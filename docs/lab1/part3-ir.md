## 中间代码生成

### IR

[IR](https://en.wikipedia.org/wiki/Intermediate_representation)也是表示程序结构的一种方式，一般来说IR比AST更加接近汇编，但是仍然保存了一些程序中的高级信息，因此比汇编更加容易优化。

IR有很多种类，包括三地址码([Three Address Code](https://en.wikipedia.org/wiki/Three-address_code), TAC)，静态单赋值形式([Static Single Assignment Form](https://en.wikipedia.org/wiki/Static_single_assignment_form), SSA)，基于栈的IR，等等。如果你感兴趣的话可以自行查阅了解，这里不做要求。

我们这里使用基于栈的IR。这种IR的最大特点是中间代码生成和汇编代码生成(不追求性能的话)非常容易编写，但是一般实际的编译器都不会使用它，因为它并不适合进行优化，这样其实也就失去了IR存在的根本意义之一了。

> 类似[Java Bytecode](https://en.wikipedia.org/wiki/Java_bytecode)这样的，虽然也可以看做是基于栈的IR，但是实际的Java虚拟机中都会先把它转化成其它容易优化的形式，所以它的意义仅仅是便于生成和传输，不会用于汇编代码生成。

尽管如此，我们这个教学用的编译器还是选择使用基于栈的IR，主要目的是能够体现IR这个结构在实际的编译器中的地位，尽量让大家体会感受编译器的工作流程，只是限于课程的工作量的限制还是没法和实际的编译器做到真正的一致。

基于栈的IR顾名思义维护一个运算栈，它最主要的特点在于它的运算指令，例如加法和减法指令这些，是没有操作数的。所有的运算指令的语义都是从这个运算栈的顶部弹出操作数，进行运算后再把结果压回栈中。这里不能完全理解也没有关系，我们之后每加入新的指令时都会介绍其功能和特点。

### 本阶段用到的指令

现在唯一可能的语句是return一个常数，所以IR中完全可以只设计一条指令，也就是return一个常数，这个常数也作为指令的一部分。但是我们不推荐这样的设计，因为这样完全无法兼容后面的新语法，之后可以return一个变量之后，这条return常数的指令事实上是完全用不上了，所以反而总工作量还变大了。

我们的建议是设计两条指令：

- PUSH指令，指令中还包含一个常数，语义是将这个常数压入栈中
- RET指令，语义是将栈顶的值弹出，将这个值作为返回值结束程序

对于一条return常数的指令，就依次生成这两条指令即可。


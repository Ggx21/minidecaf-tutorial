# 左值
step5 已经提过，赋值表达式中 `=` 左边必须是左值（lvalue），不能 `1+3 = 5`，
但当时我们直接在语法上限定了这个条件，没有深入讨论左值。
而 step11 中 `&` 的操作数也必须是左值，`&(2+3)` 是没有意义的，
但语法上已经没有这个的保证了
> 因此 lvalue 的 l 除了 left，又有人说是 location 的意思。
> 因为比起“能出现在赋值 = 的左边”，左值更本质的特征是，左值是一个 **有地址的值**（所以才能 `&`）。

一些例子如：
```c
int a; int* p;
a   = 1;    // a    是左值；    1       不是
*&a = 2;    // *&a  是左值；    2, &a   不是
p   = &a;   // p, a 都是左值；  &a      不是
*p  = 3+a;  // *p   是左值；    3, a, 3+a 都不是
```

由上容易看出：
1. 左值作为操作数时，进行操作需要的是 **它的地址**；
    > 例如上面 `a=1` 不需要读取 `a` 的值，但需要 `a` 的地址以便把 1 保存到该地址。
2. 非左值（即“右值”，像几个常量和最后一行的 `a`），操作需要知道的是 **它的值**；
    > 例如上面 `3+a` 需要的是 `a` 的值（对 `a` 的地址做 load 操作就能加载到 `a` 的值）。
3. 一个表达式（例如 `a`）可能有时是左值有时不是，取决于它出现在哪儿。

接着上面第 3. 点说，一个表达式要是左值，需要满足两个条件：
1. 能利用如下规则（语义规范 11.1）构造出来
    1. 被声明过的变量是左值；
    2. 如果 `e` 是左值，那么括号括起的 `(e)` 也是左值。
    3. 如果 `e` 是类型为 `T*` 的表达式，那么 `*e` 是类型为 `T` 的左值。
        > 如果程序没有类型错误，则 `*e` 一定是左值，地址是 `e` 的值。
2. 出现在需要左值的地方（`&` 操作数、`=` 左边）
    > 如果需要左值的地方不是左值（例如 `1+2=3`），那么就要报错。（语义规范 5.5, 11.3）

和上面说的一样，生成代码的过程中，对于左值要生成它们的地址，右值要生成它们的值。
生成左值地址比较容易：
1. 如果左值是变量，其地址就是变量的地址（一个 `frameaddr` 或者 `globaladdr`）
2. 如果左值是解引用得到的 `*e`，其地址就是 `e` 的值
    > （语义规范 11.3）所以 `&*e` 等价于 `e`，但它不是左值了
3. 括起的左值 `(e)` 的地址就是 `e` 的地址


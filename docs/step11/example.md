# step11 实验指导

本实验指导使用的例子为：

```C
int x[10];
int main() { int y[10]; return 0; }

```

## 词法语法分析

针对数组，我们需要设计 AST 节点来表示它，给出的参考定义如下：

| 节点 | 成员 | 含义 |
| --- | --- | --- |
| `IndexExpr` | 索引基底 `base`，索引下标 `index` | 索引运算 |

## 语义分析

由于 Step11 里引入了数组，现在我们的变量类型不只是 int 型了，还包括 int 型数组。因此，为了保证所有表达式中变量的类型均合法，需要进行类型检查。

在[类型系统](./typesystem.md)里我们给出了类型系统的形式化定义，同学们可以参考。

### Python 框架

`frontend/type/array.py` 里实现了数组类型，同学们可以使用它完成实验，也可以自行对其进行修改。

### C++ 框架

`type/type.hpp` 中的 ArrayType 表示数组类型，同学们可以使用它完成实验，也可以自行对其进行修改。

## 中间代码生成

数组和普通变量类似，可以分为局部数组和全局数组。

全局数组的处理与全局变量类似，由于是升级关卡，我们留给同学**自行思考**（和全局变量究竟有什么不同，是不是需要的内存空间更大？）。

局部数组我们给出一种参考实现，实际上不只有一种实现方法。参考实现中，我们定义了一条中间代码指令 ALLOC 用于分配内存：

| 指令 | 参数 | 含义 |
| --- | --- | --- |
| `ALLOC` | `size` | 分配 size 字节的内存，并返回内存首地址 |

依据参考实现的方法，测试样例可以被翻译为如下的中间代码（忽略全局数组部分）：

```
main:
    T0 = ALLOC 40 # 一个 int 类型为 4 个字节
    T1 = 0
    return T1
```

通过这种方式，我们实际上是把内存分配的锅甩给了目标代码生成，这大大提升了目标代码生成的自由度，属于合理分锅。

我们还需要考虑如何访问数组元素。通过 ALLOC 指令我们得到了数组的首地址，那么任何一个数组元素的地址为在首地址的基础上加上偏移得到。于是读取数组元素可以使用 Step10 中引入的 LOAD 指令实现，我们还需要引入一条类似的 STORE 指令实现写入数组。

那么，如何将数组下标对应到地址偏移？对一维数组，下标和偏移只差一个常数倍（int 型的大小为 4 个字节）的区别。而对于高维数组，我们可以将之看作一个一维大数组。对于一个数组 a[d1][d2]...[dn]，访问 a[i1][i2]...[in] 就等价于访问 a[i1*d2*d3*...*dn + i2*d3*...*dn + ... + in]。在将数组索引翻译成 TAC 时，同学们需要自行将数组下标转换成地址计算指令。这个步骤并不困难，但可能比较繁琐，同学们实现时要注意各种细节。

## 目标代码生成

同中间代码生成，全局数组**自行思考实现**。

对于局部数组的内存分配，我们推荐在栈上为局部数组分配所需的空间，实际上，Step5 栈帧中**局部变量区域**，在我们的实验中就是为局部数组准备的。因此你要做的就是，模仿开辟栈帧的操作，对栈顶指针 sp 进行一定的修改，在栈上开辟出一块连续内存，并将这块内存的首地址返回即可。后续如有对数组中元素的访问，根据首地址进行偏移操作即可。


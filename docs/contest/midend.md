# 中端设计

中端的设计包括两个部分：中间表示的设计和中端优化。

## 中间表示

前端的解析和中端设计密不可分，通常，我们需要设计一个中间表示（Intermediate Representation, IR）来连接前端和后端。也只有我们定义好了中间表示，前端才知道怎么处理AST。

### 什么是中间表示？

中间表示（也称中间代码，intermediate representation / IR）是介于语法树和汇编代码之间的一种程序表示。 它不像语法树一样保留了那么多源程序的结构，也不至于像汇编一样底层。

由于源语言（MiniDecaf）和目标语言（RISC-V 汇编）一般存在较大的差别，因此直接把源语言翻译为目标语言中的合法程序通常是比较困难的。大多数编译器实现中所采取的做法，是首先把源语言的程序翻译成一种相对接近目标语言的中间表示形式，然后再从这种中间表示翻译成目标代码。中间表示（IR）的所带来的优势如下：

- 缩小调试范围，通过把 AST 到汇编的步骤一分为二。如果目标代码有误，通过检查 IR 是否正确就可以知道：是AST 到 IR 翻译有误，还是 IR 到汇编翻译有误。 将 AST 转换到汇编的过程分成两个步骤，每个步骤代码更精简，更易于调试。
- 适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, C, Java...）。由于不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块。如果有了 IR，只需要写 N 个 IR 生成器和 M 个汇编生成器，只有 N + M 个模块。

- 便于优化，中间表示可以附带一些额外信息，比如类型信息、控制流信息等，这些信息辅助编译器进行优化。

### 中间表示的设计

#### 三地址码



#### 静态单赋值

> 静态单赋值这一小节改编自：
> https://buaa-se-compiling.github.io/miniSysY-tutorial/challenge/mem2reg/help.html
> 在此表示感谢！

静态单赋值（Static Single Assignment, SSA）是编译器中间表示（IR）阶段的一个重要概念，它要求程序中每个变量在使用之前只被赋值一次。

例如，考虑使用 IR 编写程序计算 1 + 2 + 3 的值，一种可能的写法为：

```assembly
_T0 = 1
_T1 = 2
_T2 = 3
_T3 = _T0 + _T1
_T3 = _T3 + _T2
return _T3
```
很遗憾，上述程序并不符合 SSA 的要求，因为其中变量 _T3 被赋值了两次。正确的写法应该为：
```assembly
_T0 = 1
_T1 = 2
_T2 = 3
_T3 = _T0 + _T1
_T4 = _T3 + _T2
return _T4
```
#### 我们为什么要这样做呢？

因为 SSA 可以简化每个变量的属性，进而简化编译器的优化过程。

例如，考虑下面这段伪代码：

```assembly
y := 1
y := 2
x := y
```
很显然，其中变量 y 的第一次赋值是不必须的，因为变量 y 被使用前，经历了第二次赋值。对于编译器而言，确定这一关系并不容易，需要经过定义分析（Reaching Definition Analysis）的过程。在很多控制流复杂的情况下，上述过程将变得更加困难。

但如果将上述代码变为 SSA 形式：

```assembly
y1 := 1
y2 := 2
x1 := y2
```
上述关系变得更加显而易见，由于每一个变量只被赋值一次，编译器可以轻松地得到 x1 的值来自于 y2 这一信息。

正因如此，许多编译器优化算法都建立在 SSA 的基础之上，例如：死代码消除（dead code elimination）、常量传播（constant propagation）、值域传播（value range propagation）等。

#### 我们如何实现 SSA 呢？

例如，考虑使用 IR 编写程序使用循环计算 5 的阶乘。

按照 C 语言的思路，我们可能给出如下写法：

```assembly
_L0:
  _T0 = 0
  _T1 = 1
  _T2 = 2
  _T3 = ADD _T0, _T1  # int temp = 1
  _T4 = ADD _T0, _T2  # int i = 2
  _T5 = 5
_L1:
  _T6 = LT _T4, _T5   # i < 5
  BEQZ _T6, _L3
_L2:                  # loop label
  _T3 = MUL _T3, _T4  # temp = temp * i
  _T4 = ADD _T4, _T1  # i = i + 1
  JUMP _L1
_L3:                  # break label
  return _T3
```
我们注意到，变量 _T3 和 _T4 由于循环体的存在可能被赋值多次，因此上述写法并不符合 SSA 的要求。

一种可能的方案是使用 Phi 指令。Phi 指令的语法是 `<result> = PHI [<val0>, <label0>], [<val1>, <label1>] ...` 。它使得我们可以根据进入当前基本块之前执行的是哪一个基本块的代码来选择一个变量的值。

由此，我们的程序可以改写为：

```assembly
_L0:
  _T0 = 2
  _T1 = 1
_L1:
  _T2 = PHI [_T0, _L0], [_T6, _L2]  # int i = 2
  _T3 = PHI [_T1, _L0], [_T7, _L2]  # int temp = 1
  _T4 = 5
  _T5 = LT T2, _T4                  # i < 5
  BEQZ _T5, _L3
_L2:                                # loop label
  _T7 = MUL _T3, _T2                # temp = temp * i
  _T6 = ADD _T2, _T1                # i = i + 1
  JUMP _L1
_L3:                                # break label
  return _T3
```
由此，上述程序中每一个变量只被赋值了一次，满足了 SSA 的要求。（注意，SSA 仅要求变量在静态阶段被单一赋值，而不是在运行时仅被赋值一次）

另一种可能的方案是使用 Alloca、Load 和 Store 的组合。SSA 要求中间表示阶段虚拟寄存器满足单一赋值要求，但并不要求内存地址如此。因此，我们可以在前端生成中间代码时，将每一个变量都按照栈的方式使用 Alloca 指令分配到内存中，之后每次访问变量都通过 Load 或 Store 指令显式地读写内存。使用上述方案编写的程序满足 SSA 的要求，且避免了繁琐地构造 Phi 指令，但频繁地访问内存将导致严重的性能问题。

#### 有没有更好的解决方案呢？

有，我们可以将两种方案结合起来。

在前端生成中间代码时，首先使用第二种方案利用 Alloca、Load、Store 指令快速地构建满足 SSA 要求的代码。
随后，在上述代码的基础上， 将其中分配的内存变量转化为虚拟寄存器，并在合适的地方插入 Phi 指令。
这一解决方案也被称为 mem2reg 技术。

## 中端优化

中端的优化是编译器的一个重要组成部分，它可以在保持程序功能不变的前提下，提高程序的性能。中端优化的目标是提高程序的性能，减少程序的运行时间和资源消耗。中端优化的方法有很多，比如常量传播、死代码消除、循环不变量外提、循环展开、函数内联等。

一个经典的例子是常量传播。常量传播是指将一个常量值替换为它的值，以便于在中端直接完成一些计算以降低运行时开销。比如，对于下面的 IR 代码：

```asm
_T1 = 5
_T2 = _T1 + 6
_T3 = _T2 + 7
_T4 = _T3 + 8
_T5 = _T4 + 9
ret _T5
```

经过常量传播优化后，可以得到：

```asm
_T1 = 5
_T2 = 11
_T3 = 18
_T4 = 26
_T5 = 35
ret _T5
```

进一步如果我们进行死代码消除，可以得到：
> 什么是死代码消除？
> 死代码消除是指删除程序中没有用到的代码，以减少程序的运行时间和资源消耗。

```asm
_T5 = 35
ret _T5
```

### 预期目标

完成这部分内容后，你的编译器应该能将 MiniDecaf 程序翻译成 IR，并能够输出 IR。进一步地，如果你希望参加大实验，你还需要实现一些中端优化。


# 死代码消除

死代码消除即无用代码消除，死代码和不可达代码是两个概念。前者指的是执行之后没有任何作用的代码（例如：多余的计算），后者指的是永远无法被执行到的代码。

活跃变量分析为每个程序点计算出所有变量的集合的子集，用于表示该点处活跃的变量，所以数据流分析的值集为所有变量的集合的幂集。"活跃"的含义是在程序执行过这一点**之后**，这个变量**当前的值**会被使用到，所以数据流分析是后向的。对于单个语句$S$，传递函数要根据$S$之后活跃的变量计算$S$之前活跃的变量，计算方法为：所有$S$用到的变量在$S$之前都是活跃的，所有$S$之后活跃的变量，如果没有在$S$中被定值，证明未来的那次使用用的还是$S$之前的值，所以也是活跃的。

这里讲一下几个常见的需要注意的点：

进行死代码删除的时候，如果一条语句**没有副作用**，而且它的赋值目标(如果有的话)不在$out_S$中，那么这条语句就可以删去
   - 所谓的副作用，其实就是除了"改变赋值目标变量"之外，其他所有的作用。显然，tac中没有既没有副作用，同时也没有赋值目标的语句
   - 你在实现的时候可以认为除了`a = call b`之外的所有有赋值目标的语句都是没有副作用的，对于`a = call b`，如果$a \notin out_S$，要求将它优化为`call b`

其实还有一些语句的"副作用"不是很明确，比如除0，有符号整数溢出等(依平台而定)，可能会导致程序崩溃，但是**优化的时候可以不把这当成是副作用**：按照c/c++常用的说法这叫未定义行为，这可以减轻编译器作者的负担，编译器可以假定程序永远没有未定义行为，并以此为依据来优化。

我们的测试样例中不会出现未定义行为，所以可以放心地忽略掉这些副作用。
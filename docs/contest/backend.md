# 后端设计

编译器后端的主要功能是将中间表示（IR）转换为目标架构的汇编代码，在我们的课程实验中即将TAC翻译为RISC-V汇编代码。与目标机器架构紧密相关的优化也会在这一阶段进行。

## 代码生成

目标代码的生成是后端的核心部分。通常中间表示不会与目标架构的汇编代码非常相似，一方面它们所用的指令不一样，另外中间表示也会省略掉与物理寄存器和函数调用的若干细节。这要求我们在将IR翻译为汇编指令时处理好这些缺失的部分，生成合法的汇编程序。

### 指令选择

对于一条IR指令，选择合适的汇编指令对应物。对于大部分算术指令，一对一翻译即可，这没有什么难度；而某些IR指令没有直接的相应汇编指令，需要被翻译为多条汇编指令。你可能需要选择相对更优的候选指令序列。一对多指令翻译包含一些微妙之处，比如可能引入额外的寄存器、有潜在的副作用、干扰数据流分析，有时将它们视为一个指令整体是更合理的选择。你可能需要恰当地选择将一条“指令”彻底地转化为汇编指令的时机。

这里举几个例子：

- 逻辑与和逻辑或。可详见step4。
- 函数调用。函数调用通常不止一条call指令，在它之前需要生成传参的指令（参数少时用mv，多的时候压栈），在它之后可能要修改栈指针。
- SSA IR中的Phi指令。通常Phi指令会被翻译为mv指令，但留意多条Phi指令同时存在的情况，它们在语义上“同时发生”，而实际指令序列具有顺序，这可能导致寄存器中的值被错误覆盖。

### 寄存器分配

IR里通常会假设数量无限的虚拟寄存器（或称作变量），但目标ISA（Instruction Set Architecture）通常只允许有限数量的物理寄存器，我们必须将虚拟寄存器映射到物理寄存器上。如果物理寄存器无法容纳所有的活跃变量，它们就需要溢出（spill）到栈上。大多数架构上寄存器访问开销显著低于内存访问开销，因此我们应尽量避免发生spill。

课程实验使用的寄存器分配算法非常简单，它以基本块为单位，在基本块结束处活跃的变量会全部被spill到栈上。你会发现这个算法显得比较愚蠢，产生了大量实际无用的load和store指令。因此，你需要实现一个“全局”的寄存器分配算法，它应当能够跨基本块进行分析。（这里的“全局”通常以函数为粒度）

常见的全局寄存器分配算法包括图染色和线性扫描。由于我们并没有较为严格的编译时间要求，大家可以使用**step13**中提到的图染色算法。该算法的一个优势在于能够顺带处理mv指令，可以消除掉无用复制，这使得你前面做代码生成时可以轻松一点。

寄存器分配算法中存在一个比较微妙的地方：当我们不得不选择一个变量spill时，优先选择哪个变量。通常这里是启发式的，我们需要对每个变量设置一个优先级或溢出权重（spill weight）。假设我们已知一个变量中存放的是常数，那么它的保存和恢复开销都会比其它变量更低：无须保存，恢复时只需一条li指令而不必生成load。这种低spill开销的变量可以优先成为被踢出内存的倒霉蛋候选。（思考：我们是否应该优先spill循环体中的变量？）为了给变量设定合理的溢出权重，你可能需要依赖一些分析pass的结果。

### 栈帧确定和最终代码生成

在代码生成的早期阶段我们无法确定最终栈帧的大小。比如在寄存器分配阶段产生的溢出变量会使得栈帧大小增加，我们需要追踪栈上变量的偏移量和大小。留意load和store指令中允许的立即数偏移范围，当一个函数具有巨大的栈帧时，你可能需要插入一些额外的代码来计算栈上的地址或访问栈上的变量，甚至需要重新进行寄存器分配。

确定栈帧后生成函数的prologue和epilogue，其中主要包括callee-saved寄存器的保存与恢复、对栈指针的调整。注意有些架构可能对栈指针有对齐要求（e.g. 必须是8的整数倍）。

## 目标架构相关优化

这里简单地举几个例子。

1. 指令选择相关的窥孔优化

    此类优化指的是将局部的几条指令替换为更优的指令序列的一类优化，并非特指。需要注意的是此类优化较为琐碎，建议按需实现。

    例如以下的RISC-V指令序列
    ```assembly
    li t0, 0
    bne a0, t0, label1
    ```

    可以被替换为`bne a0, zero, label1`，后续再通过无用指令消除去掉`li t0, 0`（假设该值不再使用）。总的来说，一类优化机会包括识别出指令序列中的常量，尝试将它们嵌入至指令中（RISC-V的I型指令），并进行无效果指令消除（mv到自身、加0、乘1）、强度削减（乘除2的幂转移位，除法转乘法）等优化。

    再举一个ARM的例子。ARM的访存指令支持基址+索引*4的寻址模式（类似x86），以下汇编指令序列
    ```assembly
    mov r1, r1, LSL #2
    add r0, r0, r1
    ldr r0, [r0]
    ```

    可以被合并为一条指令：
    ```assembly
    ldr r0, [r0, r1, LSL #2]
    ```

    这种汇编代码模式在数组访问中较为常见。

2. 指令调度

    指令调度指的是在不影响指令逻辑的前提下调整指令的顺序，目的之一是利用现代处理器的特性提升指令级并行度。基本块内的指令调度首先会利用指令间的依赖关系构造DAG，然后利用关键路径长度、寄存器压力、处理器发射宽度等因素结合处理器功能单元的执行模型依次决定指令的执行顺序。感兴趣的同学可以自行查看相关资料。

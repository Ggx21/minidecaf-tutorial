## 代码生成

我们需要把局部变量保存在某个地方。简单起见，我们会把它们保存在栈上。我们还需要记住每个变量在栈上保存的确切位置，以便我们以后可以引用它。

如何在编译时知道一个变量的位置呢？绝对的内存地址要到运行时才能确定，结合栈帧的知识，编译时我们可以通过`fp`以及固定的偏移来获取特定变量。

### 建立栈帧

当一个函数(我们称它为`f`)返回时，它的调用者需要能够接上它离开的地方。这意味着它的栈帧，以及`sp`和`fp`中的值，都需要和`f`被调用之前完全一样。被调用时，`f`需要做的第一件事就是为自己建立一个新的栈帧，使用下面的指令。

```
addi sp, sp, -framesize
sd ra, framesize-8(sp)
sd fp, framesize-16(sp)
addi fp, sp, framesize
```

这些指令称为函数前序（function prologue）。其中, framesize = 变量数量 * 8 + 16，注意，目前我们所有的变量长度都为8。

在`f`返回之前，它立即执行函数前序来删除这个栈帧，让一切都和函数前序之前一样。

```
ld fp, framesize-16(sp)
ld ra, framesize-8(sp)
addi sp, sp, framesize
ret
```
这被称为函数收尾（function epilogue）。到目前为止，我们可以不需要函数前序（function prologue）或函数收尾（function epilogue），但添加它们将减少后续面对跳转和函数时的困难。

有了这些准备：
- **可以将变量位置保存为`fp`的偏移量**。我们知道`fp`到`sp`上面没有任何东西（因为我们在函数前序中设置了一个空的堆栈框架），而且我们知道`fp`在函数收尾之前不会改变。
- 我们可以安全地将局部变量推送到栈上，而不改变调用者的栈帧。

我们应该在函数定义的开始处生成函数前序，就在函数的标签之后，并在函数末尾生成函数收尾。

需要注意的是，我们需要改写之前我们的 RET 指令，它应当跳到函数收尾而不是直接 ret，考虑到目前我们没有分支指令而且只有一个函数，不改写暂时不会产生问题。

这样，我们对于变量的映射可以通过变量相对于 `fp` 的偏移来建立。现在让我们看看如何处理变量的声明、赋值和引用。

### 变量声明

在代码生成阶段，变量已经在函数前序中隐式声明，我们可以忽略变量声明。

### 变量赋值

目前只有变量才能作为左值，所以记得检查 assign 操作的类型（或许你已经在 parser 中进行了检查）。因为我们的变量相当于一个地址，可以通过 `sd` 指令完成变量赋值。

```
visitAssign(IR assign) {
    visit(assign.rhs);                  //计算变量值，结果压入栈中
    emitStore(assign.lhs.offset);       //进行赋值
}
```
`void emitStore(int offset)` 生成如下代码：

```asm
ld t0, 0(sp)
sd t0, 8*{offset}(fp)
```

> 注意，assign 语句存在返回值，也就会最终在栈中留下一个值。
> 因此， `a = 0;` 语句会给 `a` 赋值并在栈中留下一个 `0`，必须将这个多余的值弹出。
> \<statement\> ::= \<exp\> ";" 类型的 statement 都存在这个问题。

### 变量引用

要引用表达式中的变量，只需将其从堆栈中复制到栈顶即可：

```
visitVar(IR var) {
    emitLoad(var.offset);
}
```

```asm
ld t0, 8*{offset}(fp)
addi sp, sp, 8
sd t0, (0)sp
```
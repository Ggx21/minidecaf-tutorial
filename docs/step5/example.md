# step5 实验指导

本实验指导使用的例子为：

```C
int main() {
    int x = 2021;
    return x;
}
```

## 词法语法分析
如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。

> 注意，赋值可以被看作是一种表达式，语法规则里要体现这一点。

## 语义分析

从 step5 开始，我们需要在语义分析阶段对局部变量的规范进行检查。具体来说，我们需要名为符号表的数据结构。符号表的实现已经在框架中给出。因此，你只需要修改语义分析部分的代码，在必要时调用符号表的接口即可。

在符号表构建过程中，我们要按照语句顺序，逐一访问所有变量定义声明。在访问变量声明时，我们需要为该变量赋予一个变量符号，并将它存入符号表中。由于变量不能重复声明，在定义变量符号前需要在符号表中检查是否有同名符号。

类似地，在访问表达式时，如果遇到变量的使用，我们也需要在符号表中检查，避免使用未声明的变量。例如，如果我们将测例修改为：

```C
int main() {
    int x = 2021;
    return x + y;
}
```

那么在扫描到加法操作的 AST 结点时，会依次检查该操作的两个操作数 x 和 y。这两个操作数均为变量标识符，因此我们需要到符号表中搜索 x 和 y 对应的符号。符号 x 可以在符号表中找到（我们在扫描 `int x = 2021;` 这条语句后已经为其定义），而 y 无法找到，因此编译器需要在扫描到 y 对应的结点时报错。

符号表总是和作用域相关的。例如，在 C 语言中，我们可以在全局作用域中定义名为 "a" 的全局变量，同时在 main 函数中定义名为 "a" 的局部变量，这并不产生冲突。不过由于 Step5 还无需支持全局变量和块语句，同学们不用考虑这一点，只考虑 main 函数作用域对应的单张符号表即可。

此外，在本 step 中，我们引入了赋值操作。赋值可以看作一种特殊的二元运算，但需要注意，赋值号左侧必须为一个**左值**。具体来说，同学们需要检查赋值号左侧只能是变量名标识符。在 step11 中，我们会将左值的范围进一步包括数组元素。

### python 框架

`frontend/symbol` 目录下为符号的实现。其中 `symbol.py` 为符号类的基类，`varsymbol.py` 为变量符号。在本 step 中，同学们只需要考虑变量符号即可。

`frontend/scope` 目录下为符号表的实现。其中 `scope.py` 为作用域类，在本 step 中由于只有一个局部作用域，因此无需考虑作用域栈。同学们只需要新建一个 Scope 维护 main 函数中所有出现过的变量符号即可。

### C++ 框架

`src/symb` 目录下为符号的实现。`symb/symbol.hpp` 中，Symbol 类为符号类的基类，Variable 类为变量符号。在本 step 中，同学们只需要考虑变量符号即可。

`src/scope` 目录下为符号表的实现。`scope.hpp` 中，Scope 类为作用域基类，其下有 GlobalScope（全局作用域）、FuncScope（函数作用域）、LocalScope（局部作用域）等子类。在本 Step 中由于只有一个局部作用域，因此无需考虑作用域栈。同学们只需要新建一个 Scope 维护 main 函数中所有出现过的变量符号即可。

建立符号表后，需要记录哪个语法树结点对应哪个符号。为此，你可以使用在语法树结点中以 ATTR 宏标记的成员变量，或增加额外的成员变量以供记录。框架中，宏 ATTR 用以区别语法树结点本身的成员变量和中端新纪录的成员变量。这个宏只是给成员变量修改了名字，并无其他语义。例如 VarDecl::name 是语法树结点本身的成员变量，表示变量名；而 VarDecl::ATTR(sym) 则是新增的成员变量，记录此变量对应的符号。

## IR 生成

我们首先来看 step5 测试用例所对应的中间代码：

```assembly
main:
	_T1 = 2021                  
    _T0 = _T1                    
    return _T0 
```

从中间代码中我们不难看出，step5 我们虽然引入了变量的概念，但是在比较低级的中间代码上，数据的存储和传递仍然是基于虚拟寄存器进行的。由于 MiniDecaf 语言中的基本类型只有 int 型，而 TAC 里的临时变量也是 32 位整数，因此，我们可以把 MiniDecaf 局部变量和 TAC 临时变量对应起来。

在扫描到 `int x = 2021;` 这条语句时，中间代码先把立即数 2021 加载到临时变量 _T1 中，然后再把 _T1 的值赋给临时变量 _T0 ，此时 _T0 已经成为了变量 x 的“替身”。每次需要用到变量 x 的值时，我们都会去访问 _T0。例如，测例中直接用返回 _T0 代替了返回变量 x 的值。因此，为了在后续使用变量 x 时能快速找到 _T0 这个临时变量，在符号表中存储 x 这个符号时，应当为该符号设置一个成员，存储 x 对应的临时变量。每当在 AST 上扫描到一个变量标识符结点时，我们都直接调用该变量对应的临时变量作为结点的返回值。

### python 框架

请注意 `frontend/symbol/varsymbol.py` 中，变量符号的定义里有该变量对应的 TAC 临时变量成员。

### C++ 框架

假设 tr 是一个 TransHelper 类（用于创建 TAC 的辅助类）的对象。对于一个 Variable（变量符号）对象 sym，可通过 sym->attachTemp(tr->getNewTempI4()) 为其分配一个 int 类型的临时变量。分配后，可通过 sym->getTemp 获取此临时变量。

## 目标代码生成
在 step5 中我们已经引入了变量的概念，然而在中间代码仍然使用虚拟寄存器存储和传递数据，在中间表达中，变量的值也存储在部分虚拟寄存器中。你或许会有疑问，如果我在程序里定义了很多个变量，甚至超过了目标机器实际拥有的物理寄存器，会不会出现寄存器数据覆盖造成的错误呢？答案是肯定的，如果我们仅仅是按照虚拟寄存器定义的顺序分发物理寄存器的。实际的编译器设计中，有一系列算法称为**寄存器分配算法**。寄存器分配算法负责调度和分配有限的物理寄存器资源，保证所有的**临时变量（虚拟寄存器）**都有合适的物理寄存器跟它相对应，且在程序执行的任何时刻，不会出现寄存器分配冲突（即两个同时有效且将被用到的临时变量被分配到同一个物理寄存器），寄存器分配冲突会造成程序运行结果的错误。然而，理想寄存器分配问题是 **NP 完备的**（可归约成 3-SAT 问题），这意味着对于一个含有几百个变量的程序，为了获得理想的寄存器分配方案，编译器需要消耗大量的时间来进行运算。因此，实际的编译器中均只追求获得该问题的近似最优解。我们的实验框架中，使用了一种简单的基于**活跃性分析**暴力分配算法，下面我们将对这个暴力算法做简单介绍。

### 暴力寄存器分配算法

我们的暴力寄存器分配算法是基于活跃性分析的，关于活跃性分析，为了避免一次实验包含太多知识，我们将会在 step8 详细介绍活跃性分析的相关理论。你现在只需了解，活跃性分析是为了求解当前临时变量是否还会在后续的程序中被用到。

基于活跃性分析的暴力寄存器分配算法的基本思路为：针对每一条中间代码指令（例如 _T2 = ADD _T1, _T0），对于每条指令的源操作数（本例中 _T1 和 _T0），我们查看是否已经放在寄存器里面，如果不是则分配一个寄存器并从**栈帧**中把该变量加载进寄存器中；对于每条指令的目标操作数（本例中 _T2），如果它还没有跟某个寄存器关联，则分配一个新的寄存器给它。

当分配寄存器的时候，我们首先查看有没有寄存器是空闲的（即尚未跟某个临时变量关联），有则选择该寄存器作为分配结果。否则看查看有没有寄存器所关联的临时变量在当前已经不是活跃变量了，这说明该寄存器所保存的数据已经不会被用到了，我们可以放心的把这个寄存器交待分配的临时变量而不用担心数据缺失的问题。最糟糕的是，当前所有寄存器所关联的变量都是活跃的，这说明没有空闲寄存器可以被用于分配，我们的做法是把某个寄存器所关联的现在暂时不用的变量“扔”到栈帧（内存的一部分）中，从而腾出这个寄存器。选取受害者寄存器的方法是随机选取，这也是为什么我们的分配算法叫暴力算法。

细心的同学或许已经注意到了，我们在分配寄存器的时候提到了**从栈帧中加载数据**及**将暂时不用的变量存储到栈帧**中，那么什么是栈帧呢？

### 栈帧

1. 栈帧的概念

   汇编语言课上提到过**栈帧**的概念，简单回想一下：每次调用和执行一个函数，都会在栈上开辟一块新的空间，这片空间就叫做“栈帧”，栈帧中存放了函数执行所需的各种数据，包括需要临时保存的局部变量、在栈上临时申请的存储空间（如数组，我们在 step11 中会讲到）、被调用者负责保存的寄存器等等。栈帧是函数正确调用和执行的保证。

   > 需要注意的是，由于我们目前只支持一个 main 函数，直到 step9 才会有多函数支持。所以现在关于栈帧的讨论，就只针对 main 函数的栈帧，并且集中于临时变量的存储和加载。

   下图给出了一个函数的栈帧，我们假设当前函数被某个函数调用。如图所示，当前函数的栈帧由被调用者负责保存的寄存器、保存的临时变量以及局部变量三个部分组成，fp 指向当前栈帧的栈底，sp 指向当前栈帧的栈顶，fp 和 sp 之间的部分就是当前函数的栈帧。当前步骤中，我们需要关注的是临时变量保存区域，正是在这片区域中，保存了寄存器分配中被踢出原来寄存器，但是仍活跃的临时变量。值得一提的是，临时变量保存区域中还保存了基本块出口仍活跃的临时变量，关于基本块的概念，我们将在 step8 提出，这里你只需要知道临时变量保存区域不只有被踢出寄存器的“受害者变量”即可。

   ![ ](./pics/stack.png)

2. 栈帧的建立与销毁

   栈帧是函数运行所需要的上下文的一部分，在进入函数的时候需要建立自己的栈帧，在退出函数的时候需要销毁自己所建立的栈帧。既然栈帧如此重要，程序在运行的过程中应该怎么建立和销毁呢？实际上，建立栈帧的操作是由编译器生成代码完成的。每个函数最开始、由编译器生成的用于建立栈帧的那段汇编被称为函数的 **prologue**，prologue 需要做的事情有：分配栈帧空间、保存相应寄存器。相应的，函数末尾、用于销毁栈帧的一段汇编叫函数的 **epilogue**，epilogue 需要做的事情有设置返回地址、回收栈帧空间以及从当前子过程返回。

   听上去创建和销毁栈帧是一个大工程？实际上，确定栈帧，我们只需要维护好两个寄存器就可以了：sp 和 fp，它们分别保存当前栈帧的栈顶地址和栈底地址。当新的函数被调用，我们需要把旧栈帧的栈底地址（fp）保存起来，用旧栈帧的栈顶地址（sp）表示新栈帧的栈底地址（新fp）。不难看出，新老栈帧在栈内存中是连续的空间。此外，每个函数体中需要分配的局部变量以及需要保存的临时变量在编译器都是可知的，因此，栈帧的大小在编译期也是可知的：保存寄存器的空间+临时变量保存空间+局部变量空间。在获得栈帧大小之后，我们通过适当修改栈顶指针（sp）的值，分配恰当的栈帧空间。

   实际上，我们在实验框架中已经给出了寄存器分配以及栈帧创建、销毁的代码，下面我们就给出代码所在的位置，感兴趣的同学可以参考代码和注释进行深入学习。

   **python 框架**：

   寄存器分配算法主要集中在 backend/reg/bruteregalloc.py 中，主要有以下几个函数：

   1. accept：根据每个函数的 CFG 进行寄存器分配，寄存器分配结束后生成相应汇编代码
2. bind：将一个 Temp 与寄存器绑定
   3. unbind：将一个 Temp 与相应寄存器解绑定
   4. localAlloc：根据数据流对一个 BasicBlock 内的指令进行寄存器分配
   5. allocForLoc：每一条指令进行寄存器分配
   6. allocRegFor：根据数据流决定为当前 Temp 分配哪一个寄存器
   
   **C++ 框架**：
   
   寄存器分配算法主要集中在 src/asm/riscv_md.cc 中，主要有以下几个函数：
   1. getRegForRead：为源操作数对应的临时变量分配寄存器。
   2. getRegForWrite：为目标操作数对应的临时变量分配寄存器。
   3. selectRegToSpill：选择寄存器不足时，溢出到栈内存的寄存器，目前是随机算法。
       栈帧建立和销毁分别位于 emitProlog 函数和 emitTrace 函数中。

# 思考题

1. 描述程序运行过程中函数栈帧的构成，分成哪几个部分？
2. 有些语言允许在同一个作用域中多次定义同名的变量，例如这是一段合法的 Rust 代码（你不需要精确了解它的含义，大致理解即可）：

```Rust
fn main() {
  let a = 0;
  let a = f(a);
  let a = g(a);
}
```

其中`f(a)`中的`a`是上一行的`let a = 0;`定义的，`g(a)`中的`a`是上一行的`let a = f(a);`。

如果 MiniDecaf 也允许多次定义同名变量，并规定新的定义会覆盖之前的同名定义，请问在你的实现中，需要对定义变量和查找变量的逻辑做怎样的修改？

# 总结

Step5 主要涉及的知识为符号表、寄存器分配和栈帧，对于大家来说有一定的跳跃性和挑战性，希望大家能够尽早开始。
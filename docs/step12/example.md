# step12 实验指导

本实验指导使用的例子为：

```C++
int func(int param[]){
    param[0] = 1;
    return 0;
}

int main() { 
    int arr[4] = {1,2};
    func(arr);
    return arr[0] + arr[1] + arr[2];
}
```

## 词法语法分析

我们需要增加一个数组的初始化列表，可以直接修改上一节数组的AST结点增加一个数组用于记录初始化元素。

函数的参数列表需要加上数组类型。

## 语义分析

由于 Step12 里额外引入了数组传参和数组初始化，所以你需要修改语义分析，以支持数组传参。传参出现了一种特殊情况，即：函数参数数组的第一维可以为空

```c++
int fun(int a[][12]){
	a[0][1] = 1;
    return 0;
}
```

## 中间代码生成

在C语言中，对于全局数组，如果没有初始化，那么其值全为0，而对于局部数组来说，如果没有初始化，其值是未定义的。

而初始化后数组的元素值是确定的，如果初始化时指定的的元素个数比数组大小少，剩下的元素都回被初始化为  0。例如：

```c
int arr[4]={1,2};
// 等价于
int arr[4]={1,2,0,0};
```

因此你可能需要内置一个`__my_memset`这样的函数来实现数组数组的清零，这里采用`__my_memset`这个名字是为了防止与stdlib中的`memset`冲突。

> 当然你也可以直接调用标准库中的memset函数，但是由于我们在函数一节推荐大家的实现方法并没有按照RISC-V 的标准调用约定实现，所以你可能需要特殊处理一下调用外部函数的寄存器。
>
> 你不妨试试自己写一个带初始化的局部数组，看看gcc是怎么做的，也可以看看传参所使用的寄存器是哪几个，这样就可以免去自己内置memset函数的工作。

实际上上述初始化可以等价地转化为：

```c++
int arr[4];
__my_memset(arr, 0, sizeof(int) * 4);
a[0] = 1;
a[1] = 2;
```

# 目标代码生成

数组传参相对于初始化是简单的，回想函数一节的传参方式，**自行实现**。

下面主要讲解数组初始化：

假如你之前实现的函数调用不是RISC-V 的标准调用约定，`__my_memset`函数对应的汇编代码不会写，而gcc生成的和我们想要的不一样应该怎么办？

在你实现数组传参之后，就可以用你自己的编译器生成一份自己的`__my_memset`

例如：

```c++
int __my_memset(int arr[], int n, int size){
    // 这与标准的memset实现是不一样的
    // 由于我们知道我们的函数只用于初始化数组
    // 传入的n只可能为0，因此这样做也是可以的
    size = size / 4;
    for(int i = 0; i < size; i = i + 1){
        a[i] = 0;
    }
    return 0;
}
```

然后用自己的编译器生成一份汇编代码，嵌入到自己的后端即可。

需要注意的是：在生成函数时，编译器会自动给每个函数调用和函数名称前面加上下划线，来防止名字冲突，所以如果出现链接错误时，请先检查生成的汇编代码的函数名称和调用处的函数名称。

# 思考题


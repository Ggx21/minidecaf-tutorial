# step12 实验指导

本实验指导使用的例子为：

```C++
int func(int param[]){
    param[0] = 1;
    return 0;
}

int main() { 
    int arr[4] = {1,2};
    func(arr);
    return arr[0] + arr[1] + arr[2];
}
```

## 词法语法分析

我们需要增加一个数组的初始化列表，可以直接修改上一节数组的AST结点增加一个数组用于记录初始化元素。

函数的参数列表需要加上数组类型。

## 语义分析

由于 Step12 里额外引入了数组传参和数组初始化，所以你需要修改语义分析，以支持数组传参。传参出现了一种特殊情况，即：函数参数数组的第一维可以为空

```c++
int fun(int a[][12]){
	a[0][1] = 1;
    return 0;
}
```

## 中间代码生成

在C语言中，对于全局数组，如果没有初始化，那么其值全为0，而对于局部数组来说，如果没有初始化，其值是未定义的。

而初始化后数组的元素值是确定的，如果初始化时指定的的元素个数比数组大小少，剩下的元素都回被初始化为  0。例如：

```c
int arr[4]={1,2};
// 等价于
int arr[4]={1,2,0,0};
```

因此你可能需要内置一个`memset`这样的函数来实现数组数组的清零，由于gcc自带`memset`函数，并且我们按照Step 9应该实现了Risc-V标准调用约定，因此数组清零不是一件难事

实际上上述初始化可以等价地转化为：

```c++
int arr[4];
memset(arr, 0, sizeof(int) * 4);
a[0] = 1;
a[1] = 2;
```

# 目标代码生成

数组传参相对于初始化是简单的，回想函数一节的传参方式，**自行实现**。

需要注意的是：在生成函数时，编译器会自动给每个函数调用和函数名称前面加上下划线，来防止名字冲突，所以如果出现链接错误时，请先检查生成的汇编代码的函数名称和gcc中的memset函数名称是否一致。

# 思考题


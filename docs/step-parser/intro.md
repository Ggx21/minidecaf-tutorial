# parser stage 实验指导(自顶向下语法分析)

在前面的实验中, 我们使用yacc/lex自动生成的语法分析器和词法分析器，完成了编译器的前端部分. 

这个stage主要涉及"手工"语法分析器(parser)的实现，我们将这个stage称作parser stage.

parser stage中, 我们将实现自顶向下的语法分析, 词法分析器仍然使用lex自动生成.  

### 准备工作
parser stage不涉及中端、后端部分, 所以请将你在stage2完成的中后端代码合并到parser stage的实验框架上.

对于C++, 需要将这些文件夹中stage2的代码合并过来，替换parser stage原有的代码(和start_code相同):
     
     asm,scope,symb,tac,translation,type

对于python， **TODO: 需要从stage2合并哪些文件?**

### 背景知识

如果你已经很熟悉自顶向下语法分析、自底向上语法分析的原理, 可以跳过这部分.

yacc自动生成的语法分析器,属于lalr(1)语法分析, 是**自底向上**的语法分析方法.
     
具体来说, 维护一个符号栈, 每一步进行shift将新的token加入栈顶，或reduce将栈顶的一些符号组成产生式,
 从语法树的最底层开始向上构建节点, 最终获得一棵语法树.
     
如对于算术表达式 a + b + c * (d + e),

语法为: 
    Expr -> Expr '+' Expr | Expr '*' Expr | '(' Expr ')'
    Expr -> 'a' | 'b' | 'c' | 'd' | 'e'

自底向上语法分析的过程是: 

1. 不断shift直到符号栈内包含 'a' '+' 'b', 检查下一个符号为'+', 进行一次reduce, 获得a+b组成的Expr节点,压栈
2. 继续shift直到栈内包含 Expr '+' 'c' '*' '('  'd' + 'e', 检测到下一个符号为 ')', 进行一次reduce, 获得d+e对应的Expr压栈
3. Expr '+' 'c' '*' '('  Expr ')', 继续reduce, 依次reduce括号表达式, 乘法表达式, 加法表达式, 获得最终的语法树根节点Expr. 

而自顶向下语法分析的过程是:

从解析根节点Expr开始, 从左向右读取 'a' '+' 后, 判定使用产生式Expr-> Expr + Expr,来推导根节点,将 'a' 对应为加号左侧的Expr, 将剩余的 b + c * (d + e) 对应为加号右侧的Expr, 递归解析， 用递归解析返回的结果来构造根节点。

在递归解析b + c * (d + e) 的过程中, 读取到 'b' '+', 就判定使用Expr -> Expr + Expr来进行下一步推导.

然后分别递归解析 'b' 和 c * (d + e)

接下来读取到 c * 的时候, 再次决定递归，分别推导'c' 和 (d+e)....

注意到, 尽管这里从根节点开始选择产生式，是自顶向下的, 但对语法树节点的构造, 仍需要在递归函数退出、返回下层语法树节点之后，自底向上地进行构造。
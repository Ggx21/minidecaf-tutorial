# step2 实验指导
我们按照上一节划分的编译器阶段，分阶段给出 step2 实验指导。本实验指导使用的例子为：

> 需要注意的是，我们为了简化描述，提取出了测试用例中和本步骤最相关的部分，实际的测试用例还是一个完整的，带有主函数的 MiniDecaf 程序。

```C
-1
```

## 词法语法分析
如果你使用工具完成词法语法分析，修改你的规范以满足要求，剩下的交给工具即可。
语法规范已经给出，词法规范的变化也很简单，新增三个 token：`-`、`~` 和 `!`。

> 你的规范和我们的要求等价、能通过测试即可，不用完全一样。
>
> 需要注意的是，检查时只会根据输出是否正确来判断，在一开始，你可能会使用和规范不完全一样的语法规则，也得到标准的结果。但我们强烈建议你编写的语法规则尽量和规范保持一致，否则后面增加更多的语法规则时，和规范不一致的语法规则想编译出标准的结果会越来越难。

## 语义分析

没有特别需要修改的地方。但请注意，由于现在 return 语句的返回值不再是整型常量，而是表达式，因此语义分析时需要**递归地访问运算操作结点的子结点**，才能访问到作为叶子结点的整型常量，完成 step1 中实现的整型常量越界检查。

## 中间代码生成
在 step1 中，我们只需为 return 语句的返回的整型常量分配一个临时变量即可。而从 Step2 开始，语法树上出现了各种运算操作结点。在生成 TAC 的过程中，我们需要为运算结点分配一个临时变量，并生成一条指令，该指令根据子结点的临时变量进行计算，将结果赋予该结点的临时变量。

针对取负操作，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下

| 指令 | 参数 | 含义 |
| --- | --- | --- |
| `NEG` | `T0` | 对参数取负 |

按照上文说的，-1 在语法树上对应父-子两个结点，父结点为取负操作，子结点为常量 1。在生成过程中，首先使用 Visitor 模式递归地访问子结点，我们使用一个临时变量加载该立即数。之后，在父结点，我们根据子结点的临时变量，生成一条取负指令，将这条指令得到的目标临时变量设置为父结点的临时变量。

因此，测例可以翻译成如下的中间代码：

```asm
_T0 = 1
_T1 = NEG _T0
```

## 目标代码生成
step2 目标代码生成步骤的关键点在于，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。以 NEG 中间表达指令为例，RISC-V 汇编中有 neg 指令与其对应，因此上述中间代码可以翻译为如下的 RISC-V 汇编：

```assembly
li t0, 1
neg t1, t0
```

关于目标代码生成有一个小技巧，如果你实在不知道某个运算符应该翻译成怎样的汇编代码，可以参考 gcc 的输出结果。例如，你可以通过 gcc 编译如下程序来了解如何翻译逻辑非运算符到 RISC-V 汇编（**记得加 -O3 选项**）：

```C
int foo(int x) {
    return !x;
}
```

不出意外你会获得如下结果：

```assembly
foo:
    seqz    a0,a0
    ret
```

# 思考题

1. 我们在语义规范中规定整数运算越界是未定义行为，运算越界可以简单理解成理论上的运算结果没有办法保存在32位整数的空间中，必须截断高于32位的内容。请设计一个 minidecaf 表达式，只使用`-~!`这三个单目运算符和从 0 到 2147483647 范围内的非负整数，使得运算过程中发生越界。

> 提示：发生越界的一步计算是`-`。

# 总结
本步骤中其他运算符的实现逻辑和方法与取负类似，大家可以借鉴取负的实现方法实现剩下的逻辑非和按位非。并且，我们在实验框架中已经给出了取负的参考实现，希望能够帮助大家快速上手编译实验。

# step10 实验指导

本实验指导使用的例子为：

```C
int x = 2021;
int main() { return x; }
```

## 词法语法分析

针对全局变量，我们需要新设计 AST 节点来表示它，只需修改根节点的孩子类型即可：原先表示整个 MiniDecaf 程序的根节点只能有函数类型的子节点，现在还可以允许变量声明作为子节点。

## 语义分析

在引入全局变量后，AST 的根结点的子结点不再只是函数了，还可能包括全局变量定义。全局变量就放在栈底的全局作用域中。构建符号表遍历 AST 过程中，栈底元素一直都在，不会被弹出。

## 中间代码生成

经过 Step5 的实验学习，我们知道局部变量是存储在寄存器或栈中的，可以直接访问。然而，全局变量存储在特别的内存段中，不能直接访问。我们建议加载一个全局变量的方式为首先加载全局变量符号的地址，然后根据地址来加载数据。因此我们需要定义两个中间代码指令，完成全局变量数值的加载：

| 指令 | 参数 | 含义 |
| --- | --- | --- |
| `LOAD` | `T1, offset` | 临时变量 T1 中存储地址，加载与该地址相差 offset 个偏移的内存地址中的数据 |
| `LOAD_SYMBOL` | `symbol` | symbol 为字符串，加载 symbol 符号所代表的地址 |

有了上述两条指令，我们可以将测试用例翻译如下：

```
main:
    _T0 = LOAD_SYMBOL x
    _T1 = LOAD _T0, 0
    return T1
```

需要说明的是，你也可以把两条指令合并为一条指令，直接加载全局变量的值，但我们觉得分为两条指令扩展性更好。

请注意，翻译出的 TAC 代码里没有提到全局变量的初始值。同学们可以将变量的初始值存在变量符号里，在后端中**通过读取符号表得到初值**。当然这里只是一种参考实现，你也可以将全局变量的定义显式地写在 TAC 中，从而使中端与后端完全解耦。

## 目标代码生成

Step10 中目标代码生成的主要任务有：翻译中间代码，将全局变量放到特定的数据段中。

1. 翻译中间代码

   实际上，我们提供的中间代码设计和 RISC-V 汇编的思想是一致的，RISC-V 汇编中有对应 LOAD 和 LOAD_SYMBOL 的指令，我们直接给出翻译结果：

   ```assembly
   main：
       la t0, x        # _T0 = LOAD_SYMBOL x
       lw t1, 0(t0)    # _T1 = LOAD _T0, 0
       mv a0, t1
       ret
   ```

2. 将全局变量放到特定的数据段中

   翻译中间代码步骤中（也就是上一点）有很大问题，需要加载的 x 符号究竟在哪，如果生成的汇编程序中通篇不涉及 x 的定义，程序肯定是有问题的。实际上，RISC-V 提供了一系列的[汇编指令](https://github.com/TheThirdOne/rars/wiki/Assembler-Directives)帮助声明数据段。
   
   因为全局变量的声明都是一样的，所以我们直接给出测试用例的声明，不同的变量声明简要修改名称和初始值即可：

   ```assembly
   .data
   .globl x
   x:
       .word 2021
   ```
   
   其中 .data 表示输出到 data 段；.globl x 声明 x 为全局符号；.word 后是一个 4 字节证书，是 x 符号在内存的初始值。
   
   按照约定 data 段中存放已初始化的全局变量，未初始化全局变量放到 bss 段中，如将未初始化的全局变量 x 存放到 bss 段的汇编如下，.space 表示预留一块连续的内存，4 表示大小（字节）。
   
   ```assembly
   .bss
   .globl x
   x:
       .space 4
   ```

# 思考题
1. 请给出将全局变量 `a` 的值读到寄存器 `t0` 所需的 riscv 指令序列。

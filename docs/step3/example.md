# step3 实验指导

本实验指导使用的例子为：

```C
1<2
```

## 词法语法分析
如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。
> 对有兴趣的同学：虽然 `-2` 和 `2-3` 里面的 `-` 意义不同，但 lexer 不知道这点（parser 才知道），所以它们都会用同样的 token kind `-` 表示。
> 但有时，可能需要后续阶段告诉 lexer（或 parser）一些信息，最经典的例子是 [“typedef-name identifier problem”](https://en.wikipedia.org/wiki/Lexer_hack)。

我们的表达式语法规范和 C 标准的基本相同，但略显繁琐。
如果你选择的语法分析工具支持优先级和结合性，并且你希望用这些信息来简化语法分析工具的编写，请参考[这里](./precedence.md)。

## 语义分析

语义分析无需修改。

## 中间代码生成
与一元操作类似，针对加法，我们需要设计一条中间代码指令来表示它，给出的参考定义如下：

| 指令  | 参数    | 作用           |
| ----- | ------- | -------------- |
| `ADD` | `T0,T1` | 将两个参数相加 |

因此，测例可以翻译成如下的中间代码：

```assembly
_T0 = 1
_T1 = 3
_T2 = ADD _T0, _T1
```

## 目标代码生成

step3 目标代码生成步骤的关键点与 step2 相同，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。

```assembly
li t0, 1
li t1, 3
add t2, t0, t1
```

# 思考题

1. 我们知道“除数为零的除法是未定义行为”，但是即使除法的右操作数不是 0，仍然可能存在未定义行为。请问这时除法的左操作数和右操作数分别是什么？请将这时除法的左操作数和右操作数填入下面的代码中，分别在你的电脑（请标明你的电脑的架构，比如 x86-64 或 ARM）中和 RISCV-32 的 qemu 模拟器中编译运行下面的代码，并给出运行结果。（编译时请不要开启任何编译优化）

```c
#include <stdio.h>

int main() {
  int a = 左操作数;
  int b = 右操作数;
  printf("%d\n", a / b);
  return 0;
}
```

# 总结
本步骤中其他运算符的实现逻辑和方法与加法类似，可以参考二元加法的实现方法设计实现其他二元运算符。

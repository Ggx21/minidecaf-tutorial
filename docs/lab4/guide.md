# step4 实验指导

## 词法语法分析
如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。

语义检查无需修改。

如果你是手写分析，TODO

## IR 生成
沿用 step3 加入的二元操作 IR（以及左右操作数的位置），新的 IR 如下。

| 指令 | 参数 | 含义 | IR 栈大小变化 |
| --- | --- | --- | --- |
| `eq` | 无参数 | `==`（弹出栈顶两个元素，如果相等压入 1，否则压入 0） | 减少 1 |
| `ne` | 无参数 | ……`!=` | 减少 1 |
| `le` | 无参数 | ……`<=` | 减少 1 |
| `ge` | 无参数 | ……`>=` | 减少 1 |
| `lt` | 无参数 | ……`<` | 减少 1 |
| `gt` | 无参数 | ……`>` | 减少 1 |
| `land` | 无参数 | ……`&&` | 减少 1 |
| `lor` | 无参数 | 弹出栈顶两个元素，将其逻辑或压入栈 | 减少 1 |

> 当然，IR 设计很灵活。参见思考题 3。

## 汇编生成
对于比较大小和相等的操作，参照 gcc 结果，自行完成汇编生成。

逻辑表达式会麻烦一点，因为 gcc 可能生成跳转，所以下面给出 `land` 和 `lor` 对应的汇编。
表格中，我们省略了汇编的前缀 `lw t1, 4(sp)  ;  lw t2, 0(sp)` 和后缀 `addi sp, sp, 4  ;  sw t1, 0(sp)`。
注意 RISC-V 汇编中的 `and` 和 `or` 都是位运算指令，不是逻辑运算指令。

| IR       | 汇编                                                |
| ---      | ---                                                 |
| `land` | `or t1,t1,t2  ;  snez t1,t1` |
| `lor` | `snez t1,t1  ;  snez t2,t2  ;  and t1,t1,t2` |

# 任务
1. 改进你的编译器，支持本节引入的新特性，通过相关测试。
2. 实验报告中回答思考题。

# 总结
step4 和 step3 差别不大。

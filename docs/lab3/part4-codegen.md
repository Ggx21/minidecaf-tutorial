## 代码生成

### 基础

这一节涉及到了双目运算，分别对应如下几个汇编指令：

```asm
add t0, t1, t2          #t0 = t1 + t2
sub t0, t1, t2          #t0 = t1 - t2
mul t0, t1, t2          #t0 = t1 * t2
div t0, t1, t2          #t0 = t1 / t2
rem t0, t1, t2          #t0 = t1 % t2
```

这些指令都有统一的格式，以第二、第三个寄存器为左右操作数，将计算结果置于第一个寄存器中。

### 生成

本周在代码生成阶段有一个新的挑战。要处理一个二元表达式，比如`e1+e2`，我们生成的汇编需要：

- 计算`e1`并将其保存在某处
- 计算`e2`
- 将`e1`加到`e2`，

所以，我们需要一个地方来保存第一个操作数。把它保存在寄存器中会很复杂。考虑这样一个式子（我们还没有涉及括号，仅从计算顺序的角度考虑）:

```
3+(3+3)
```

`e1 = 3`，`e2 = 3+3`，第二个操作数本身包含子表达式，还需要把中间结果保存在寄存器中，这导致有可能覆盖`e1`。这里栈式机为我们提供了一种足够简单的解决方式。
我们依旧需要递归的生成汇编代码：

```
visitAdd(IR add) {
    visit(add.lhs);
    visit(add.rhs);
    emitAdd();
}
```

想一想栈式机的运行方式，在执行完左操作数的计算（`visit(add.lhs)`）后，在栈上应当有了左操作数的结果，但右操作数的计算与左操作数无关，不会消耗掉这一结果。因此，在右操作数计算完毕后，栈上内容应该如图：
```
...
left operator
right operator  <- sp
...
```
emitAdd() 应当消耗这两个结果并将最终结果压栈。

```asm
ld t1, 0(sp)            #取右操作数
ld t0, -8(sp)           #取左操作数
add sp, sp, 8           #移动sp到合适位置
add t0, t0, t1,         #执行add运算
sd t0, 0(sp)            #储存结果
```

对于加法和乘法操作，操作数的顺序不重要，但对于其他三种运算，必须注意操作数计算和装载的顺序。
# 类型检查
正如指导书所说，类型检查目的是
1. 完成和表达式类型相关的一大类语义检查，例如 11.4 和 11.5；
2. 计算表达式的类型信息，提供给后续阶段使用。

说类型检查之前，我们先提一下类型。
类型的概念大家都很熟悉了（非形式化地），无非就是一个值的集合；
然后称表达式 `e` 的类型是 `T` 当且仅当 `e` 的值在 `T` 的集合里。
就 step11 而言，我们只需要在编译器中定义两种类型：
* 整数 `IntegerType()`，表示 32 位有符号 `int`
* 指针 `PointerType(baseType)`，表示指向 `baseType` 的指针
    > 例如 `int**` 就是 `PointerType(PointerType(IntegerType()))`。
    > 文档中为了简洁我们会写成前者，但编译器代码中要写后者。

> 就 step11 而言实现上不需要这么复杂，甚至你可以就用整数表示类型，例如 0 表示 `int`，3 表示 `int***`。
> 但这么做的话，step12 引入数组类型会很麻烦，更别提实际中还有 `struct` / 函数指针等等类型了。
>
> 对有兴趣的同学：这里也有一个概念上的区分，“指针类型（`PointerType`）” 并不是一个 “类型”。
> 回顾 step1，我们也说过 `Integer` 不是一个 `Token` 而是一个 `Token` 种类（`TokenKind`）。
> 同样的，指针类型是类型的类型，每个 `PointerType` 的实例对象才真正表示一个具体的指针类型。
> 有一门专门研究类型的理论叫 type theory，其中类型（type）的类型称为 kind，有兴趣的同学可以参考 *Types and Programming Languages*、*Proofs and Types* 等书。

类型检查阶段是由一系列 **类型规则** 指导进行的，源代码中操作如果需要类型检查，那它需要先声明自己的类型规则。
对于某个操作，其类型规则包含两个部分：
1. 各个源操作数的类型有什么限制；
2. 如果源操作数的类型满足 1.，那么操作的结果（如果有）是什么类型。

一些类型规则的例子如下
1. 加法 `+` 只能 `int` 加 `int`, 结果还是 `int`。
    > 如果有了指针算术甚至浮点，加法的类型规则会更加复杂。
2. if 的条件表达式类型必须是 `int`，没有操作结果。
3. 变量的类型就是它声明给出的类型。
4. 整数字面量的类型就是整数类型。
5. 解引用操作 `*e` 要求操作数类型 `e` 是指针类型 `T*`，结果类型是 `T`。
    > 指针能执行的操作很有限，见语义规范 11.5
6. 取地址操作符 `&e` 对源操作数类型没有要求，结果类型是 `PointerType(源操作数类型)`。
    > 这里假设已经做过左值检查了，另一种选择是把左值检查和类型检查糅在一起。
    > 另外，虽然操作数类型没有要求，但还是要做类型检查，保证操作数内部没有类型错误。
7. 类型转换（cast）对源操作数类型没有要求，结果类型就是转换的目标类型。
8. 函数调用：见语义规范 9.4，结果类型就是函数的返回类型。

类型检查阶段完成后，为了把类型信息传递给后续阶段，AST 中每个表达式结点都要新增一个属性 `type` 描述它的类型。
不然后续阶段看到 AST 里面的一个“加”，都不知道是整数加、指针算术（step12）还是浮点加，那 IR/汇编 就没法生成了。

我们还是可以使用一个 AST Visitor 实现类型检查，在其中
1. 对于每个操作结点，先对所有子结点类型检查，完成后子结点的 `type` 就是源操作数的类型。
    然后对照这个操作的类型规则，如果源操作数类型不对那么报错，否则计算该结点的 `type`。
2. 碰到变量声明（包括形参），遍历声明类型子节点，然后设置其变量数据结构的类型。
    如果有初始值，对它执行类型检查，如果它的类型和声明的类型不匹配则报错。

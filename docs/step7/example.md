# step7 实验指导

本实验指导使用的例子为：

```C
int main() {
    int x = 1;
    {
        x = 2; 
        int x = 3;
    }
    x = 4;
    return x;
}
```

## 词法语法分析

> TODO：按照规范要求增加新的语法树结点和语法规则。

## 语义分析

从 Step7 开始，我们需要考虑作用域和代码块。简而言之，一份代码中可能有多个代码块的嵌套，因此作用域开始出现了层次结构。例如，在示例中，尽管 main 函数里定义了变量 x，但随后我们开启了一个新的代码块。在这个代码块中，赋值语句 `x = 2;` 中的 x 就是指 main 作用域中定义的 x，而随后通过 `int x = 3;` 我们定义了另一个变量 x，这个 x 只在内部大括号括起的作用域内生效。

在 Step5 中，我们只维护了 main 的作用域，所有符号都在这个作用域的符号表中维护。现在，为了维护层次嵌套的作用域，我们引入了**作用域栈**（Scope Stack）这个数据结构。在进行符号表构建的扫描过程中，我们需要动态维护作用域栈，保存当前扫描结点所在的从内到外所有作用域。每次我们开启一个代码块时，要新建一个作用域并压栈；而当退出代码块时，要弹栈关闭此作用域。

让我们看看示例里怎样维护作用域栈。栈底是一个全局作用域，目前它的符号表里只有 main 函数。由于我们目前不需要考虑函数和全局变量，因此可以暂时忽略全局作用域。进入 main 函数时，开启一个局部作用域，在扫描 `int x = 1;` 时定义变量符号 x，并将之加入栈顶作用域的符号表中。如下所示：

| 作用域栈           | 符号表              |
| ------------------ | ------------------- |
| 全局作用域（栈底） | 函数 main（可忽略） |
| 局部作用域（栈顶） | 变量 x              |

之后，我们扫描到一个局部代码块，开启一个局部作用域并压栈。在扫描 `x = 2;` 时，我们需要分析 x 这个变量对应着哪个作用域里的符号。此时的作用域栈是这样的：

| 作用域栈           | 符号表              |
| ------------------ | ------------------- |
| 全局作用域（栈底） | 函数 main（可忽略） |
| 局部作用域         | 变量 x              |
| 局部作用域（栈顶） | 空                  |

我们从栈顶开始，自顶向下依次查找变量 x 直至找到为止。在栈顶作用域中，符号表中没有变量符号 x，于是向下继续查找。在 main 函数对应的作用域中，我们找到了变量符号 x，因此此处的 x 就对应 main 函数作用域里定义的变量 x。

接着，我们扫描到了语句 `int x = 3;`，定义变量时，我们只需要在栈顶作用域中查找该变量是否存在。若不存在，即可定义。此时的作用域栈是这样的：

| 作用域栈           | 符号表              |
| ------------------ | ------------------- |
| 全局作用域（栈底） | 函数 main（可忽略） |
| 局部作用域         | 变量 x              |
| 局部作用域（栈顶） | 变量 x              |

请务必注意上表中的两个变量 x 是**不同的变量**。

接着，我们退出代码块，弹栈，此时的作用域栈变成了：

| 作用域栈           | 符号表              |
| ------------------ | ------------------- |
| 全局作用域（栈底） | 函数 main（可忽略） |
| 局部作用域（栈顶） | 变量 x              |

最后访问语句 `x = 4;`，此时我们从作用域栈中找到的变量 x 变为了 main 作用域里的 x。

## 中间代码生成

本步骤中无须新增新的 TAC 指令。

让我们来看看示例所对应的 TAC 代码：

```
main:
    _T1 = 1
    _T0 = _T1   # int x = 1;
    _T2 = 2
    _T0 = _T2   # x = 2
    _T4 = 3
    _T3 = _T4   # int x = 3;
    _T5 = 4
    _T0 = _T5   # x = 4;
    return _T0
```

显然，两个代码块里的变量 x 是不同的变量，因此它们分别对应着不同的临时变量。其中，_T0 对应着 main 作用域里的 x，而 _T3 则对应着内层代码块定义的变量 x。只要同学们在符号表构建阶段把每个变量和正确作用域的变量符号关联起来，这一步就非常简单了：找到对应变量符号，使用该符号对应的临时变量即可。

## 目标代码生成

由于不需要新增新的中间代码指令，本步骤中目标代码生成模块没有新的工作，但这是建立在你之前的实现没有错误基础上的。

# 思考题
1. 请将下述 MiniDecaf 代码中的 `???` 替换为一个 32 位整数，使得程序运行结束后会返回 0。
```c++
int main() {
    int x = ???;
    if (x) {
        return x;
    } else {
        int x = 2;
    }
    return x;
}
```

2. 在实验指导中，我们提到“就 MiniDecaf 而言，名称解析的代码也可以嵌入 IR 生成里”，但不是对于所有语言都可以把名称解析嵌入代码生成。试问被编译的语言有什么特征时，名称解析作为单独的一个阶段在 IR 生成之前执行会更好？

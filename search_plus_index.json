{"./":{"url":"./","title":"实验简介","keywords":"","body":"MiniDecaf 编译实验 实验概述 MiniDecaf 1 是一个 C 的子集，去掉了include/define等预处理指令，多文件编译支持，以及struct/指针等语言特性。 本学期的编译实验要求同学们通过多次“思考-实现-重新设计”的过程，一步步实现从简单到复杂的 MiniDecaf 语言的完整编译器，能够把 MiniDecaf 代码编译到 RISC-V 汇编代码。进而深入理解编译原理和相关概念，同时具备基本的编译技术开发能力，能够解决编译技术问题。MiniDecaf 编译实验分为多个 stage，每个 stage 包含多个 step，共包含 11 个 step。每个 step 大家都会完成一个可以运行的编译器，把不同的 MiniDecaf 程序代码编译成 RISC-V 汇编代码，可以在 QEMU/SPIKE 硬件模拟器上执行。随着实验内容一步步推进，MiniDecaf 语言将从简单变得复杂。每个步骤都会增加部分语言特性，以及支持相关语言特性的编译器结构或程序（如符号表、数据流分析方法、寄存器分配方法等）。下面是采用 MiniDecaf 语言实现的快速排序程序，与 C 语言相同。为了简化实现，MiniDecaf 不支持以数组作为函数参数，因此快速排序的数组以全局数组的形式给出： int a[1000]; int qsort(int l, int r) { int i = l; int j = r; int p = a[(l+r)/2]; while (i p) j = j - 1; if (i > j) break; int u = a[i]; a[i] = a[j]; a[j] = u; i = i + 1; j = j - 1; } if (i l) qsort(l, j); return 0; } 2021 年秋季学期基本沿用了 2020 年秋季学期《编译原理》课程的语法规范，为降低实验难度，进一步去掉了指针等语言特性。和 2020 年秋季学期课程实验所不同的是，为了贴合课程教学内容，提升训练效果，课程组设计了比较完善的编译器框架，包括词法分析、语法分析、语义分析、中间代码生成、数据流分析、寄存器分配、目标平台汇编代码生成等步骤，并采用 C++ 与 Python 两种语言实现。每个 step 同学们都会面对一个完整的编译器流程，但不必担心，实验开始的几个 step 涉及的编译器框架知识都比较初级，随着课程实验的深入，将会循序渐进地引入各个编译器功能模块，并通过文档对相关技术进行分析介绍，便于同学们实现相关编译功能模块。 实验起点和基本要求 本次实验一共设置 12 个步骤（其中 step0 为环境配置，主要是 RISC-V 工具链和硬件模拟器的的安装与使用，以及学会使用助教提供的自动测试脚本）。后续的 step1-11 我们将由易到难完成 MiniDecaf 语言的所有特性，由于编译器的边界情况很多，因此你只需通过我们提供的正例与负例即可。 我们以 stage 组织和发布实验，各个 stage 组织如下： 第一个编译器（step1）。我们给的实验框架可以通过所有测试用例，你需要做的事情为跟着文档阅读学习实验框架代码。请各位同学注意，stage1 尤为重要，掌握好实验框架是高质量和高效率完成后续实验的保证。 常量表达式（step2-step4）。在这个 stage 中你将实现常量操作（加减乘除模等）。 变量和语句（step5-step6）。在这个 stage 中你将第一次支持变量声明与赋值，以及条件跳转语句。 块语句和循环（step7-step8）。在这个 stage 中你将支持块语句，所谓块语句，就是多个语句组成一个块，每个块都是一个作用域。作为一种特殊的块语句，你也将实现循环操作。 全局变量和函数（step9-step10）。在这个 stage 中你将支持声明全局变量，并且支持函数的声明和调用。 数组（step11）。在这个 stage 中，你将支持数组，包括全局数组和局部数组。 其中，stage1-stage4 为基础关卡，你需要通过它们以拿到一定的分数。stage5-stage6 为升级关卡，如果你学有余力，完成它们可以减少期末考试在总评中所占的比重。 TODO：需要根据教学安排更新比重。 关于文档，我们以 step 组织文档，每个 step 的文档都将以如下形式组织：首先我们会介绍当前 step 需要用到的知识点，其次我们会以一个当前 step 具有代表性的例子介绍它的整个编译流程。在之前 step 中已经介绍的知识点，我们会略过，新的知识点和技术会被详细介绍。 实验提交 TODO: 下面的是 2020 年的实验安排，需更新到 2021 年的版本。 你需要使用 git 对你的实验做版本维护，然后提交到 git.tsinghua.edu.cn。 大家在网络学堂提交帐号名后，助教给每个人会建立一个私有的仓库，作业提交到那个仓库即可。 关于 git 使用，大家也可以在网上查找资料。 每次除了实验代码，你还需要提交 实验报告，其中包括 你的学号姓名 简要叙述，为了完成这个 step 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 晚交扣分规则 是： 晚交 n 天，则扣除 n/15 的分数，扣完为止。例如，晚交三天，那你得分就要折算 80%。 备注 1. 关于名字由来，由于往年的实验叫 Decaf，我们在新的且更简单的语言规范下复用了 Decaf 的编译器框架，所以今年的实验就叫 MiniDecaf 了。 ↩ "},"docs/step0/todo.html":{"url":"docs/step0/todo.html","title":"待完善","keywords":"","body":"还需要完善的地方 [ ] 根据教学安排更新实验占比（README.md）@曾军 [ ] 更新 2021 年实验提交安排，为同学们创建清华 git 仓库（README.md，step0/testing.md）@杨耀良 [ ] 将实验框架放到 github 上（step0/testing.md）@陈之杨@曾军 [ ] 加入 python 框架相关代码位置（step1/arch.md）@陈之杨 [ ] step1 词法分析语法分析需完善，需要排考虑如何排版和呈现（step1/example.md）@刘润达@周智 [ ] step1 补充 python 框架代码生成细节（step1/example.md）@杨耀良 [ ] 完善实验框架环境配置中各工具安装细节的Mac版本（step0/env.md）@曾军 [ ] 将实验框架放到 github 上（step0/testing.md）@陈之杨@曾军 "},"docs/step0/riscv_env.html":{"url":"docs/step0/riscv_env.html","title":"RISC-V环境配置","keywords":"","body":"RISC-V 环境配置 必做：RISC-V 的 gcc 和 qemu 我们的编译器只生成 RISC-V 汇编，然后再使用 gcc 把 RISC-V 汇编变成 RISC-V 可执行文件，最后用 qemu/spike 等模拟器来运行 RISC-V 可执行文件。 这里的 gcc 和常说的 gcc 不一样。 常说的 gcc 运行在我们的 x86 机器上、把 C 编译到 x86 可执行文件； 而这里的 gcc 虽然也运行在我们的 x86 机器上，却要编译到 RISC-V 可执行文件。 这种“gcc 跑在 x86 却编译出 RISC-V 代码”的操作被称为交叉编译（cross compilation）。 因此我们不能直接使用有些系统自带的 gcc，这种 gcc 生成的可执行程序只能在你本机（x86）上运行。 我们需要下载安装 riscv64-unknown-elf-gcc，用来生成 RISC-V 可执行程序。 我们提供了预编译的 riscv64-unknown-elf-gcc 和 qemu 模拟器，不过只能在 Linux/Mac 下运行，Windows 的同学可以使用 WSL，或者运行一个虚拟机。 命令行基础操作我们就不赘述了，大家可以自己在网上查找资料。 下面是环境配置指南，请阅读自己的系统的那一小节。 你的编译器 gcc qemu/spike C-- 源文件 ------------> RISC-V 汇编 -----> 可执行文件 --------> 输出 Windows 用户环境配置指南 下面描述了 WSL 的一种参考方法。 你还可以开一个 Linux 虚拟机，使用 Virtualbox 或 VMWare 等，然后参考下面 Linux 配置。 Win10 设置 参考 https://blog.csdn.net/daybreak222/article/details/87968078 ，设置“开发者模式”以及“启用子系统功能”。 打开Microsoft Store，搜索Ubuntu，选择ubuntu20.04. 按照下面的 Linux 用户环境配置指南安装 riscv 工具链。 Linux 用户环境配置指南 从网络学堂下载 riscv-prebuilt.tar.gz 压缩包并解压（命令是 tar xzf riscv-prebuilt.tar.gz） 安装工具链 cp riscv-prebuilt/* /usr/ -r 在第 2. 步，你可以选择不安装到系统目录下。相应的，你需要设置环境变量： export PATH=$PATH:/path/to/riscv-prebuilt/bin，把 /path/to 替换为你的解压目录。 把上面这条命令加到你的 ~/.bashrc 文件中，这样不用每次打开终端都要重新设置。 每次改完 ~/.bashrc 你都需要重启终端，以便改动生效。 （如果你不用系统自带的 bash 而是用 zsh 之类的 shell，那加到 ~/.zshrc 等 shell 配置文件里） macOS 用户环境配置指南 从这里下载预编译好的 RISC-V 工具链并解压到你喜欢的目录。 由于 macOS 不支持 QEMU 的用户态模式，我们使用 Spike 模拟器和一个简易内核 riscv-pk 提供用户态程序的运行环境。你可以选择下面两种安装方法中的任意一种： 从网络学堂上下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，不过还需要通过 Homebrew 安装依赖 device tree compiler： $ brew install dtc 通过 Homebrew 安装 Spike（会自动安装 dtc）： $ brew tap riscv/riscv $ brew install riscv-isa-sim 然后从网络学堂上下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，只用里面的 pk。 Homebrew 也提供了 riscv-pk，不过那是 64 位的，而我们需要 32 位的，请使用我们预编译的 riscv-pk 或自行编译。 （可选）设置环境变量，方法与 Linux 一样，见上一节。如果不设置每次使用 gcc 和 spike 时都要输入完整路径。不过对于 pk 设置环境变量不管用，要么把它放到系统目录 /usr/local/bin/pk，要么每次都用完整路径。 测试你 GCC 和 Spike 是否成功安装，详见RISC-V 的工具链使用。 必做：测试你是否正确配置好了环境 创建 test.c 文件，其中写入如下内容 #include int main() { printf(\"Hello world!\\n\"); } 编译 test.c 文件，gcc 应该输出一个可执行文件 a.out。但 a.out 是 RISC-V 可执行文件，所以我们的 X86 计算机无法运行。 $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 test.c $ ls a.out a.out $ ./a.out bash: ./a.out: cannot execute binary file: Exec format error 后面RISC-V 的工具链使用总结了 gcc 和 qemu 在编译实验中可能需要的用法。 使用 qemu 执行 a.out$ qemu-riscv32 a.out Hello world! 备注 1. 开头的 $ 表示接下来是一条命令，记得运行的时候去掉 $。例如，让你运行 $ echo x，那你最终敲到终端里的是 echo x（然后回车）。如果开头没有 $，那么这一行是上一条命令的输出（除非我们特别说明，这一行是你要输入的内容）。 ↩ "},"docs/step0/riscv.html":{"url":"docs/step0/riscv.html","title":"RISC-V 的工具链使用","keywords":"","body":"RISC-V 相关信息 RISC-V 是一个很像 MIPS 的 RISC 指令集架构，编译实验要求你的编译器把 MiniDecaf 程序编译到 RISC-V 汇编。 指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"。 另外这里也有（非官方的）指令用法说明。 不过事实上，很多时候看 gcc 输出的汇编比看什么文档都有用。 RISC-V 工具使用 我们提供预先编译好的 RISC-V 工具，在环境配置中已经叙述了安装和使用方法。 下面汇总一下。 注意，我们虽然是用的工具前缀是 riscv64， 但我们加上参数 -march=rv32im -mabi=ilp32 以后就能编译到 32 位汇编 1。 使用时记得加这个参数，否则默认编译到 64 位汇编。 我们假设你已经正确设置好了环境变量，否则运行 riscv64-unknown-elf-gcc 或 qemu-riscv32 或 spike 时请用完整路径。 gcc 编译 input.c 到汇编 input.s，最高优化等级（否则输出的汇编会很冗长） # input.c 的内容 $ cat input.c int main(){return 233;} # 编译到 input.s $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c # gcc 的编译结果 $ cat input.s .file \"input.c\" .option nopic .attribute arch, \"rv32i2p0_m2p0\" .attribute unaligned_access, 0 .attribute stack_align, 16 .text .section .text.startup,\"ax\",@progbits .align 2 .globl main .type main, @function main: li a0,233 ret .size main, .-main .ident \"GCC: (SiFive GCC 8.3.0-2020.04.0) 8.3.0\" gcc 编译 input.s 到可执行文件 a.out # input.s 的内容，就是上面汇编输出的简化版本 $ cat input.s .text .globl main main: li a0,233 ret # 编译到 a.out $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 input.s # 输出结果，能看到是 32 位的 RISC-V 可执行文件 $ file a.out a.out: ELF 32-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped 【Linux 用户】qemu 运行 a.out，获取返回码 # 运行 a.out $ qemu-riscv32 a.out # $? 是 qemu 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 【macOS 用户】Spike 模拟器运行 a.out，获取返回码 # 运行 a.out # /usr/local/bin/pk 替换为你自己的 pk 路径 $ spike --isa=RV32G /usr/local/bin/pk a.out bbl loader # $? 是 spike 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 1. 这里的 rv32im 表示使用 RV32I 基本指令集，并包含 M 扩展（乘除法）。本实验中我们不需要其他扩展。 ↩ "},"docs/step0/env.html":{"url":"docs/step0/env.html","title":"实验框架环境配置","keywords":"","body":"实验框架环境配置 C++ 实验框架环境配置 关于操作系统，助教推荐使用 Linux 环境（如 Ubuntu，Debain 或 Windows 下的 WSL 等），当然你也可以在类 Unix 系统环境（Mac OS）中进行开发。助教不推荐直接在 Window 中搭建开发环境。对于 C++ 实验框架，你需要安装或保证如下软件满足我们的要求： TODO：详细介绍一下Mac中各种工具安装的细节。 Flex Flex 是一个自动生成词法分析器的工具，它生成的词法分析器可以和 Bison 生成的语法分析器配合使用。我们推荐从 Github 下载安装最新版本(在2021.9.1, 最新版本是2.6.4,不推荐使用低于2.6的版本)。 在ubuntu下，apt-get install flex 安装的flex版本为2.6,是可用的。 Bison Bison是一个自动生成语法分析器的工具,它生成的语法分析器可以和Flex生成的词法分析器配合使用。我们推荐从官网下载安装最新版本（在2021.9.1, 最新版本是3.7.6，不推荐使用低于3.7的版本,如ubuntu apt-get install安装的3.0.4版本是不可用的）。 下载解压tar.gz文件后， 在路径下执行./configure && make && make install, 就应该能正确安装。如果发生失败，就尝试sudo ./configure sudo make, sudo make install, 然后bison --version检查一下版本是否为3.7.6就可以了。 Boehmgc C++ 语言的实验框架中，为了简化内存分配的处理，使用了一个第三方垃圾回收库，简单来说，使用这个垃圾回收库提供垃圾回收功能后，我们在框架里可以new了之后不用delete也不会出问题。 在ubuntu下,通过 apt-get install libgc-dev安装的boehmgc库是可用的。 gcc 助教推荐的 gcc 版本为 8.5.0。 需要注意的是，如果你使用 Mac OS 进行开发，Mac 自带的 g++ 命令极有可能软链接到了 clang，我们的实验框架在某些版本的 clang 下无法编译通过，因此推荐你使用如下方法安装特定版本的 gcc。安装完成之后，你需要使用 gcc-8，g++-8 来调用特定版本的 gcc，g++，同时你需要修改我们提供的 Makefile 中的 CC 与 CXX 选项。 # Mac OS $ brew install gcc@8 # Ubuntu $ sudo apt-get install gcc-8 python 实验框架环境配置 关于操作系统，类似 C++，但由于 python 的跨平台性，理论上也可以在 Windows 下进行开发。但不保证Windows和在线测试环境下程序行为的一致性。由于 python 自带的包管理系统 pip，安装推荐的依赖只需执行如下命令。 $ pip install -r ./requirements.txt python 3.9 框架本身在 python 3.9 下进行开发，使用了 python 3.9 的新特性并仅在这一版本下经过测试。请保证你所使用的 python 版本高于此版本。 argparse 框架使用了 argparse 以处理命令行参数。官方文档中提供了它的教程。 ply ply是一个自动生成词法分析器和语法分析器的工具，其中ply.lex为词法分析相关的模块而ply.yacc为语法分析相关。我们提供了 ply 的文档。 助教推荐使用类似 Miniconda 的系统以最小化出现奇怪依赖问题的风险。助教推荐在项目中使用 type hints，如果你习惯在 vscode 中进行开发的话同时推荐使用 pylance 这一插件。 必做：测试你是否正确配置好了环境 C++ 实验框架 确定各工具的版本 # g++ $ g++-8 -v # Flex $ flex --version # Bison $ bison --version "},"docs/step0/testing.html":{"url":"docs/step0/testing.html","title":"运行实验框架","keywords":"","body":"推荐：运行实验框架 配好环境以后，我们强烈推荐你构建运行我们提供的实验框架初始代码。 接下来我们会用到 git。 git 的安装和使用会在软件工程课上讲述，同学们也自行查阅相关资料，也可以参考这里 。 通过 git clone 把测例和实验框架实现克隆到同一个目录下面。 TODO：框架上传之后更新链接。 C++ 和 Python 框架在同一个仓库的不同分支里面。 按照参考实现的 README 配置好它的环境。 按照测例的 README 运行测试 step1，实验框架给出的初始代码可以通过 step1 的所有测例。 测试运行的 输出结果 大致如下。 $ STEP_UNTIL=1 ./check.sh gcc found qemu found parallel found OK testcases/step1/multi_digit.c OK testcases/step1/newlines.c ...... 其他测试点，太长省略 "},"docs/step0/faq.html":{"url":"docs/step0/faq.html","title":"常见问题","keywords":"","body":"常见问题 Invalid ELF image for this architecture $ qemu-riscv32 a.out a.out: Invalid ELF image for this architecture 解决方法： 注意编译时 gcc 要用 riscv64-unknown-elf-gcc，并且加上 -march=rv32im -mabi=ilp32。 command not found $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c riscv64-unknown-elf-gcc: command not found 或者运行 qemu-riscv32 时提示上面的错误。 解决方法： 你是否按照环境配置中指南配好环境？如果你没有安装到系统目录，是否设置 PATH，并且把 export PATH... 命令放到 ~/.bashrc？ Spike pk 卡死 执行 spike pk 直接卡死，需要按多次 Ctrl-C 后才能退出。 解决方法： 可能是忘加了 --isa=RV32G 选项，在用 64 位的 Spike 跑 32 位 pk。 如果你加了该选项也有这个问题，可能是你安装了 64 位的 pk 然后在用 32 位的 Spike 跑，请使用我们预编译的 32 位 pk。 Spike 运行报错：could not open pk $ spike --isa=RV32G pk libc++abi.dylib: terminating with uncaught exception of type std::runtime_error: could not open pk (did you misspell it? If VCS, did you forget +permissive/+permissive-off?) 解决方法： Spike 找不到 pk，请输入 pk 的完整路径。 Spike 运行报错：assertion failed: IS_ELF32(eh) $ spike --isa=RV32G pk a.out bbl loader ../pk/elf.c:42: assertion failed: IS_ELF32(eh) Power off 解决方法： 你可能编译出了 64 位的 a.out，注意编译时 gcc 要用 riscv64-unknown-elf-gcc，并且加上 -march=rv32im -mabi=ilp32。 Spike 运行报错：Child dtb process failed $ spike --isa=RV32G /usr/local/bin/pk a.out Failed to run dtc: No such file or directory Child dtb process failed 解决方法： 使用 Homebrew 安装 device tree compiler： $ brew install dtc macOS 下找不到 realpath 命令 macOS 下运行 minidecaf-tests 里的 check.sh 报错： ./check.sh: line 25: realpath: command not found ./check.sh: line 26: realpath: command not found ./check.sh: line 30: $asmfile: ambiguous redirect ...... 解决方法： 使用 Homebrew 安装 coreutils： $ brew install coreutils "},"docs/step1/arch.html":{"url":"docs/step1/arch.html","title":"MiniDecaf 编译器结构","keywords":"","body":"MiniDecaf 编译器结构 MiniDecaf 编译器大致划分为三个部分：前端、中端、后端。通过编译器前端，可以读入 MiniDecaf 源程序，然后通过词法分析和语法分析将源程序转化为一个抽象语法树（Abstract Syntax Tree, AST)，接下来通过扫描 AST 进行语义分析，检查是否存在语义错误；在编译器中端，通过扫描 AST 生成中间代码 —— 三地址码；在编译器后端中，将三地址码转换为 RISC-V 汇编代码。下面依次介绍上述编译步骤，以及对应框架代码的位置。 我们在这里针对每个步骤只是简要介绍，目的是给同学们一个大致的印象：编译器到底是由哪些部分组成的，这些部分又有什么作用。具体的技术点，我们将在用到的 step 作详细介绍。 词法分析和语法分析 此部分对应框架源码位置： C++ 框架：词法分析程序位于 src/frontend/scanner.l；语法分析程序位于 src/frontend/parser.y；语法树位于 src/ast/ Python 框架：词法分析程序位于 frontend/lexer；语法分析程序位于 frontend/parser 编译器前端分为两个子任务，一是词法分析，二是语法分析。词法分析的功能是从左到右扫描 MiniDecaf 源程序，识别出程序源代码中的标识符、保留字、整数常量、算符、分界符等单词符号（即终结符），并把识别结果返回给语法分析器，以供语法分析器使用。语法分析是在词法分析的基础上针对所输入的终结符串建立语法树，并对不符合语法规则的 MiniDecaf 程序进行报错处理。一般而言，这一步所生成的语法树并非表示了所有语法细节的语法分析树，而是只表示其树形结构的抽象语法树（Abstract Syntax Tree, AST）。比如，对于下面这一段简单的MiniDecaf 代码： if (i) i = 1; 它对应的完整语法分析树可能长这样： if_stmt |- \"if\" |- \"(\" |- Identifier(\"i\") |- \")\" |- assign_stmt |- Identifier(\"i\") |- \"=\" |- Int(1) |- \";\" 其中双引号下的和大写字母开头的都为词法分析器产出的终结符。而对应的抽象语法树可能长这样： if_stmt |- (condition) Identifier(\"i\") |- (body) assign_stmt |- (lh) Identifier(\"i\") |- (rh) Int(1) AST省略掉了完整的语法分析树中不必要的细节，有利于简化树的结构与后续对树的处理。 词法分析和语法分析的最终结果是一棵跟所输入的 MiniDecaf 源程序相对应的语法树。本阶段的实验重点是掌握 LEX 和 YACC 的用法，了解编译器自动构造工具的特点，并且结合实验内容理解正规表达式、自动机、LALR(1) 分析等理论知识在实践中的应用。 语义分析 此部分对应框架源码位置： C++ 框架：符号表构建位于 src/translation/build_sym.cpp；类型检查位于 src/translation/type_check.cpp；符号表相关的数据结构位于src/symb；作用域相关数据结构位于 src/scope TODO：加入 Python 框架相关代码位置 语法分析树的建立可以说明所输入的 MiniDecaf 源程序在语法规范上是合法的，但是要进行有效的翻译，编译器还需要理解每个程序语句的含义。了解程序含义的过程称为语义分析。 可以把语义分析过程分为两个部分：分析符号含义和检查语义正确性。分析符号含义是指对于表达式中所出现的符号，找出该符号所代表的内容，这个工作主要通过检索符号表来实现。检查语义正确性指的是要检查每个表达式的操作数是否符合要求，也就是说检查每个表达式是否为语言规范中所规定的合法的表达式。由于不合法的语句具体含义在语言规范中没有规定，从而使得编译器没法明确这些语句的确切含义，所以检查语义的正确性是很有必要的。如果一个程序成功通过语义分析，则说明这个程序的含义对于编译器来说是明确的，从而翻译工作才能得以进行。 具体来说，在这一阶段中，我们需要对 AST 两遍扫描，分别完成以下的检查： 符号表构建：声明了哪些标识符，每一处使用的标识符对应于哪一处的声明。 类型检查：各语句和表达式是否类型正确。 如果在语义分析阶段发现问题，那么整个编译过程在这一阶段结束后就终止，并报告编译错误。所有的语义错误都应该且只应该在这一阶段进行报告。下面分别介绍符号表构建和类型检查的内容。 符号表构建 针对 MiniDecaf 程序中所有定义的标识符，包括函数名和变量名，我们统一用一种具有层次结构的符号表来维护。使用符号表的好处主要有两个：第一，在分析各语句和表达式时，若它们引用了某些标识符，我们可以在符号表中查询这些符号是否有定义以及相关信息（如类型）；第二，符号表的层次结构与作用域是一一对应的，因此容易检查出符号定义是否有冲突。 由于 Step1-4 中只需要考虑常量的计算，直到 Step5 开始才需要考虑构建符号表。 类型检查 完成符号表构建后，我们就可以自顶向下地遍历 AST，逐一对每个语句和表达式进行类型检查。 对于静态类型 (statically-typed) 语言，在语言设计之初，设计者都会考虑该语言支持表达哪些类型，并给出定型规则 (typing rules)。 在已知定型规则的情况下编码实现类型检查算法并不困难——往往只要逐条将其翻译为代码即可。 事实上，由于 MiniDecaf 代码的基本类型只有整数类型（int），因此我们在类型检查时只需要考虑 int 和 int 数组两种类型。在 Step11 之前，都基本不需要考虑类型检查。 中间代码生成 C++ 框架：三地址码定义位于 src/tac；中间代码生成位于 src/translation/translation.cpp TODO：加入 Python 框架相关代码位置 在对 AST 进行语义分析后，我们将在这一阶段把带有类型标注的 AST 进行翻译成适合后端处理的一种中间表示。中间表示（也称中间代码，intermediate representation / IR）是位于语法树和汇编之间的一种程序表示。 它不像语法树一样保留了那么多源程序的结构，也不至于像汇编一样底层。 由于源语言（MiniDecaf）和目标语言（RISC-V 汇编）一般有比较大的差别，因此直接把语法树翻译为目标语言中的合法程序通常是比较困难的。大多数编译器实现中所采取的做法是首先把源语言的程序翻译成一种相对接近目标语言的中间表示形式，然后再从这种中间表示翻译成目标代码。 容易看出，IR 的好处有如下几点： 缩小调试范围，通过把 AST 到汇编的步骤一分为二。通过观察 IR 是否正确生成就能知道：到底是 IR 生成这一小步有问题，还是 IR 到汇编这一小步有问题。 比起 AST 到汇编当成一整个大步骤，分成两个小步，每步代码更少，更容易调试。 实际中，有了 IR 更容易适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, C, Java...）。由于不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块。如果有了 IR，只需要写 N 个 IR 生成和 M 个汇编生成，一共 N + M 个模块。 下面，我们将对我们所使用的中间代码——三地址码（TAC）做简单介绍，后续的实验步骤中需要你添加恰当的三地址码指令来完成特定的功能。当然，我们会对比较复杂的情况给出参考实现，各位同学可以依据参考实现完成设计，也可以根据自己的想法进行三地址码的设计。 三地址码 三地址码（Three Address Code, TAC）看起来很像汇编，但是和汇编最大的差异在于——汇编里面使用的是目标平台（如 risc-v, x86, mips）规定的物理寄存器，其数目有限；而 TAC 使用的是“伪寄存器”，我们称临时变量，理论上其数目可以无限，我们想要多少就有多少（这意味着直接将临时变量转化为寄存器可能会出现寄存器不够用的情况）。在后端生成汇编代码时，我们再考虑如何为临时变量分配物理寄存器。 main: # main 函数入口标签 _T0 = 1 # 加载立即数 _T1 = _T0 # 临时变量赋值操作 _T2 = ADD _T0, _T1 # 加法操作 _T2 = _T0 + _T1 _T3 = NEG _T0 # 取负操作 _T3 = -_T0 return _T2 # 函数返回 以上给出了一份 TAC 程序的示例。请注意本文档中的 TAC 代码示例都只是为了方便阅读而采取了这种表示方法，但 TAC 代码只是一种中间表示，并不需要像汇编语言那样有严格的文法。因此，同学们可以自由选择输出 TAC 代码的格式，只要方便自己调试即可。例如，你也可以将 _T2 = ADD _T0, _T1 输出成 _T2 = _T0 + _T1。 TAC 程序由标签和指令构成： 标签用来标记一段指令序列的开始。从底层的角度来看，每个标签本质上就是一个地址，且往往是某一段连续内存的起始地址。在本框架中，标签有两个作用：作为函数入口地址（如上例中的 main 函数入口）、作为分支语句的跳转目标（TAC 指令不支持 MiniDecaf 语言中的 if, for 等条件/循环控制流语句，而是将它们都翻译成更加底层的跳转语句）。 指令与汇编指令类似，每条 TAC 指令由操作码和（最多3个）操作数构成。 操作数可能会有：临时变量、常量、标签（可理解为常量地址）和全局变量（全局变量的处理比较特殊，由于 Step10 才需要考虑它，我们届时再介绍处理它的方法）。如上例所示，TAC 中的临时变量均用 \"_Tk\" 表示。 TAC 程序是无类型的，或者说它仅支持一种类型：32位（4字节）整数。出于方便考虑，MiniDecaf 只支持 int 类型和 int 数组类型，其值和地址都能用一个32位整数装下，故 MiniDecaf 程序中的变/常量和 TAC 中的变/常量可以直接对应。 数组类型无法用临时变量直接表示，因此用一段连续内存的起始地址表示。其实现细节我们在 Step11 再详细讨论。 数据流分析和寄存器分配 C++ 框架：数据流图定义及优化在 src/tac/flow_graph.cpp 及 src/tac/dataflow.cpp 中；寄存器分配在 src/asm/riscv_md.cpp中 TODO：加入 Python 框架相关代码位置 数据流分析 一般来说，在三地址码的基础上是可以直接翻译为目标代码的，但是这样的直接翻译会导致所产生的代码的效率比较差，所以多数编译器都会进行一定的优化工作。为了进行更深入的优化，编译器需要了解程序语义的更多内容，例如一个变量的某个赋值在当前指令中是否有效、一个变量在当前指令以后是否还会被使用、当前运算指令的两个操作数是否都能够在编译的时候计算出来、循环体中某些代码是否能够提出到循环外面、循环次数是不是编译的时候已知的常数等等，这些语义分析一般分为数据流分析和控制流分析两种。 所谓数据流分析，是指分析各种数据对象在程序的执行路径中的状态关系，例如一个变量在某个语句以后是否还被用到等。依据数据流分析的结果，我们可以进行后续的中间代码优化以及寄存器分配等相关步骤。 而所谓的控制流分析，是指分析程序的执行路径满足什么性质，例如是否包含多重循环、控制流图中是否包含强连通块等。关于数据流分析的细节，我们将在 step8 做详细介绍。 寄存器分配 所谓寄存器分配，是指为中间代码中的虚拟寄存器分配实际的物理寄存器。对中间代码来说，通常假设虚拟寄存器的数量是无限的，这导致我们在分配物理寄存器时无法简单的对虚拟寄存器做一一映射，需要有一个调度与分配算法来合理使用有限的物理寄存器。本实验框架中使用了一种暴力寄存器分配算法，具体细节将在 Step5 中详细说明，当然如果你感兴趣，你也可以基于我们的框架实现更高级的干涉图分配算法，具体不作要求。 目标平台汇编代码生成 C++ 框架：目标平台汇编代码生成在 src/asm 中 TODO：加入 Python 框架相关代码位置 通常我们认为的目标代码生成步骤包含寄存器分配、指令选择。寄存器分配是指为中间代码中的虚拟寄存器分配实际的物理寄存器，设计物理寄存器的调度分配。指令选择是指选用合适的汇编指令来翻译中间代码指令，如中间代码生成章节提供的例子中，使用 addi 汇编指令来翻译 ADD 中间代码指令。需要特别提出的是，RISC-V 指令集的设计思路是尽可能简洁，因此有些指令并没有直接提供，需要用多条简单指令代替。如相等、大于等于、逻辑与、逻辑或等等，大家实现时需要特别注意。 本次实验我们的目标平台为 RISC-V，RISC-V 是一个很像 MIPS 的 RISC 指令集架构，编译实验要求你的编译器把 MiniDecaf 程序编译到 RISC-V 汇编。指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"，另外这里也有（非官方的）指令用法说明。下图给出了 RISC-V 的32个整数寄存器的相关说明，其中需要特别注意的寄存器有 ra（存放返回地址）、sp（存放当前栈顶地址）、fp（存放当前栈底地址）、a0&a1（存放返回值）。为了简单起见，我们简化了 RISC-V 的调用约定，由调用者负责保存寄存器，因此你无需关心某个寄存器是caller-saved 还是 called-saved。 "},"docs/step1/example.html":{"url":"docs/step1/example.html","title":"通过例子学习","keywords":"","body":"通过例子学习，一个仅有 return 的主函数编译全流程： 本步骤主要涉及的语法为主函数和 return 语句，完成本步骤之后，你的编译器将支持将一个仅有 return 的主函数编译为32位 RISC-V 汇编代码，并通过 RISC-V 工具链生成可以在硬件模拟器上正确运行的程序。因为这是大家首次接触 MiniDecaf 编译实验框架，我们给大家的代码框架中已经包含所有 Step1 的实现，大家可以直接运行通过 Step1 的测试用例。并且，我们在每个步骤的文档中会详细梳理介绍在当前步骤中需要用到的知识点以及对应的代码片段和注释，如果我们认为当前步骤并不需要了解某部分知识点（如数据流分析、寄存器分配），我们会在后续的步骤中进行知识点的讲解。 下面我们将通过一个简单的 step1 测试用例，一起走过它的编译全流程： int main() { return 2021; } 请注意，这里给出的生成结果（抽象语法树、三地址码、汇编）只是一种参考的实现，同学们可以按照自己的方式实现，只要能够通过测试用例即可。 词法分析语法分析 TODO：合理排版呈现，现在比较乱 Token流： Int Identifier(\"main\") LParen RParen LBrace Return IntConst(2021) Comma RBrace AST: Program -> Functions -> Type Identifier LParen RParen LBrace Statements RBrace Statements -> ReturnStmt ReturnStmt -> Return IntConst(2021) Comma (制图?) Makefile中调用了flex和bison来处理parser.y和scanner.l, 将对语法分析器和词法分析器的描述翻译为C++实现。 scanner.l和parser.y是配合使用的，简单来说，scanner.l定义了词法规则，parser.y定义了语法规则。parser.y自动生成的语法分析器，会调用scanner.l生成的yylex()函数, 相当于getNextToken() 将“return\"解析为一个token的规则，在scanner.l中是 \"return\" { return yy::parser::make_RETURN (loc); } loc是表示当前扫描位置的line\\column行列的全局变量，yy::parser::make_RETURN是parser.y自动生成的函数，构建一个parser能够使用的RETURN token。 在parser.y中， %token RETURN \"return\" ; 这一段就为parser声明了RETURN这个token。 %token IDENTIFIER \"identifier\" %token ICONST \"iconst\" 具体语义可参考 https://www.gnu.org/software/bison/manual/html_node/Complete-Symbols.html。 非终结符也需要声明。 %nterm Program FoDList 我们将非终结符都声明为语法树结点的指针类型。每条语法规则里对应的动作会构建一个新的语法树结点。如 FuncDefn : Type IDENTIFIER LPAREN FormalList RPAREN LBRACE StmtList RBRACE { $$ = new ast::FuncDefn($2,$1,$4,$7,POS(@1)); } | $1, $2按顺序索引规则右侧的非终结符。 语义分析 在 Step1 语义分析步骤中，我们要遍历 AST，检验是否存在如下的语义错误： main 函数是否存在。 return 语句是否有返回值。 返回值是否在 int 合法的范围内。 在实际操作中，我们遍历 AST 所用的方法就是的 Visitor 模式，通过 Visitor 模式，我们可以从抽象语法树的根结点开始，遍历整颗树的所有语法结点，并针对特定的语法结点作出相应的操作，如名称检查和类型检查等。在编译器中，这种基于 Visitor 的对语法树进行一次遍历，完成某种检查或优化的过程，称为遍（pass）。不难想到，一个现代编译器是由很多pass 组成的，如 gcc 根据优化等级不同会有数百个不等的 pass。下面，我们将指出，step1 中我们是如何实现符号表构建 pass 和类型检查 pass 的，选择不同语言的同学，可以选择去看相应的代码注释与实现细节。 Python 框架 frontend/typecheck/namer.py 和 typer.py 分别对应了符号表构建和类型检查这两次遍历。在 Step1-10 中，同学们只需要考虑 namer.py（因为只有 int 类型，无需进行类型检查）。在框架中，namer 和 typer 都是继承 frontend/ast/visitor.py 中的 Visitor 类来通过 Visitor 模式遍历 AST 的。其实现细节参见代码。 C++ 框架 translation/build_sym.hpp 和 translation/type_check.hpp 及相应 .cpp 文件分别对应了符号表构建和类型检查这两次遍历。在 Step1-10 中，同学们只需要考虑 build_sym.hpp（因为只有 int 类型，无需进行类型检查）。在框架中，两者都是继承ast/visitor.hpp 中的 Visitor 类来通过 Visitor 模式遍历 AST 的。其实现细节参见代码。 中间代码生成 在通过语义检查之后，编译器已经掌握了翻译源程序所需的信息（符号表、类型等），下一步要做的则是将抽象语法树翻译为便于移植和优化的中间代码，在本实验框架中就是三地址码。如何翻译抽象语法树？当然还是无所不能的 Visitor 模式，我们在中间代码生成步骤中再遍历一次语法树，对每个结点做对应的翻译处理。具体来说，在 step1 当中，我们只需要提取 return 语句返回的常量，为之分配一个临时变量，再生成相应的 TAC 返回指令即可。不难看出，本例对应的三地址码为： main: # main 函数入口标签 _T0 = 2021 # 为立即数2021分配一个临时变量 return _T0 # 返回 下面，我们同样也指出了在代码中我们是怎样实现这个中间代码生成 pass 的，大家可以参考注释和代码了解实现细节。 Python 框架 frontend/tacgen/tacgen.py 中通过一遍 AST 扫描完成 TAC 生成。和语义分析一样，这部分也使用了 Visitor 模式。 frontend/utils/tac 目录下实现了生成 TAC 所需的底层类。其中 tacinstr.py 下实现了各种 TAC 指令，同学们可以在必要时修改或增加 TAC 指令。提供给生成 TAC 程序流程的主要接口在 funcvisitor.py 中，若你增加了 TAC 指令，则需要在 FuncVisitor 类中增加生成该指令的接口。在本框架中，TAC 程序的生成是以函数为单位，对每个函数（Step1-8 中只有 main 函数）分别使用一个 FuncVisitor 来生成对应的 TAC 程序。除此之外的 TAC 底层类，同学们可以不作修改，也可以按照自己的想法进行修改。 C++ 框架 translation/translation.hpp 及相应 .cpp 文件中通过一遍 AST 扫描完成 TAC 生成。和语义分析一样，这部分也使用了 Visitor 模式。 tac 目录下实现了生成 TAC 所需的底层类。其中 tac/tac.hpp 下实现了各种 TAC 指令，同学们可以在必要时修改或增加 TAC 指令。tac/trans_helper.hpp 及相应 .cpp 文件中的 TransHelper 类用于方便地生成 TAC 指令流，若你增加了 TAC 指令，则需要在 TransHelper 类中增加生成该指令的接口。除此之外的 TAC 底层类，同学们可以不作修改，也可以按照自己的想法进行修改。 目标代码生成 目标代码生成步骤是对中间代码的再一次翻译，在本例中，你需要了解并掌握的知识点有: 如何将一个立即数装载到指定寄存器中？ RISC-V 提供了 li 指令来支持加载一个 32 位立即数到指定寄存器中，其中 表示寄存器名， 表示立即数值，如：li t0, 2021，就是将立即数 2021 加载到寄存器 t0 中。 如何设置返回值？ 在 RISC-V 中，a0 和 a1 是 gcc 调用约定上的存储返回值的寄存器，返回值会按照其大小和顺序存储在 a0 和 a1 中。也就是说，如果你有一个 32 位的返回值，你可以放在 a0 中返回，如果你有两个 32 位的返回值，你就需要把它们分别放在 a0 和 a1 中返回。更多的返回值会全部放入内存返回，如约定好的栈的某个位置，这取决于函数调用约定。 在我们的实验要求中，返回值均是单个 32 位的值。因此在当前步骤中你只需要了解，将需要返回的值放入 a0 寄存器中，然后在后面加上一条 ret 指令即可完成函数返回的工作。 综上所述，我们上述中间代码翻译成如下 RISC-V 汇编代码： .text # 代码段 .global main # 声明全局符号 main main: # 主函数入口符号 li t0, 2021 # 加载立即数2021到t0寄存器中 mv a0, t0 # 将返回值放到a0寄存器中 ret # 返回 关于实现细节，对应的代码位置在下面给出，代码中提供注释供大家学习： Python 框架 TODO：补充 Python 框架目标代码生成细节。 C++ 框架 C++ 框架中关于目标代码生成的文件主要集中在 src/asm 文件夹下，step1 中你只需要关注 src/asm/riscv_md.cpp 即可。具体来说，riscv_md.cpp 中的 emitPiece 函数是整个目标代码生成模块的入口。你只需要顺着函数调用的逻辑，以及我们提供的注释，就能够走通整个编译的流程。 "},"docs/step1/visitor.html":{"url":"docs/step1/visitor.html","title":"Visitor 模式速成","keywords":"","body":"Visitor 模式速成 编译器的构造中会使用到很多设计模式，Visitor 模式就是常见的一种。 基础的设计模式都在 OOP 课程中覆盖，这里重提一下 Visitor 模式，并以框架中的代码为示例进行介绍。 我们知道，编译器里有很多的树状结构。最典型的就是，源程序通过上下文无关文法解析后，得到的抽象语法树。在语义分析和中间表示生成两个步骤中，我们都需要遍历整个抽象语法树。Visitor 模式的目的，就是对遍历树状结构的过程进行封装，本质就是一个 DFS 遍历。 让我们考虑 step1 的文法： program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer 以这个文法对应的一段 MiniDecaf 代码为示例： int main() { return 2; } 它会对应如下的 AST 结构： program function type(int) identifier(main) param_list return int(2) 我们用缩进表示树结构，其中 program, function, type, identifier, param_list, block, return, int 等均为 AST 上的结点类型。 Python 框架 在框架中，我们有以下的 AST 结点类实现（进行了适当的简略）： ''' frontend/ast/node.py ''' class Node: # 所有 AST 结点的基类 # ... ''' frontend/ast/tree.py ''' class Program(ListNode[Union[\"Function\", \"Declaration\"]]): # 程序，AST 的根结点类型 # ... class Function(Node): # 函数 # ... class Statement(Node): # 语句基类 # ... class Return(Statement): # return 语句 # ... class TypeLiteral(Node): # 类型基类 # ... class TInt(TypeLiteral): # 整型 # ... 假设在经过了词法分析和语法分析后，我们已经成功将 MiniDecaf 代码转化为了 AST 结构。现在，我们想要编写代码对 AST 进行扫描。很容易写出递归的 DFS 遍历： def dfs(node: Node): if isinstance(node, Program): for func in node.functions: dfs(func) elif isinstance(node, Function): # do something for scanning a function node elif isinstance(node, Return): # ... dfs 函数接收一个结点，根据这个结点的类型进行深度优先遍历。容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的遍历逻辑。 那么我们把这些遍历逻辑封装到一个类里面，就得到了一个最简单的 Visitor。此外，为了便于实现，我们不使用 isinstance 来判断结点类型，而是调用结点自身的一个 accept 函数，并把不同的 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口。 ''' frontend/ast/node.py ''' class Node: # 所有 AST 结点的基类 def accept(self, v: Visitor[T, U], ctx: T) -> Optional[U]: raise NotImplementedError ''' frontend/ast/tree.py ''' class Program(ListNode[Union[\"Function\", \"Declaration\"]]): # ... def accept(self, v: Visitor[T, U], ctx: T): return v.visitProgram(self, ctx) class Function(Node): # ... def accept(self, v: Visitor[T, U], ctx: T): return v.visitFunction(self, ctx) # ... ''' frontend/ast/visitor.py ''' class Visitor(Protocol[T, U]): def visitOther(self, node: Node, ctx: T) -> None: return None def visitProgram(self, that: Program, ctx: T) -> Optional[U]: return self.visitOther(that, ctx) def visitFunction(self, that: Function, ctx: T) -> Optional[U]: return self.visitOther(that, ctx) # ... 之后，如果我们想要编写一种遍历 AST 的方法，可以直接继承 Visitor 类，并在对应结点的 visit 成员方法下实现对应的逻辑。例如，框架中用如下的方法进行符号表构建： class Namer(Visitor[ScopeStack, None]): def visitProgram(self, program: Program, ctx: ScopeStack) -> None: # ... for child in program: if isinstance(child, Function): child.accept(self, ctx) def visitFunction(self, func: Function, ctx: ScopeStack) -> None: # ... # ... 如果想要访问某个子结点 child，直接调用 child.accept(self, ctx) 即可。 C++ 框架 在框架中，我们有以下的 AST 结点类实现（进行了适当的简略）： // ast/ast.hpp class ASTNode { // 所有 AST 结点的基类 public: virtual NodeType getKind (); // 返回结点类型 // ... }; class FuncDefn : public ASTNode { // 所有函数 // ... }; class Statement : public ASTNode { // 语句基类 // ... }; class ReturnStmt : public Statement { // return 语句 // ... }; class Type : public ASTNode { // 类型基类 // ... }; class IntType : public Type { // 整型 // ... }; 假设在经过了词法分析和语法分析后，我们已经成功将 MiniDecaf 代码转化为了 AST 结构。现在，我们想要编写代码对 AST 进行扫描。很容易写出递归的 DFS 遍历： void dfs(ASTNode *node) { if (node->getKind() == NodeType::PROGRAM) { for (auto &&item : ((Program*)node)->func_and_globals) { dfs(item); } } else if (node->getKind() == NodeType::FUNC_DEFN) { // do something for scanning a function node } else if (node->getKind() == NodeType::RETURN) { // ... } } dfs 函数接收一个结点，根据这个结点的类型进行深度优先遍历。容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的遍历逻辑。 那么我们把这些遍历逻辑封装到一个类里面，就得到了一个最简单的 Visitor。此外，为了便于实现，我们不使用 getKind 来判断结点类型，而是调用结点自身的一个 accept 函数，并把不同的 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口。 // ast/ast.hpp class ASTNode { // 所有 AST 结点的基类 public: virtual void accept(Visitor *) = 0; }; class Program : public ASTNode { public: void accept(Visitor *v) override { // 仅作示意，实际实现在对应的 .cpp 文件里 v->visit(this); } }; class FuncDefn : public ASTNode { public: void accept(Visitor *v) override { // 仅作示意，实际实现在对应的 .cpp 文件里 v->visit(this); } }; // ast/visitor.hpp class Visitor { public: virtual void visit(Program *) {} virtual void visit(FuncDefn *) {} }; 之后，如果我们想要编写一种遍历 AST 的方法，可以直接继承 Visitor 类，并在对应结点的 visit 成员方法下实现对应的逻辑。例如，框架中用如下的方法进行符号表构建： class SemPass1 : public Visitor { void visit(ast::Program* prog) { // ... // visit global variables and each function for (auto it = prog->func_and_globals->begin(); it != prog->func_and_globals->end(); ++it) { (*it)->accept(this); // ... } // ... } } 如果想要访问某个子结点 child，直接调用 child.accept(self, ctx) 即可。 "},"docs/step1/manual-parser.html":{"url":"docs/step1/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 该文档简单展示使用 c 风格代码手写 parser 的过程。 0. 定义 我们的最终目标是这样一个函数，接受 token list 作为输入，输出一个代表整个程序结构的 AST。 parse(token_list) -> Prog 但是在 lab9 之前我们都只有一个 main 函数，所以这里的 Prog 可以暂时简化为 Function。 首先我们先定义 token 和 AST node enum TokenKind { TK_RESERVED, // 保留字，包含关键字和各种符号 TK_IDENT, // 标识符，如变量名、函数名 TK_NUM, // 数字字面量，如 1, 0 }; struct Token { TokenKind kind; char* str; //对应的字符串 // int raw, col; //如果你想得到报错位置，需要在这里记录行号与列号信息 }; struct Prog { Function* func; } struct Func { list stmts; } enum NodeKind{ ND_RETURN, // return 语句 ND_NUM, // 数值字面量 }; struct Node { NodeKind kind; int val; // 用于储存 ND_NUM 类型节点的数值 Node* expr; // 用来储存 ND_RETURN 类型节点返回的表达式节点 }; statement 和 expression 两类节点有较大的区别，推荐区分为不同的两类 Node，这里未作区分，也不会有什么问题。 推荐使用 unique pointer 和 shared pointer 来构建 AST 树。 1. 访问 Token 在 lex 阶段，我们的到了一个 token list，在 parse 阶段，我们需要访问这个 list 构建 AST ，我们需要一套访问接口来方便操作。 // 获得当前正在处理的 token，处理完毕返回 NULL Token* take_token(); // 进入下一个 token 的处理 void next_token(); 这一步实现简单，甚至不一定要抽象为一个函数，请大家自行实现。 2. 框架 解析的过程是对产生式的还原。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer 最上层函数为解析一个 Prog，目前相当与解析一个函数。 Program* parse() { Program* prog = new Program(); Function *fn = function(); prog->func = fn; return prog; } 　非终结符解析函数 parse()中，function()函数代表解析一个非终结符 function，即：从当前的 token 开始，消耗若干个 token，直到解析完成一个function（一个非终极符）。该函数没有输入，返回一个 AST 结点，过程中消耗了 token。接下来本文中类似函数（名称与产生式中非终结符一致）都是类似的含义。 按照生成式，解析一个 function 需要依次解析 type Identifier ( ） { statement }，如下： Function *function() { parse_reserved(\"int\"); // 应该为 type(), 这里做了简化 char *name; parse_ident(name); Function *fn = new Function(name); parse_reserved(\"(\"); parse_reserved(\")\"); parse_reserved(\"{\"); while (!parse_reserved(\"}\")) { fn->nodes.push_back(stmt()); } return fn; } 其中 parser_xxx()代表解析一个终结符。为直接访问 token 的函数，仅仅处理一个 token，与 token 类别一一对应。正如上方的说明，stmt() 表示，消耗一系列 token，解析出一条语句。 对非终极符的解析函数是由其他的非终结符函数、终结符函数和处理AST节点的语句构成，如果你同时完成了名称解析或者类型检查等，你还需要其他功能语句。 终结符解析函数：parser_xxx() // 解析成功返回 true, 否则为 false bool parse_int_literal(int &val); // 解析一个数字字面量，结果通过 val 返回 bool parse_reserved(const char* str); // 解析一个保留字 str bool parse_ident(char* &ident); // 解析一个标识符，结果通过 ident 返回 这些底层的解析函数会处理当前的 token（通过 take_token()）拿到，如果成功会跳过当前 token（也就是调用 next_token()）。 如 parse_reserved() 会检查当前 token 的类型是否为 TK_RESERVED，如果是，检查其字符串是否与给出的一致,如果是，返回 true。以上任意一步失败，返回 false。 如果你想要自己的编译器在发生错误时停止，可以这样。 Function *function() { assert(parse_reserved(\"int\")); // ... } 当然，也可以输出一些错误信息。如果你想得到报错位置，可以令 parse_xxx()返回 token 位置信息。 stmt() 类似 function()的思路，对语句的解析也可以按照生成式进行，目前仅需要解析 return 一种类型的语句。 Node* stmt() { Node* node = NULL; if (parse_reserved(\"return\")) { node = new Node(ND_RETURN); node->expr = expr(); assert(parse_reserved(\";\")); return node; } return node; } 其中, expr()为解析一个表达式的函数，因为目前的 expr()仅仅需要解析一个数字，可以通过调用 parse_int_lliteral()轻松实现。返回一个类型为 ND_NUM的Node就好了。 总结 第一个 lab 的工作看似很简单，但是我们需要搭建一个比较完整的框架来便于后续工作，其实工作量较大。接下来工作会比较轻松。 "},"docs/step1/spec.html":{"url":"docs/step1/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step1 语法规范 我们采用 EBNF (extended Barkus-Naur form) 记号书写语法规范，采用类似 ANTLR 的记号： 小写字母打头的是非终结符（如 program），大写字母打头的是终结符（如 Identifier），可以用字符串字面量表示终结符（如 'int'） 后面会用到：( 和 ) 表示分组，| 表示选择，* 零或多次，+ 一或多次，? 零或一次。 很容易通过增加新的非终结符，去掉这些符号。例如 x+ 就可以被替换成新的非终结符 y，并且 y : x | x y。 EBNF 也有很多写法，另一种是用尖括号表示非终结符 ::= 等。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer step1 语义规范 1.1 MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2^31, 2^31-1]，补码表示。 1.2 编译器应当只接受 [0, 2^31-1] 范围内的整数常量, 不支持负整数常量，如果整数不在此范围内，编译器应当报错。引入负号-后，可以用负号配合正整数常量来间接表示负整数常量。 1.3 如果输入程序没有 main 函数，编译器应当报错。 "},"docs/step2/intro.html":{"url":"docs/step2/intro.html","title":"任务概述","keywords":"","body":"实验指导 step2：一元运算符 step2 中，我们要给整数常量增加一元运算：取负 -、按位取反 ~ 以及逻辑非 !。 语法上，我们需要修改 expression 的定义，从 expression : Integer 变成： expression : unary unary : Integer | ('-'|'!'|'~') unary 三个操作的语义和 C 以及常识相同，例如 ~0 == -1，!!2 == 1。 稍微一提，关于按位取反，我们使用补码存储 int；关于逻辑非，只有 0 表示逻辑假，其他的 int 都是逻辑真。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step2/guide.html":{"url":"docs/step2/guide.html","title":"实验指导","keywords":"","body":"step2 实验指导 我们按照上一节划分的编译器阶段，分阶段给出 step2 实验指导。 词法语法分析 如果你使用工具完成词法语法分析，修改你的规范以满足要求，剩下的交给工具即可。 语法规范已经给出，词法规范的变化也很简单，新增三个 token：-、~ 和 !。 你的规范和我们的要求等价、能通过测试即可，不用完全一样。 语义检查无需修改。 如果你是手写分析，参见这里。 IR 生成 显然，我们要引入一类 IR 表示一元操作。 一元操作 IR 的含义是：弹出栈顶，对弹出的值做某个一元操作，再把操作的结果值压入栈顶。 换言之，就是直接对栈顶做某个操作。 指令 参数 含义 IR 栈大小变化 neg 无参数 栈顶取负 不变 not 同上 栈顶按位取反 不变 lnot 同上 栈顶取逻辑非 不变 和 step1 一样，这一节所讲的领悟意思即可。 你不用照着实现。 例如你可以把三条指令变成一条 Unary(op)，其中 op 是 \"-\"、\"~\" 或 \"!\"。 你甚至也不必显式转成 IR。 和 step1 一样，采用 Visitor 模式遍历 AST 来生成 IR。除了 step1 的要求，step2 还要求你遍历 AST 时， 遇到一元表达式的时候，先生成子表达式的 IR，然后再根据操作类型生成一个 neg 或 not 或 lnot 所以，~!--3 会翻译成 push 3 ; neg ; neg ; lnot ; not 五条 IR 指令。 汇编生成 很简单，如下表。 IR 汇编 neg lw t1, 0(sp) ; neg t1, t1 ; sw t1, 0(sp) not …… lnot …… 要知道每个操作生成什么样的汇编，可以参考 gcc 的输出。 例如我们想知道取负的汇编，那我们用 gcc 编译 int foo(int x) { return -x; }， 结果如下（记得加 -O3），我们就知道取负是 neg 目标寄存器, 操作数寄存器。 foo: neg a0,a0 ret 仿照上面，自己确定 not 和 lnot 的汇编。 思考题 我们在语义规范中规定整数运算越界是未定义行为，运算越界可以简单理解成理论上的运算结果没有办法保存在32位整数的空间中，必须截断高于32位的内容。请设计一个 minidecaf 表达式，只使用-~!这三个单目运算符和从 0 到 2147483647 范围内的非负整数，使得运算过程中发生越界。 提示：发生越界的一步计算是-。 总结 本节内容不多。 "},"docs/step2/manual-parser.html":{"url":"docs/step2/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 节点定义变化 增加三种表达式节点，分别为：按位取反、取负、逻辑取反 struct NodeKind { + ND_NEG, + ND_NOT, + ND_BITNOT, } 这一变化很简单，以后省略。 parse 过程变化 按照产生式变化对应修改即可，很简单。 expression : unary unary : Integer | ('-'|'!'|'~') unary Node* expr() { return unary(); } Node* unary() { if(parse_reserved(\"-\")) { Node* neg = new Node(ND_NEG); neg->expr = unary(); return neg; } //...　`!``~`同理 return num(); } 注意，unary()的解析是递归的，这与产生式是一致的。 "},"docs/step2/spec.html":{"url":"docs/step2/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step2 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : unary unary : Integer | ('-'|'!'|'~') unary step2 语义规范 2.1 运算符 - 的结果是其操作数的相反数。 2.2 运算符 ~ 的结果是其操作数的二进制反码（也就是说，结果中的每一个二进制位是 1 当且仅当其对应的二进制位是 0）。 2.3 当操作数不等于 0 时，逻辑非运算符 ! 的结果为 0；当操作数等于 0 时，其结果为 1。 2.4 MiniDecaf 中，负数字面量不被整体作为一个 token。它被看成是一个取负符号、后面是它的绝对值。 所以我们无法用字面量表示 -2147483648，但可以写成 -2147483647-1（待我们加上四则运算后）。 2.5 整数运算越界是未定义行为（undefined behavior），即对程序的行为无任何限制。 例如 -(-2147483647-1) 是未定义行为。这一条规则对于后续 step 引入的运算符也都适用。 对于含有未定义行为的 C/C++ 程序，在启用优化选项编译时，编译器可能产生意料之外的结果。 "},"docs/step3/intro.html":{"url":"docs/step3/intro.html","title":"任务概述","keywords":"","body":"实验指导 step3：加减乘除模 step3 我们要增加的是：加 +、减 -、乘 *、整除 /、模 % 以及括号 ( )。 语法上我们继续修改 expression，变成 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1+2*(4/2+1) == 7。 我们这种表达式语法写法可能比较繁琐，但它有几个好处： 和C99 标准草案保持一致 把优先级和结合性信息直接编码入语法里，见优先级和结合性一节。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step3/guide.html":{"url":"docs/step3/guide.html","title":"实验指导","keywords":"","body":"step3 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 对有兴趣的同学：虽然 -2 和 2-3 里面的 - 意义不同，但 lexer 不知道这点（parser 才知道），所以它们都会用同样的 token kind - 表示。 但有时，可能需要后续阶段告诉 lexer（或 parser）一些信息，最经典的例子是 “typedef-name identifier problem”。 我们的表达式语法规范和 C 标准的基本相同，但略显繁琐。 如果你选择的语法分析工具支持优先级和结合性，并且你希望用这些信息来简化语法分析工具的编写，请参考这里。 语义检查无需修改。 如果你是手写分析，参见这里。 IR 生成 我们同样引入一类 IR 表示二元操作。 执行二元操作的 IR 时，两个操作数需要位于栈顶，然后它们被弹出、进行相应操作，再把结果压入栈顶。 指令 参数 含义 IR 栈大小变化 add 无参数 弹出栈顶两个元素，压入它们的和 减少 1 sub 无参数 弹出栈顶两个元素，压入它们的差，顺序如上 减少 1 mul、div、rem 无参数 ……乘除模 减少 1 其中我们规定二元操作的右操作数在栈顶，左操作数在右操作数下面。 举个例子，(10-3)%5 翻译成 IR 是 [push 10 ; push 3 ; sub ; push 5 ; rem] 五条指令， 执行过程中栈变化如图。 类比 step2，生成 IR 时 Visitor 遍历 AST 遇到二元操作，需要（注意 1. 和 2. 的顺序） 首先生成左操作数的 IR（左操作数入栈，栈顶是左操作数） 然后生成右操作数的 IR（右操作数入栈，栈顶是右操作数) 根据操作不同生成对应的二元 IR 上面的 3 步执行完后，栈大小比执行第 1. 步以前增加 1，栈顶就是二元操作的结果。 这符合我们在 step1 中的假设： 考虑源代码中某个表达式被翻译成了一系列 IR 指令，那么从任何初始状态出发执行这些 IR 指令， 完成后 IR 栈大小增加 1，栈顶就是表达式的值。 汇编生成 仿照 step2 所说，用 gcc 自己确定 sub/mul/div/rem 的汇编。 IR 汇编 add lw t1, 4(sp) ; lw t2, 0(sp) ; add t1, t1, t2 ; addi sp, sp, 4 ; sw t1, 0(sp) sub,mul,div,rem …… 思考题 请给出将寄存器 t0 中的数值压入栈中所需的 riscv 汇编指令序列；请给出将栈顶的数值弹出到寄存器 t0 中所需的 riscv 汇编指令序列。 我们知道“除数为零的除法是未定义行为”，但是即使除法的右操作数不是 0，仍然可能存在未定义行为。请问这时除法的左操作数和右操作数分别是什么？请将这时除法的左操作数和右操作数填入下面的代码中，分别在你的电脑（请标明你的电脑的架构，比如 x86-64 或 ARM）中和 RISCV-32 的 qemu 模拟器中编译运行下面的代码，并给出运行结果。（编译时请不要开启任何编译优化） #include int main() { int a = 左操作数; int b = 右操作数; printf(\"%d\\n\", a / b); return 0; } 总结 本节重点是执行过程中栈的变化，以及上面提到的 step1 的假设，参见上面 IR 生成一节。 "},"docs/step3/precedence.html":{"url":"docs/step3/precedence.html","title":"优先级和结合性","keywords":"","body":"优先级和结合性 操作符有优先级和结合性的概念，在之前的编程经历中大家应该已经对这两个概念已经有了直观的理解，这里用例子进一步解释一下： 优先级是两个操作符之间的关系，例如*的优先级比+高，所以表达式1 + 2 * 3应该解析成语法树add (1 mul (2 3))（前序表示），不能解析成mul (add (1 2) 3) 结合性是一个操作符的性质，例如-是左结合的，所以表达式1 - 2 - 3应该解析成sub (sub (1 2) 3)，不能解析成sub (1 sub (2 3)) 我们给出的语法规范已经表示了这样的性质，因此理论上我们不需要再额外定义操作符的优先级和结合性了。你可以自己试试，按照本步给出的语法规则，上面的两个表达式确实只能解析成我们期望的结果。 但是有一个问题：这样的语法规范虽然是正确的，也确实可以直接用来实现语法分析器了，但并不符合直观：我们一开始学习C或者别的编程语言的时候，讲的就是一个二元表达式由两个子表达式和中间的操作符组成，并且操作符有优先级和结合性。也就是这样的： expression : expression ('+'|'-') expression | expression ('*'|'/'|'%') expression | ('-'|'~'|'!') expression | Integer | '(' expression ')' 当然，它是有歧义的，你也可以自己试试，如果只有这些产生式的话，上面的两个表达式都可以解析成正确或者错误的结果。所以如果想基于这个规范来实现语法分析器，就必须告诉语法分析工具这些操作符的优先级和结合性是什么。 之后每一步给出的语法都是没有歧义，本身就能体现优先级和结合性的。如果你确实想借助优先级和结合性来实现，需要两个步骤： 把我们给出的语法规范转化成类似上面这样“更模糊”，有歧义的语法规范。我们相信这个方向的转化应该是容易的。 指定每个操作符的优先级和结合性。可以参考https://en.cppreference.com/w/c/language/operator_precedence，它给出了C语言操作符的优先级和结合性，因为我们的MiniDecaf语言是C语言的一个子集，所以这张表格也足够我们的语言使用了。 "},"docs/step3/manual-parser.html":{"url":"docs/step3/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 struct Node { - Node* expr; + Node* lexpr; + Node* rexpr; } 现在需要储存两个 expression。 parse 过程变化 按照产生式变化对应修改即可，很简单。 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative // ... primary : Integer | '(' expression ')' 加法示例： Node* additive() { Node* node = multiplicative(); while(parse_reserved(\"+\")) { //这里只展示了 `+`, `-`同理 node = new_binary(ND_ADD, node, multiplicative()); } return node; } Node* new_binary(NodeKind kind, Node* lexpr, Node* rexpr); // 类似构造函数，简单赋值 注意左结合性，请思考为何这么写能够保证左结合。如果一种算法是右结合的，应该怎样写呢？ "},"docs/step3/spec.html":{"url":"docs/step3/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step3 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step3 语义规范 3.1 二元操作符 * 的结果是操作数的乘积。 3.2 二元操作符 / 的结果是第一个操作数除以第二个操作数所得的商的整数部分（即所谓“向零取整”），二元操作符 % 的结果是第一个操作数除以第二个操作数所得的余数。在两种操作中，如果第二个操作数为 0，则其行为都是未定义的。当 b 不为 0 时，表达式 (a/b)*b + a%b 应该等于 a。 3.3 二元操作符 + 的结果是操作数的和。 3.4 二元操作符 - 的结果是第一个操作数减去第二个操作数所得的差。 3.5 除非特别声明，子表达式求值顺序是未规定行为（unspecified behavior），即其行为可以是多种合法的可能性之一。也就是说，以任意顺序对子表达式求值都是合法的。 例如：执行 int a=0; (a=1)+(a=a+1); 之后 a 的值是未规定的（待我们加上变量和赋值运算符后，这个问题才会产生真正切实的影响）。 "},"docs/step4/intro.html":{"url":"docs/step4/intro.html","title":"任务概述","keywords":"","body":"实验指导 step4：比较和逻辑表达式 step4 我们要增加的是： 比较大小和相等的二元操作：、、>=, >, ==, != equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive 逻辑与 &&、逻辑或 || expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1=2 是逻辑真（int 为 1）。 但特别注意，C 中逻辑运算符 || 和 && 有短路现象，我们不要求。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step4/guide.html":{"url":"docs/step4/guide.html","title":"实验指导","keywords":"","body":"step4 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查无需修改。 手写分析根据生成式变化修改即可，变化很小。 IR 生成 沿用 step3 加入的二元操作 IR（以及左右操作数的位置），新的 IR 如下。 指令 参数 含义 IR 栈大小变化 eq 无参数 ==（弹出栈顶两个元素，如果相等压入 1，否则压入 0） 减少 1 ne 无参数 ……!= 减少 1 le 无参数 …… 减少 1 ge 无参数 ……>= 减少 1 lt 无参数 …… 减少 1 gt 无参数 ……> 减少 1 land 无参数 ……&& 减少 1 lor 无参数 弹出栈顶两个元素，将其逻辑或压入栈 减少 1 这样设计的IR中，&&和||都是没有短路性质的。我们的语义规范要求是否实现短路性质都可以。 汇编生成 对于比较大小和相等的操作，参照 gcc 结果，自行完成汇编生成。 逻辑表达式会麻烦一点，因为 gcc 可能会用跳转来实现&&和||，比较难以理解，所以下面直接给出 land 和 lor 对应的不使用跳转的汇编。 表格中，我们省略了汇编的前缀 lw t1, 4(sp) ; lw t2, 0(sp) 和后缀 addi sp, sp, 4 ; sw t1, 0(sp)。 注意 RISC-V 汇编中的 and 和 or 都是位运算指令，不是逻辑运算指令。 IR 汇编 lor or t1,t1,t2 ; snez t1,t1 land snez t1,t1 ; snez t2,t2 ; and t1,t1,t2 思考题 在表达式计算时，对于某一步运算，是否一定要先计算出所有的操作数的结果才能进行运算？ 在 MiniDecaf 中，我们对于短路求值未做要求，但在包括 C 语言的大多数流行的语言中，短路求值都是被支持的。为何这一特性广受欢迎？你认为短路求值这一特性会给程序员带来怎样的好处？ 总结 step4 和 step3 差别不大。 "},"docs/step4/spec.html":{"url":"docs/step4/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step4 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step4 语义规范 4.1 关系操作符 （小于）、>（大于）、（小于等于）和>=（大于等于）的结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。 关系操作符可能导致表达式的含义与数学文献中常见的含义不同，例如 0 的含义与 (0 相同，即“如果 0 小于 1，那么判断是否有 1 小于 2，否则判断是否有 0 小于 2”。 4.2 判等操作符 ==（等于）和 !=（不等于）类似于关系操作符，结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。但判等操作符的优先级比关系操作符更低。对于任意一对操作数，这两个操作符中有且仅有一个结果为 1。 其优先级的设定会导致其含义在某些时候可能会反直观，例如，0 的运算结果为 1。 4.3 当操作数都非 0 时，逻辑与操作符 && 的结果为 1；否则其结果为 0。 4.4 当操作数有一个非 0 时，逻辑或操作符 || 的结果为 1；否则其结果为 0。 4.5 逻辑操作符 || 和 && 依然遵循语义规范 3.5，即其操作数的求值顺序是未指定行为。 换言之，我们不对逻辑表达式的短路求值做要求，可以将操作数两个以任意顺序计算出，再计算逻辑操作的结果。 "},"docs/step5/intro.html":{"url":"docs/step5/intro.html","title":"任务概述","keywords":"","body":"实验指导 step5：局部变量和赋值 这一步我们终于要增加变量了，包括 变量的声明 变量的使用（读取/赋值） 并且，虽然还只有一个 main 函数，但 main 函数可以包含多条语句和声明了。 为了加入变量，我们需要确定：变量存放在哪里、如何访问。 为此，我们会引入 栈帧 的概念，并介绍它的布局。 语法上，step5 的改动如下： function : type Identifier '(' ')' '{' statement* '}' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression primary : Integer | '(' expression ')' | Identifier 并且我们也要增加语义检查了：变量不能重复声明，不能使用未声明的变量。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step5/guide.html":{"url":"docs/step5/guide.html","title":"实验指导","keywords":"","body":"step5 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查部分，我们需要检查是否（一）使用了未声明的变量、（二）重复声明变量。 为此，我们在生成 IR 的 Visitor 遍历 AST 时，维护当前已经声明了哪些变量。 遇到变量声明（declaration）和使用（primary 和 assignment）时检查即可。 可以把这个要求和后面提到的符号表结合，放到 IR 生成去做。 如果你是手写分析，参见这里。 IR 生成 为了完成 step5 的 IR 生成，我们需要确定 IR 的栈帧布局，请看 这里。 step1提到，局部变量保存在栈上，这个栈和IR中的运算栈并不是一个概念。 前者指的是汇编中一片可以增长的物理空间（可以称之为物理栈），后者是一个逻辑上的概念。 这二者的关系是，我们之前一直在使用物理栈的空间来实现运算栈。 局部变量存放在物理栈上，运算栈也在物理栈上，它们的内存空间很接近，但是二者是互不干扰的，对运算栈的压栈弹栈操作，不能影响到局部变量的值。 因此我们需要加入访问物理栈内部的 load/store，以及生成栈上地址的 frameaddr 指令。 此外我们还加入一个pop指令，这与上面的讨论没有什么关系，是用于别的用途： 指令 参数 含义 IR 栈大小变化 frameaddr 一个非负整数常数 k 把当前栈帧底下开始第 k 个元素的地址压入栈中 增加 1 load 无参数 将栈顶弹出，作为地址 1 然后加载该地址的元素（int），把加载到的值压入栈中 不变 store 无参数 弹出栈顶作为地址，读取新栈顶作为值，将值写入地址开始的 int 减少 1 pop 无参数 弹出栈顶，忽略得到的值 减少 1 IR 生成还是 Visitor 遍历，并且 遇到读取变量 primary: Identifier 的时候，查符号表确定变量是第几个，然后生成 frameaddr 和 load。 如果查不到同名变量，应当报错：变量未定义 遇到变量赋值的时候，先生成等号右手边的 IR，同上对等号左手边查符号表，生成 frameaddr 和 store。 注意赋值表达式是有值的，执行完它的 IR 后栈顶还保留着赋值表达式的值。这就是为什么 store 只弹栈一次。 遇到表达式语句时，生成完表达式的 IR 以后记得再生成一个 pop，保证栈帧要满足的第 1. 条性质（这里有说） 遇到声明时，除了记录新变量，还要初始化变量。 为了计算 prologue 中分配栈帧的大小，IR 除了一个指令列表，还要包含一个信息：局部变量的个数。 main 有多条语句了，它的 IR 是其中语句的 IR 顺序拼接。 例如 int main(){int a=2; a=a+3; return a;}，显然 a 是第 0 个变量。 那它的 IR 指令序列是（每行对应一条语句）： push 2 ; frameaddr 0 ; store ; pop ; frameaddr 0 ; load ; push 3 ; add ; frameaddr 0 ; store ; pop ; frameaddr 0 ; load ; ret ; 汇编生成 IR 指令到汇编的对应仍然很简单，如下表。 IR 汇编 frameaddr k addi sp, sp, -4 ; addi t1, fp, -12-4*k ; sw t1, 0(sp) load lw t1, 0(sp) ; lw t1, 0(t1) ; sw t1, 0(sp) store lw t1, 4(sp) ; lw t2, 0(sp) ; addi sp, sp, 4 ; sw t1, 0(t2) pop addi sp, sp, 4 但除了把 IR 一条一条替换成汇编，step5 还需要生成 prologue 和 epilogue，并且 ret 也要修改了， 参见栈帧文档。 IR 汇编 ret lw a0, 0(sp) ; addi sp, sp, 4 ; j FUNCNAME_epilogue 另外我们还要求 main 默认返回 0： 5.4 执行完 main 函数但没有通过 return 结束时，返回值默认为 0。 显然，如果 main 是通过 return 结束的，按照上面的修改一定是跳到 main_epilogue，否则是顺序执行到 main_epilogue 的。 因此我们在 main_epilogue 之前，所有语句之后，加上 push 0 的汇编即可，表示默认返回 0。 思考题 描述程序运行过程中函数栈帧的构成，分成哪几个部分？每个部分所用空间最少是多少？ 有些语言允许在同一个作用域中多次定义同名的变量，例如这是一段合法的 Rust 代码（你不需要精确了解它的含义，大致理解即可）： fn main() { let a = 0; let a = f(a); let a = g(a); } 其中f(a)中的a是上一行的let a = 0;定义的，g(a)中的a是上一行的let a = f(a);。 如果 MiniDecaf 也允许多次定义同名变量，并规定新的定义会覆盖之前的同名定义，请问在你的实现中，需要对定义变量和查找变量的逻辑做怎样的修改？ 备注 1. 我们规定 load 的地址必须对齐到 4 字节，生成 IR 时需要保证。store 也是。 ↩ "},"docs/step5/stackframe.html":{"url":"docs/step5/stackframe.html","title":"栈帧","keywords":"","body":"栈帧 所以我们需要确定栈（包括 IR 的栈和汇编的栈）上面到底有那些元素，这些元素在栈上的布局如何。 汇编语言课上提到过 栈帧（stack frame） 的概念，简单回想一下： 每次调用和执行一个函数，都会在栈空间上开辟一片空间，这篇空间就叫“栈帧”。 栈帧里存放了执行这个函数需要的各种数据，包括局部变量、callee-save 寄存器等等。 当然，既然汇编有栈帧, 栈式机 IR 也有栈帧。 我们只有一个函数 main，直到 step9 我们才会有多函数支持。 所以现在关于栈帧的讨论，我们就只考虑一个栈帧。 后面的 step 会深入讨论。 关于栈帧，有两个问题需要说明 栈帧长什么样？即、栈帧上各个元素的布局如何？ 栈帧是如何建立与销毁的？ 第 1. 点，我们规定，程序执行的任何时刻，栈帧分为三块： 栈顶是计算表达式用的运算栈，它可能为空（当前不在计算某表达式的过程中） 然后一片空间存放的是当前可用的所有局部变量 返回地址、老的栈帧基址等信息 下图展现了汇编栈的栈帧结构，以及执行过程中栈中内容的变化。 栈左上方是源代码，右上方是 IR。 粉色背景表示已经执行完的汇编对应的源代码/IR。 假设用户给的输入是 24 12。 从中可以看出，栈帧满足如下性质 每条语句开始执行和执行完成时，汇编栈帧大小都等于 8 + 4 * 局部变量个数 个字节，其中 4 == sizeof(int) 是一个 int 变量占的字节数 （就是 step1 中的假设）任何表达式对应的 IR 序列执行结果一定是：栈帧大小增加 4，栈顶四字节存放了表达式的值。 汇编栈帧底部还保存了 fp 和返回地址，使得函数执行完成后能够返回 caller 继续执行。 把栈帧设计成这样，访问变量就可以直接用 fp 加上偏移量来完成。 例如第 1. 小图中，“读取 a” 就是加载 -12(fp)；第 3. 小图中，“保存到 c” 就是保存到 -20(fp)。 我们只叙述了汇编的栈帧，但 IR 的和汇编的一样（就我们的设计而言），也是三个部分，也要有 old fp 和返回地址。 建立栈帧 进入一个函数后，在开始执行函数体语句的汇编之前，要做的第一件事是：建立栈帧。 每个函数最开始、由编译器生成的用于建立栈帧的那段汇编被称为函数的 prologue。 就 step5 而言，prologue 要做的事情很简单 分配栈帧空间 保存 fp 和返回地址（在寄存器 ra 里） 举个例子，下面是一种可能的 prologue 写法。 其中 FRAMESIZE 是一个编译期已知的常量，等于 8 + 4 * 局部变量个数（这名字不太准确，因为有运算栈，栈帧大小其实不是常量） addi sp, sp, -FRAMESIZE # 分配空间 sw ra, FRAMESIZE-4(sp) # 储存返回地址 sw fp, FRAMESIZE-8(sp) # 储存 fp addi fp, sp, FRAMESIZE # 更新 fp 当然，开始执行函数时需要建立栈帧，结束执行时就需要销毁栈帧。 函数末尾、用于销毁栈帧的一段汇编叫函数的 epilogue，它要做的是： 设置返回值 回收栈帧空间 恢复 fp，跳回返回地址（ret 就是 jr ra） 返回值我们可以直接放在 a0 中，也可以放在栈顶让 epilogue 去加载。 如果是后者，那么上面“栈帧满足如下性质”的 1. 要把 return 作为例外了。 把返回值放在栈顶的话，下面是 epilogue 一种可能的写法。 前缀 FUNCNAME 是当前函数函数名，例如 main，加上前缀以区分不同函数的 epilogue。 FUNCNAME_epilogue: # epilogue 标号，可作为跳转目的地 lw a0, 0(sp) # 从栈顶加载返回值，此时 sp = fp - FRAMESIZE - 4 addi sp, sp, 4 # 弹出栈顶的返回值 lw fp, FRAMESIZE-8(sp) # 恢复 fp lw ra, FRAMESIZE-4(sp) # 恢复 ra addi sp, sp, FRAMESIZE # 回收空间 jr ra # 跳回 caller 就 step5，保存恢复 fp/ra 的确不必要。但是加上会让后面步骤更方便。 需要注意的是，IR 的 ret 指令不能直接 jr ra 了，而是要跳转执行 epilogue，即 j FUNCNAME_epilogue。 变量声明 对于每个变量声明，我们需要 设定变量相对 fp 的偏移量。 在栈帧上预留保存变量空间 第 2. 点已经在 prologue 中完成了，所以重点是第 1. 点。 对每个变量用一个数据结构维护其信息，如：名称、类型（step12）、声明位置、初始值等。 目前阶段，你可以简单的使用一个简单的链表或者数组来保存变量的信息。 这个保存变量符号的表被称为 符号表（symbol table）。 那偏移量可以（一）作为变量数据结构的一个字段、（二）也可以维护一个变量到偏移量的映射、（三）像下面通过某种方法计算得到。 当然，不能用一张符号表覆盖整个程序，程序中不同位置的符号表是不同的。 例如，符号表只会包含被声明的变量的信息，因此在 int a=0; 之后的符号表比之前的多了一个条目表示 a 对应的变量数据结构。 确定变量的偏移量本身倒很容易：从前往后每一个声明的变量偏移依次递减，从 -12(fp) 开始，然后是 -16(fp)、-20(fp) 以此类推。 所以对于每个变量，我们只需在其数据结构中记录：它是从前往后第几个变量。 第 k>=0 个变量的偏移量就是 -12-4*k。 目前我们没有作用域的概念，这样做是没问题的，在第7章引入作用域后，会有一种更加节约空间的做法。 "},"docs/step5/manual-parser.html":{"url":"docs/step5/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 推荐你先阅读本节其他部分，了解栈帧和对局部变量的处理方式。 定义变化 struct Node { + Var* var; } // 为了维护变量信息的结构体 + struct Var { + char* name; + int offset; // 在栈中距离 fp 的 offset + Node* init; // 初始化的值 + } parse 变化 语句类别变多了： Node* stmt() { Node* node = NULL; Type* ty; // Return statement if (parse_reserved(\"return\")) { node = new_stmt(ND_RETURN, expr()); assert(parse_reserved(\";\")); return node; } // 局部变量声明 if (type()) { return declaration(); } // 直接由表达式构成的语句，注意 a = 1; 就是此类，有一个表达式的值没有用到 node = expr(); assert(parse_reserved(\";\")); return new_stmt(ND_UNUSED_EXPR, node); } 具体的 declaration()等按照生成式很容易写出来。 declaration : type Identifier ('=' expression)? ';' Node* declaration() { // type() 已经在 stmt() 中完成 char* name; assert(parse_ident(name)); Var* var = new Var(name); // 这里储存已经声明变量的信息，为名称解析做准备 add_local(var); // 如果进行了初始化 if (parse_reserved(\"=\")) { var->init = expr(); } assert(parse_reserved(\";\")); Node* node = new_stmt(ND_DECL); node->var = var; return node; } 在被引用时： Node* primary() { // ... char* name; if (parse_ident(name)) { // find_var 负责寻找同名变量, 在 add_local 维护的数据结构中寻找即可 Var* var = find_var(name); // 引用未声明变量的检查 assert(var); return new_var_node(var); } // ... } [可选]变量信息维护 变量信息的维护可以在 IR 生成中进行，也可以在 parser 的同时进行（本文中就是这样做的），也可以专门作为一个步骤进行。 在处理变量声明时需要维护已声明变量的信息(add_local())，可以使用链表，也可以使用你喜欢的数据结构来维护它。不过要注意 add_local()中应该同时完成 offset 的确定和变量重复定义的检查。在变量被引用时，你需要通过名称找到对应的结构体。 "},"docs/step5/spec.html":{"url":"docs/step5/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step5 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement* '}' type : 'int' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step5 语义规范 5.1 每一条变量声明（定义）指定了对标识符的解释和属性。当变量被定义时，应当有一块存储空间为这个变量所保留。当变量声明之后，若与这个变量的名称相同的标识符作为操作数（operand）出现在一个表达式中时，其就应被指派（designate）为这个变量。 5.2 变量的初始化表达式指定了变量的初始值。 5.3 同一个标识符应只能作为至多一个变量的名字，即是说，不允许声明重名变量。 5.4 对未声明的变量的使用是错误。 5.5 没有被初始化的（局部）变量的值是不确定的。 在初始化表达式中，正在被初始化的变量已被声明，但其值尚未被初始化。 例如，int a = a + 1;，这样一条声明在语义上等价于 int a; a = a + 1; 5.6 局部变量的名字可以为 main。 5.7 赋值运算 = 的左操作数必须是一个可修改的左值（modifiable lvalue）。左值（lvalue）即一个会被指派为某个变量的表达式，如在 int a; a = 1; 中，a 即是一个会被指派为变量的表达式。的左值可修改是指被指派的变量不能是一个左值数组。 就 step5 来说，这一点其实几乎已经被语法保证，因为其 = 的左边只能是一个标识符，只需再要求其是一个已经声明过的变量的名字即可。 详见后面 step12 的讨论。 5.8 在赋值运算（=）中，右操作数的值会被存在左操作数所指派的变量中。 5.9 赋值表达式的结果，为赋值运算完成后左操作数所指派的变量的值，但这个结果本身并非左值。 5.10 一个函数中可以有任意多条 return 语句。 5.11 当 main 函数执行至 } 时，应终止执行并返回 0。 "},"docs/step6/intro.html":{"url":"docs/step6/intro.html","title":"任务概述","keywords":"","body":"实验指导 step6： step6 我们要支持 if 语句和条件表达式（又称三元/三目表达式，ternary expression）。 语法上的改动是： if 表达式 statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? 条件表达式 assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional block_item：为了下一阶段做准备 function : type Identifier '(' ')' '{' block_item* '}' block_item : statement | declaration if 语句的语义和 C 以及常识相同，条件表达式优先级只比赋值高。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step6/guide.html":{"url":"docs/step6/guide.html","title":"实验指导","keywords":"","body":"step6 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查无需修改。 如果你是手写分析，参见这里。 注意 step6 引入 block_item 后，declaration 不再是语句，所以 if (a) int b; 不是的合法代码。 这和 C 标准是一致的（不过在C++中这样的代码是合法的，也许这更加符合你的常识）。 悬吊 else 问题 这一节引入的 if 语句既可以带 else 子句也可以不带，但这会导致语法二义性：else 到底和哪一个 if 结合？ 例如 if(a) if(b) c=0; else d=0;，到底是 if(a) {if(b) c=0; else d=0;} 还是 if(a) {if(b) c=0;} else d=0;（其中有大括号，step7中会支持，不过意思不难理解）？ 这个问题被称为 悬吊 else（dangling else） 问题。 如果程序员没有加大括号，那么我们需要通过一个规定来解决歧义。 我们人为规定：else 和最近的 if 结合，也就是说上面两种理解中只有前者合法。 为了让 parser 能遵守这个规定，一种方法是设置产生式的优先级，优先选择没有 else 的 if。 按照这个规定，parser 看到 if(a) if(b) c=0; else d=0; 中第一个 if 时，选择没有 else 的 if； 而看到第二个时只能选择有 else 的 if 1，也就使得 else d=0; 被绑定到 if(b) 而不是 if(a) 了。 IR 生成 显然，我们需要跳转指令以实现 if，同时还需要作为跳转目的地的标号（label）。 我们的跳转指令和汇编中的类似，不限制跳转方向，往前往后都允许。 指令 参数 含义 IR 栈大小变化 label 一个字符串 什么也不做，仅标记一个跳转目的地，用参数字符串标识 不变 beqz 同上 弹出栈顶元素，如果它等于零，那么跳转到参数标识的 label 开始执行 减少 1 bnez 同上 弹出栈顶元素，如果它不等于零，那么跳转到参数标识的 label 开始执行 减少 1 br 同上 无条件跳转到参数标识的 label 开始执行 不变 注意一个程序中的标号，也就是 label 的参数，必须唯一，否则跳转目的地就不唯一了。 简单地维护一个计数器即可，例如 label l1, label l2, label l3 ... Visitor 遍历 AST 遇到一个有 else 的 if 语句，为了生成其 IR，要生成的是 首先是 条件表达式的 IR：计算条件表达式。 beqz ELSE_LABEL：判断条件，若条件不成立则执行 else 子句 跳转没有执行，说明条件成立，所以之后是 then 子句的 IR br END_LABEL：条件成立，执行完 then 以后就结束了 label ELSE_LABEL，然后是 else 子句的 IR label END_LABEL：if 语句结束。 例子：if (a) return 2; else a=2+3; 的 IR 是 frameaddr k ; load，其中 k 是 a 的 frameaddr beqz else_label1，数字后缀是避免标号重复的 push 2 ; ret br end_label1 label else_label1，然后是 push 2 ; push 3 ; add ; frameaddr k ; store ; pop label end_label1 仿照上面，容易写出条件表达式的 IR 应该如何生成，并且同时也能保证满足语义规范 6.4 和 3.2 不同，条件表达式规定了子表达式的求值顺序。 首先对条件求值。如果条件值为真，然后仅对 ? 和 : 之间的子表达式求值，作为条件表达式的值， 不得对 : 之后的子表达式求值。 如果条件为假，类似地，仅对 : 之后的子表达式求值。 类似，无 else 的 if 语句的 IR 包含 条件表达式的 IR beqz END_LABEL then 子句的 IR label END_LABEL 汇编生成 如下表： IR 汇编 label LABEL_STR LABEL_STR: br LABEL_STR j LABEL_STR2 beqz LABEL_STR lw t1, 0(sp) ; addi sp, sp, 4 ; beqz t1, LABEL_STR bnez LABEL_STR lw t1, 0(sp) ; addi sp, sp, 4 ; bnez t1, LABEL_STR 思考题 Rust 和 Go 语言中的 if-else 语法与 C 语言中略有不同，它们都要求两个分支必须用大括号包裹起来，而且条件表达式不需要用括号包裹起来： if 条件表达式 { // 在条件为 true 时执行 } else { // 在条件为 false 时执行 } 请问相比 C 的语法，这两种语言的语法有什么优点？ 总结 本节主要就是引入了跳转，后面 step8 循环语句还会使用。 备注 1. 见思考题 ↩ 2. 如果 LABEL_STR 在当前函数内，j LABEL_STR 就等于 beqz x0, LABEL_STR ↩ "},"docs/step6/manual-parser.html":{"url":"docs/step6/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 增加两种新节点的同时，需要增加 Node 的内容。 struct NodeKind { + ND_IF, + ND_TERN, // :? 运算 } struct Node { + Node* cond; // 储存条件表达式 + Node* then; // 储存条件判断成功时执行的语句（返回的表达式） + Node* else; // 储存条件判断失败时执行的语句（返回的表达式） } 注意，对于 :?运算符，then 和 else 是两个表达式节点， 对于 if 语句，这两个变量是两个语句节点。 解析变化 按照生成式变化改变即可。if 语句示例如下： Node* stmt() { // ... // IF statement if (parse_reserved(\"if\")) { assert(parse_reserved(\"(\")); node = new_node(ND_IF); node->cond = expr(); assert(parse_reserved(\")\")); node->then = stmt(); if(parse_reserved(\"else\")) node->els = stmt(); return node; } // ... } 以后同质化的内容不再展示。 "},"docs/step6/spec.html":{"url":"docs/step6/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step6 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' block_item* '}' type : 'int' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier 注意：if 的 then 分支和 else 分支需要是一个语句（statement）而非声明（declaration）。 例如 if (1) int a; 不是合法的 MiniDecaf 程序。 step6 语义规范 6.1 条件表达式会先对第一个操作数求值，再根据其值选择计算第二个或第三个操作数。当且仅当第一个操作数的值不等于 0，我们会对第二个操作数求值。当且仅当第一个操作数的值等于 0，我们会对第三个操作数求值。当第一个操作数的值为 0 时，条件表达式的求值结果为第二个操作数所求得的值；当第一个操作数的值非 0 时，条件表达式的求值结果为第三个操作数所求得的值。 不论选择第二个操作数或者是第三个操作数去求值，都必须首先计算完第一个操作数，之后才能开始第二个或第三个操作数的求值计算。 6.2 对于 if 语句而言，当控制条件不等于 0 时，会执行第一个子句；当控制条件等于 0 时，如果有 else 分支，就会执行第二个语句，否则整个 if 语句的执行便已经完成。 6.3 如果出现悬吊 else（dangling else），要求 else 优先和最接近的没有匹配 else 的 if 匹配。 例如 if (0) if (0) ; else ; 等价于 if (0) { if (0) ; else; } 而非 if (0) { if (0) ; } else ;。 "},"docs/step7/intro.html":{"url":"docs/step7/intro.html","title":"任务概述","keywords":"","body":"实验指导 step7：作用域和块语句 step7 我们要增加块语句的支持。 虽然块语句语义不难，就是把多个语句组成一个块，每个块都是一个作用域。 随之而来一个问题是：不同变量可以重名了。 重名的情况包括作用域内部声明覆盖（shadowing）外部声明，以及不相交的作用域之间的重名变量。 因此，变量名不能唯一标识变量了，同一个变量名 a 出现在代码不同地方可能标识完全不同的变量。 我们需要进行 名称解析（name resolution），确定 AST 中出现的每个变量名分别对应那个变量。 语法上改动不大 function : type Identifier '(' ')' compound_statement compound_statement : '{' block_item* '}' statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement 语义检查我们也要修改了，只有在同一个作用域里，变量才不能重复声明。 当然，如果变量在使用前还是必须先被声明。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step7/guide.html":{"url":"docs/step7/guide.html","title":"实验指导","keywords":"","body":"step7 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 至于变量相关的语义检查，因为它们和名称解析密切相关，所以可以放到那里面去，参见后文。 手写分析只需根据产生式变化增量变化即可，如果你将名称解析在语法解析中完成，你可能需要按照本章指导调整你的这部分代码，一点提示。 名称解析 step7 我们需要给自己的编译器新增一个阶段：名称解析，它位于语法分析和 IR 生成之间。 这个词广义上的含义就是：把名称关联到对应的实体。例如网络原理中的 DNS 也是名称解析。 我们所谓 “阶段” 只是逻辑上的。就 MiniDecaf 的实现而言，名称解析也可以放在 IR 生成这一步里，在生成 IR 的同时进行名称解析。 名称解析的阶段任务就是把 AST 中出现的每个变量名关联到对应的变量，它需要遍历 AST，所以实现为 AST 上的一个 Visitor 它的输入 是 parser 给的 AST 它的输出 是上面那棵 AST，但 AST 中所有涉及变量名的结点都增加一个属性，表示此处的变量名到底标识哪个变量 这样的结点有：primary、assignment 和 declaration。 代码中，这样的属性可以实现为指向 变量数据结构 的一个指针。 也可以实现为一个从 AST 结点到变量的映射。 下面是一个例子： 考虑我们有一段代码： { int a=0; a= a+1; if (a) { int a=2; return a; } return a; { int b=12; return a +b; } } 显然其中有三个变量，两个的名字是 a 一个的是 b。不妨把这三个变量记为 a0, a1, b0。 名称解析应当发现这点，并且还要把每个变量名关联到变量，所以它提供的信息类似： { int a=0; // a0 a= // a0 a+1; // a0 if (a) { // a0 int a=2; // a1 return a; // a1 } return a; // a0 { int b=12; // b0 return a // a0 +b; // b0 } } 如果按照定义把这个结果画在语法树上，那么大致如（仅示意，省略了一些不重要的中间结点） 用于储存变量信息的 符号表 的结构也需要改进，以支持作用域。具体的，它需要支持 符号表中，区分不同作用域的变量：支持声明覆盖（shadowing)、检查重复声明 离开某作用域时，要把其中的变量从符号表中删除 为此，我们把符号表改造为一个栈。 (对应上面 1.）栈中每个元素都对应一个开作用域，是一个列表，包含该作用域中至今声明过的所有变量。 程序中不同位置的符号表是不同的；某位置的 开作用域（open scope） 指的是包含该位置的所有作用域。 例如上图中 return a+b; 处，有两个开作用域（声明 a0 和 b0 的），而声明 a1 的作用域不是开作用域。 （对应上面 2.) 每进入一个作用域，就压栈一个空列表；离开作用域就弹栈 在符号表中查找变量名，从栈顶往下查找（所以内层声明才能覆盖外层声明）。 另外， 变量偏移量 和 栈帧大小 的计算方法可以做出修改。例如上面的代码中，我们很清楚a1和b0不可能同时有用，所以它们可以使用同一片物理空间来保存，这样可以节约空间。 如果我们还假设偏移量是 -12-4*frameaddr，那变量的 frameaddr 意义需要变化。 为了保证 step5 中叙述的栈帧性质，变量 frameaddr 的含义要改为是 “在此变量刚声明之前，所有开作用域中的变量总数”。 例如上图中，frameaddr(a1) == frameaddr(b0) == frameaddr(a0)+1。 栈帧大小也 FRAMESIZE 也不能等于 8 + 4 * 局部变量个数 了，它应该是 8 + 4 * 最大的frameaddr。 但是，原来的计算方法也并不是不行，我们完全可以让a1和b0使用不同的物理空间来保存，只是会浪费一些空间而已。 依然可以记录曾经出现过的变量的总数，以此为每个变量分配一个独特的地址，完全不考虑作用域的结构。 最后，名称解析 Visitor 需要 维护符号表，进入块语句（compound_statement）时压栈、离开时弹栈 每次遇到变量名（Identifier）时查找符号表，将其关联到具体的变量，或者报错变量未声明 每次遇到声明（declaration），确定 frameaddr、建立变量并插入符号表，或者报错变量重复声明 IR 生成 无须新增 IR 语句。 块语句的 IR 由其中子语句 IR 顺序拼接而成即可。 汇编生成 无须修改。 思考题 请将下述 MiniDecaf 代码中的 ??? 替换为一个 32 位整数，使得程序运行结束后会返回 0。 int main() { int x = ???; if (x) { return x; } else { int x = 2; } return x; } 在实验指导中，我们提到“就 MiniDecaf 而言，名称解析的代码也可以嵌入 IR 生成里”，但不是对于所有语言都可以把名称解析嵌入代码生成。试问被编译的语言有什么特征时，名称解析作为单独的一个阶段在 IR 生成之前执行会更好？ 总结 本节最重要的内容是名称解析。 "},"docs/step7/manual-parser.html":{"url":"docs/step7/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 处理块语句时需要记录块若干条语句的信息，可以对 Node 进行这样的修改: struct Node { + std::list body; } "},"docs/step7/spec.html":{"url":"docs/step7/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step7 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step7 语义规范 7.1 根据其声明的位置，每一个标识符都属于一个作用域。目前我们有两种作用域：文件级和块级。如果是在块中声明，则标识符其声明所属的块的作用域中，例如局部变量；否则标识符在文件级（全局）作用域中，例如全局变量。 7.2 （更新 5.6）如果一个标识符在两个作用域里面，这两个作用域必然是嵌套的，即一个内层作用域完全被另一个外层作用域所覆盖。且在内层作用域中，外层作用域里该标识符所指派（designate）的变量或函数是不可见的。 在初始化表达式中，其正在初始化的变量已被声明，会隐藏（shadow）外层作用域的同名变量，但其值不确定。例如在下面的代码片段中，a + 1 的值是不确定的。 int a = 1; { int a = a + 1; } 7.1 （更新 5.3）对于同一个标识符，在同一个作用域中至多有一个声明。 7.3 （更新 5.4）使用不在当前开作用域中的变量名是不合法的。 "},"docs/step8/intro.html":{"url":"docs/step8/intro.html","title":"任务概述","keywords":"","body":"实验指导 step8：循环语句 step8 我们要增加对循环语句，以及 break/continue 的支持： statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' 循环语句的语义和 C 的也相同，并且我们要检查 break/continue 不能出现在循环外。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step8/guide.html":{"url":"docs/step8/guide.html","title":"实验指导","keywords":"","body":"step8 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 值得一提的是，四种循环大同小异，都可以写成 Loop(pre, cond, body, post)，AST 中可以用一个统一的节点表示。 Loop(pre, cond, body, post) AST 结点表示如下的一个循环 { // pre 里面可能有声明，所以需要这个作用域 pre; // 可能是空、也可能是一个 declaration 或者 expression while (cond) { // 可能是空、也可能是一个 expression body; // body 里的 continue 会跳转到这里 post; // 是一个 expression } // break 跳转到这里 } 手写分析只需根据产生式变化增量变化即可。 名称解析 变量名相关的解析不变，但注意按照语义规范 8.2，for 要自带一个作用域，for 的初始化语句中声明的变量相当于在这个作用域中声明的。 因此 for (int i=0; i 是合法的代码， 这是符合C标准的（不过在C++中这样的代码是不合法的，也许这更加符合你的常识）， 它的名称解析如 for (int i=0; // i0 i 另外，我们需要确定：每个 break 和 continue 跳转到的标号是哪个。 实现很容易，类似符号表栈维护 break 标号栈和 continue 标号栈。 遇到 Loop(...) 就（一）创建这个循环的 break 标号和 continue 标号（以及起始标号）； （二）把两个标号压入各自栈里； （三）离开 Loop 的时候弹栈。 和 step6 一样，各个循环的标号需要唯一，简单地后缀一个计数器即可。 每次遇到 break 语句，其跳转目标就是 break 标号栈的栈顶，如果栈为空就报错。continue 语句类似。 IR 生成 无新增 IR。 这一阶段 Visitor 遍历 AST 时，遇到 Loop(pre, cond, body, post)，生成的 IR 如 pre 的 IR label BEGINLOOP_LABEL：开始下一轮迭代 cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 body 的 IR label CONTINUE_LABEL：continue 跳到这 post 的 IR br BEGINLOOP_LABEL：本轮迭代完成 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 其中 XXX_LABEL 要和上一步名称解析生成的标号名一样。 遇到 break 语句的 AST 结点时，生成一条 br BREAK_LABEL，其中 BREAK_LABEL 是名称解析确定的标号。 汇编生成 不变。 思考题 将循环语句翻译成 IR 有许多可行的翻译方法，例如 while 循环可以有以下两种翻译方式： 第一种（即实验指导中的翻译方式）： label BEGINLOOP_LABEL：开始下一轮迭代 cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 body 的 IR label CONTINUE_LABEL：continue 跳到这 br BEGINLOOP_LABEL：本轮迭代完成 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 第二种： cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 label BEGINLOOP_LABEL：开始下一轮迭代 body 的 IR label CONTINUE_LABEL：continue 跳到这 cond 的 IR bnez BEGINLOOP_LABEL：本轮迭代完成，条件满足时进行下一次迭代 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 从执行的指令的条数这个角度（label 指令不计算在内，假设循环体至少执行了一次），请评价这两种翻译方式哪一种更好？ 总结 step8 相对容易。 "},"docs/step8/spec.html":{"url":"docs/step8/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step8 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step8 语义规范 方便起见，我们称 for 循环括号中的三个表达式/声明自左向右依次为 init、ctrl 和 post。 例如 for (i=0; i 中，i=0 是 init，i 是 ctrl，i=i+1 是 post。 8.1 有三种循环语句：for 循环、while 循环和 do 循环。执行一条循环语句，意味着反复执行一条语句（即循环体），直到其控制表达式等于 0。 8.2 while 循环的控制表达式的求值在循环体的每次执行之前。 8.3 do 循环的控制表达式的求值在循环体的每次执行之后。 8.4 对于 for 循环而言：如果 init 是一个声明，其声明发生在控制表达式的第一次求值之前；如果 init 是一个表达式，其求值会在控制表达式的第一次求值之前。ctrl 即是控制表达式，其求值在循环体的每次执行之前。post 的求值在循环体的每次执行之后。 8.5 for 循环的 init、ctrl 和 post 都可以被省略。省略 ctrl 等价于将其替换为一个非零常数，比如 1。 8.6 循环语句有其自己的作用域，且是它所在的作用域的子集。循环体也有其作用域，且是循环语句的作用域的子集。如果 for 循环的 init 是一条声明，则其所声明的变量所属的作用域是整个 for 循环语句的作用域（包含 init、ctrl、post 和循环体）。 例如，for (int i=0;;i=i+1) { int i=1; return i; } 是合法的代码片段。 8.7 continue 语句和 break 语句要么出现在循环体里，要么其就是循环体。 8.8 执行一条 continue 语句，意味着将程序的执行跳转至该条 continue 语句所在的最小的循环语句的循环体的末尾。 例如，for (int i=0;i 等价于 for (int i=0;i。 8.9 执行一条 break 语句，意味着终止该条 break 语句所在的最小的循环语句的执行。 "},"docs/step9/intro.html":{"url":"docs/step9/intro.html","title":"任务概述","keywords":"","body":"实验指导 step9：函数 step9 开始，我们要支持多函数了。 我们需要支持函数的声明和定义： program : function* function : type Identifier '(' parameter_list ')' (compound_statement | ';') parameter_list : (type Identifier (',' type Identifier)*)? 我们还需要支持函数调用： expression_list : (expression (',' expression)*)? unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' 语义检查部分，我们需要检查函数的重复定义、检查调用函数的实参（argment）和形参（parameter）的个数类型一致。 我们不支持 void 返回值，直接忽略 int 返回值即可。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step9/guide.html":{"url":"docs/step9/guide.html","title":"实验指导","keywords":"","body":"step9 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 如果你是手写分析，参见这里。 名称解析 类似符号表，我们需要一张表维护函数的信息。 当然，函数不会重名，所以不用解析名称。 这张表主要目的是记录函数本身的信息，方便语义检查。 就 step9 而言，这个信息包括 参数个数（step12 开始还需要记录参数和返回值类型）。对应的语义检查：9.4 是否已经有定义，还是只有声明。对应的语义检查：9.2 IR 生成 step9 之前因为只有一个函数，所以一个 MiniDecaf 程序的 IR 就只是一个指令序列。 现在有了函数了，一个 MiniDecaf 程序的 IR 应当包含一系列 IR 函数，源代码中每个函数都对应一个 IR 函数。 而一个 IR 函数 需要包含 函数自身的信息：函数名、需要 prologue 中分配的“栈帧”大小 3 等； 函数体对应的 IR 指令序列。 对于函数声明和定义，IR 生成的 Visitor 遍历 AST 时， 函数声明结点：没有函数体，无须生成任何 IR 函数定义结点：继续遍历子结点，拿到上面的两种信息，然后创建一个 IR 函数 函数调用是一个比较复杂的操作，见 这里。 为了支持它，我们需要引入 call 指令，并且修改 ret 指令让它不要把栈顶返回值弹出。 指令 参数 含义 IR 栈大小变化 call 一个字符串表示函数名 调用作为参数的函数1，调用完后栈顶是 callee 的返回值 增加 12 ret 无参数 （返回值已经在栈顶了）终止当前函数执行，返回 caller 不变 汇编生成 ret 的汇编不变，call 的如下表。 IR 汇编 call FUNC call FUNC，然后有几个参数就执行几次 pop，然后 addi sp, sp, -4 ; sw a0, 0(sp) 我们已经在 IR 处理了传参，所以汇编生成时不用再考虑传参。 如果你采用非标准的调用约定，prologue 和 epilogue 也不用改，也不用处理 caller-save 寄存器。 否则你可能还需要增加 caller/callee-save 寄存器保存与恢复的代码。 总结 引入了概念 调用约定，并且描述了栈帧的变化。 思考题 MiniDecaf 的函数调用时参数求值的顺序是未定义行为。试写出一段 MiniDecaf 代码，使得不同的参数求值顺序会导致不同的返回结果。 备注 1. call 指令不包含准备参数。 ↩ 2. call 的变化是指，整个 callee 执行完成返回 call 指令后，IR 栈大小相对执行 call 前的大小变化。 ↩ 3. 这个栈帧加了引号，因为它没有包含运算栈 ↩ "},"docs/step9/calling.html":{"url":"docs/step9/calling.html","title":"函数调用","keywords":"","body":"函数调用 函数调用是最复杂的一种表达式结构了。 源代码里的一个函数调用，其实包含了下面几个步骤 准备参数，完成传参 （汇编）保存 caller-save 寄存器 真正执行 call 指令（汇编上是 jalr 指令） 执行 call 然后是子函数执行的时间, 直到子函数 ret（汇编上是 jr ra）返回 （汇编）恢复 caller-save 寄存器 拿到返回值，作为函数调用这个表达式的值 这几步操作有时又被称为调用序列（calling sequence） 上面几步都需要我们确定 调用约定（calling convention）： （第 1.、5. 步）参数和返回值都如何准备、该放哪儿？ （第 2.、4. 步）哪些寄存器是 caller-save 的？ （在 prologue/epilogue 中）那些寄存器是 callee-save 的？ 调用约定通常是在汇编层级用到的，汇编语言课上也讲过。 因为汇编语言很底层，没有函数/参数的语言支持，只有标号/地址/寄存器，所以需要规定如何用汇编的语言机制模拟函数调用。 我们为了简单，IR 不提供对函数的语言支持，所以我们同样需要有 IR 的调用约定。 需要注意的是，调用约定只是一种约定，它不唯一。 x86 上常见的就有默认的 cdecl（汇编课讲过）、stdcall、fastcall 等好几种。 只要 caller 和 callee 的调用约定相同，那么函数调用就不会出问题。 RISC-V 的调用约定 32 位 RISC-V 的标准（指 gcc 使用的）的调用约定中，和我们相关的是： caller-save 和 callee-save 寄存器在 \"Unprivileged Spec\" 的 109 页。 返回值（32 位 int）放在 a0 寄存器中 参数（32 位 int）从左到右放在 a0、a1……a7 中。如果还有，则从右往左压栈，第 9 个参数在栈顶。 自己使用 gcc 编译一个有很多参数的函数调用即可验证。 为了简便和方便描述，我们下面使用一种非标准的调用约定。 callee 只需要保存 fp 和 ra，caller 无须保存寄存器 callee 把返回值放在 a0 中，caller 看到返回之后把返回值压入运算栈 参数不用寄存器传递，所有参数从右往左压栈，第 1 个参数在栈顶。 这个调用约定的优点是叙述和实现简单，但不标准。 你当然可以选择实现标准的调用约定，这样你的汇编能够和 gcc 的汇编互相调用，但是难度会大一些。 助教的实现用的也不一定是这个调用约定。 采用这个非标准的调用约定，仿照 step5 我们可以画出函数调用过程中栈帧的变化图。 可见现在栈帧包含四块，从顶向下依次是运算栈、实参、局部变量、fp 和 ra（下图 1.）。 其中还有一个问题就是形参的处理，例如上面 3. 到 4. 过程中，bar 要访问 a，那 a 放在哪儿？ 可以直接使用 foo 栈帧上的实参，那么 a 相对 fp 的偏移量为 0，同理 b 偏移量为 4。 因此 step7 中的偏移量计算方法仅限非参数的局部变量，而第 k>=0 个参数相对于 fp 的偏移量是 4*k。 还有一种方法是把参数当成普通局部变量，在 prologue 中复制到栈帧中局部变量的区域。 IR 的调用约定 对于 IR 类似上面简便的约定： 传参从右到左压栈 返回值放在栈顶 另外，IR 也需要保存返回地址，如果它要作为一门独立的语言，需要被执行的话。 但我们暂时没有这个需求，可以不管它。可以假设 call 指令会把返回地址保存到其他地方，并且同时把当前栈帧设为新函数的。 汇编的 call（就是 jalr）会保存返回地址到 ra，然后 prologue 里会保存 ra 到 callee 栈帧中。 "},"docs/step9/manual-parser.html":{"url":"docs/step9/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 程序定义出现变化： struct Program { - Function* func; + std::list funcs; } 程序解析对应发生变化： Program* parse() { Program* prog = new Program(); while(not_end()) { Function *fn = function(); prog->funcs.push_back(fn); } return prog; } 函数解析需要新增对于函数参数的解析，同时函数定义发生变化。 struct Function { + std::list args; } Function *function() { assert(type()); char *name; parse_ident(name); Function *fn = new Function(name); parse_reserved(\"(\"); + fn->args = func_args(); parse_reserved(\")\"); parse_reserved(\"{\"); while (!parse_reserved(\"}\")) { fn->nodes.push_back(stmt()); } return fn; } 对函数调用的节点定义： struct FuncCall { char* name; std::list args; }; struct Node { + FuncCall* func_call; } 对函数调用的解析，同时完成名称解析和参数检查（目前之要求数量相同）。 Node* primary() { // ... char* name; if (parse_ident(name)) { parse_reserved(\"(\") Node *node = new_node(ND_FUNC_CALL); // func_call() 完成对于 args 的解析，循环解析 expr, `,` 即可 assert(node->func_call = func_call(name)); // 不能调用未声明函数 Function* fn; assert(fn = find_func(node->func_call->name)); // 参数必须相同 assert(fn->args.size() == node->func_call->args.size()); return node; } // ... } 这里没有展示如何与局部变量应用做区分，想想该如何做？ "},"docs/step9/spec.html":{"url":"docs/step9/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step9 语法规范 灰色部分表示相对上一节的修改。 program : function* function : type Identifier '(' parameter_list ')' compound_statement type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier 我们暂不要求支持不包含函数体的函数声明。 step9 语义规范 9.1 在函数调用中，实参和形参的参数个数必须相同，同一位置的参数类型也必须相同。 9.2 在准备函数的调用时，所有的实参会被求值，然后赋给相应位置上的形参。 在函数体中，形参的值可能会被改变，但即便实参是一个可修改的左值，被调用函数中形参的改变也不会影响实参的值。 9.3 函数是可以递归调用的。 9.4 （更新 5.10）执行一条 return 语句，意味着终止当前函数的执行，并将控制权交还给调用当前函数的 caller，语句中的表达式的值会返还给 caller 作为函数调用的表达式的值。一个函数可以有任意多条 return 语句。 9.5 函数的形参可以被视为在函数体的开头被定义（被以实参的值初始化）的局部变量。所有形参均为左值，且不能被在函数体中直接重定义（除非是在一个更小的嵌套的块中）。 例如，int f(int x) { int x; } 不合法，但 int f(int x) { { int x; } } 合法。 9.6 如果一个不是 main 的函数执行到了它的 }，且其返回值被 caller 所使用，则这是一个未定义行为。 对于感兴趣的同学：C 语言中规定只有使用了返回值才是未定义行为，而 C++ 中规定不管返回值有没有被使用，都是未定义行为。 我们没有支持 void 类型，但可以忽略返回值达到类似的效果。 “执行到了 }” 意味着执行时没有通过 return 返回，例如 int f(){if(0) return 0;}。 实现的时候，你可以直接让所有函数都默认返回 0，语义规范说 main 之外的函数没有 return 是未定义行为，未定义行为的意思就是你想怎么处理都可以，所以全部默认返回 0 当然也是可以的，而且更清晰简单。 "},"docs/step10/intro.html":{"url":"docs/step10/intro.html","title":"任务概述","keywords":"","body":"实验指导 step10：全局变量 step10 我们要支持的是全局变量，语法改动非常简单： program : (function | declaration)* 全局变量和局部变量不同，它不是分配在栈上，而是放在某个固定地址，写在汇编的 .bss 段或 .data 段里。 访问它也不能通过 fp 加偏移量，而是需要通过它的符号加载它的地址，通过它的地址访问它。 汇编课上应该讲过，实际中（包括 gcc 和 qemu）使用的可执行文件的格式是 ELF（Executable and Linking Format）。 .text 是其中存放代码的段（section），.bss 和 .data 都是其中存放数据的段，前者零初始化后者须指定初始值。 对有兴趣的同学： 全局变量地址不是被狭义上的编译器（compiler）确定的，也不是被汇编器（assembler）确定的，而是被链接器（linker）或加载器（loader）确定的。 简单的说，狭义上的编译器把源代码变成文本汇编，汇编器把文本汇编给编码到二进制代码，然后通过链接器变成可执行文件，运行时由加载器加载到内存中运行。 当然，广义上的编译器就囊括了这所有阶段。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step10/guide.html":{"url":"docs/step10/guide.html","title":"实验指导","keywords":"","body":"step10 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 如果你是手写分析，参见这里。 名称解析 和局部变量一样，全局变量要放进符号表里，名称解析才能解析到它们。 和 step7 一样，符号表是一个栈，其中每个元素对应一个作用域。 全局变量就放在栈底，它们位于全局作用域；名称分析遍历 AST 过程中，栈底元素一直都在，不会被弹出。 全局变量相关的语义检查有： 初始值只能是整数字面量。 有以下几种可行的实现方法： 直接取得初始值对应源代码的字符串，按整数解析（int(text) 或 Integer.parse(text)）即可。 修改语法，全局变量是一个新的 global_declaration : type Identifier ('=' Integer)? ';'。 判断这个expr节点的具体类型，要求它必须是整数常量，并且获取常量值。各种语言中都有相应的机制，只是语法不太一样。 不能重复声明：step7 已经要求同一作用域中不能重复声明变量了。 IR 生成 局部变量需要通过 frameaddr 访问，但全局变量不行，所以我们引入新的 IR 指令用于加载全局变量的地址 指令 参数 含义 IR 栈大小变化 globaladdr 一个字符串，表示符号名 取得符号名对应的全局变量的地址，压入栈中 增加 1 例如 int a=2; int main(){return a;} 中 main 的 IR 是 globaladdr a ; load ; ret。 并且现在，一个 MiniDecaf 程序的 IR 除了一系列 IR 函数，还要包含一系列 IR 全局变量 了，每个需要记录的信息类似： 大小有多少字节 是否有初始值，初始值是多少 汇编生成 汇编可以直接用 la 加载全局变量地址 IR 汇编 globaladdr SYMBOL addi sp, sp, -4 ; la t1, SYMBOL ; sw t1, 0(sp) 每个全局变量还对应一段汇编，不过这段汇编基本就是一个模板替换，我们直接给出结果。 例如 int compiler = 2020; 放到 .data，其汇编如下，compiler 和 2020 可替换成其他变量名和初始值： .data .globl compiler .align 4 .size compiler, 4 compiler: .word 2020 汇编命令（assembler directive）的标准文档在 这里。 不用深入学习汇编命令，它们不是课程内容。 简要解释一下：.data 表示输出到 data 段；.globl a 定义一个全局符号；.word 后是一个四字节整数，是 a 符号所在内存的初始值。 而 int tsinghua; 放到 .bss 的汇编如下，第一个 4 表示大小，第二个 4 表示对齐要求 .comm tsinghua,4,4 思考题 请给出将全局变量 a 的值读到寄存器 t0 所需的 riscv 指令序列。 总结 我们实验中，全局变量相对简单。 但其实全局变量可以展开讲到 linker 和 loader，可惜我们课容量有限不能讨论。 "},"docs/step10/manual-parser.html":{"url":"docs/step10/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 Program的构成再次发生变化，需要调整相关定义和解析方式，总体难度较小。这里仅作简单提示。 如何区分全局变量和函数？ 根据产生式，二者关键不同在于名称之后是否带一个　(　。 // 实际上这么写肯定不好 bool is_func() { return type() && parse_ident() && parser_reserved(\"(\"); } "},"docs/step10/spec.html":{"url":"docs/step10/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step10 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step10 语义规范 10.1 对于全局变量的初始化，我们仅对初始化表达式是整数字面量的情况做要求（例如 2123），对初始化表达式是非字面量的情况不做任何要求（例如 a 或 f() 或 2+3）。 C 其实也支持非字面量的编译期常量，例如 int a=1+3;。编译器可以计算出 1+3==4 然后让它等价于 int a=4;。 但为了实现简便，我们就不要求支持这点。 C 不允许 int a=f(); 因为 f() 不是编译器常量； 而 C++ 甚至可以支持 int a=f();，其大致实现为 int a=0; 然后在 main 之前执行的初始化函数中 a=f();。 10.2 我们对全局变量的重复声明不做任何要求或限定；但全局变量不能被重复定义，即不能有同名的被初始化的全局变量。 int a; int a=2; int a; int main(){ return a;} 是合法的 C 代码，不过不是合法的 C++ 代码，也许 C++ 的处理方式更符合你的直觉。 为了简单，我们不要求这点。比如对于形如 int a; int a=2; 或 int a; int a; 的代码片段，你可以以任意方式处理。 10.3 如果一个全局变量没有被初始化，我们认为其拥有一个默认初始值 0。 "},"docs/step11/intro.html":{"url":"docs/step11/intro.html","title":"任务概述","keywords":"","body":"实验指导 step11：数组 step11 支持的是数组和指针算术： 语法上没有太大改动， 数组的声明： declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' 数组和指针的下标操作 postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' 指针算术：语法不变，但允许：指针加/减整数、整数加指针、指针减指针了。 step11 难度不大，但有了数组让我们能够写很多有意思的程序了，step11 之前甚至 MiniDecaf 连快速排序都写不了。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step11/guide.html":{"url":"docs/step11/guide.html","title":"实验指导","keywords":"","body":"step11 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 你可能注意到，虽然数组是一种类型，但我们没有把数组放到 type 中，而是只放在 declaration 里。 这一方面是因为我们并不完全支持 C 的数组（例如我们没有指向数组的指针），另一方面 C 语言本身设计就如此。 对有兴趣的同学：C 的这个设计很麻烦…… 你能区分 int*[] 和 int(*)[] 哪个是指针的数组、哪个是数组的指针吗？ 加上函数指针就更麻烦了，例如声明 int (*(*vtable)[])(void*); 中变量 vtable 的类型是 int (*(*)[])(void*)，含义是 “是一个指针，指向一个数组，数组每个元素是函数指针，函数接受一个 void* 参数，函数返回 int”。 当然，实际中我们一般不会写出这样的代码，更好的方法是用 typedef 包装一下，例如上面的会写成 typedef int (*funcptr_t)(void*) ; typedef funcptr_t vtable_t[] ; vtable_t *vtable。 至于为什么 C 声明被设计成这样，有一个说法是设计者希望声明能够体现变量的用法。例如上面 vtable 的用法是 int v= (*(*vtable)[0])(voidptr_expr)，非常类似其声明。 当然这些都和我们 课程无关 ，我们更不用实现它们。 如果你是手写分析，参见这里。 名称解析 引入数组后，变量的大小不一定是 4 了，例如 int a[5][4] 大小是 80。 因此变量的数据结构还需要增加一个 size 属性，并且变量的 frameaddr 不一定连续了（但每个变量所占的一片内存空间一定连续）。 例如，某种实现中 int main(){ int a[2][2]; int b[2]; int c; } 中， a 的 frameaddr 是 0，b 的是 4，c 的是 6。 另外，我们修改了左值的定义 12.9： 12.9 (更新 11.1）表达式是左值的必要条件是它能被下面几条规则构造出来 被声明过的变量，如果声明类型不是数组，那么它是左值； 如果 e 是左值，那么括号括起的 (e) 也是左值； 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值； 下标运算的结果，如果其类型不是数组类型，那么它是左值。 因为本质上，int a; 的 a 的值被存放在内存中，需要一次访存 load 它的frameaddr 才能取得。 而局部变量 int a[2]; 中的 a 是一个编译期就确定的偏移量常数，它的值就是 fp 加上这个偏移量常数，无须访存。 全局变量 int a[2]; 也是类似的。 另外，数组各维长度必须是正整数，别忘实现对应的语义检查。 类型检查 除了 step12 的 IntegerType 和 PointerType， 我们还需要增加数组类型 ArrayType(baseType, length)。 例如 int *a[10][20] 就是 ArrayType(ArrayType(PointerType(IntegerType()), 20), 10)，特别注意 20 和 10 的位置。 当然，就 MiniDecaf 而言，实现中你可以一口气把所有维长度都存起来，变成 ArrayType(baseType, lengthList)，如上就是 ArrayType(PointerType(IntegerType()), [10, 20]) 如step12中所说，你也可以用不那么通用的方法来表示类型。 因为我们不允许指向数组的指针，所以可以用一个(int, 整数列表)的二元组表示step11中任何表达式的类型。 其中int部分表示数组的元素类型，它只可能是int的若干重指针，比如用 0 表示 int，3 表示 int***。 整数列表部分表示数组维度，如果为空，就是一个普通变量，否则就和上面的lengthList的含义一致。 不管你怎么表示类型，类型检查的规则是不会变的，int *a[10][20]可以表示成ArrayType(ArrayType(PointerType(IntegerType()), 20), 10)或者(1, [10, 20])，但是这只是同一个类型的两种的记录方式而已，不会影响到上层的逻辑。 并且相关类型规则是（语义规范 12.12, 12.13） 对于下标操作 e1[e2]，要求 e1 是指针类型或者数组类型，e2 是整数类型；结果类型是指针/数组的基类型。 注意，这里判断不要写 e1.type == PointerType, 而要写 e1.type instanceof PointerType（或者类似的手段）。 可以写 e2.type == IntegerType() 或者 e2.type instanceof IntegerType。 对于加法操作，除了最基础的 int 加法还要支持指针加法：两个操作数中一个是指针、另一个是 int；结果类型和指针操作数的类型一致。 对于减法操作，除了 int 减法还可能有两种情况 指针减整数：左操作数是指针类型、右操作数是 int；结果类型和第一个操作数的类型相同。（当然，MiniDecaf 禁止 int 减指针） 指针减指针：左右操作数是相同的指针类型，结果类型是 int IR 生成 无须新增 IR 指令。 数组声明 无需 IR 上特别处理，只要注意变量大小不一定是 4 即可。 并且，数组中数据的内存空间是连续的，因此无论数组的原型是几维的，都可以看做是一个一维的大数组。 对于一个数组 int a[d1][d2]⋯[dn]\\mathtt{int}~a[d_1][d_2]\\cdots[d_n]int a[d​1​​][d​2​​]⋯[d​n​​]，可看做是 int a′[d1d2⋯dn]\\mathtt{int}~a'[d_1d_2\\cdots d_n]int a​′​​[d​1​​d​2​​⋯d​n​​]。访问 a[i1][i2]⋯[in]a[i_1][i_2]\\cdots[i_n]a[i​1​​][i​2​​]⋯[i​n​​]，就是访问 a′[i1d2d3⋯dn+i2d3d4⋯dn+⋯+in]a'[i_1d_2d_3\\cdots d_n + i_2d_3d_4\\cdots d_n + \\cdots + i_n]a​′​​[i​1​​d​2​​d​3​​⋯d​n​​+i​2​​d​3​​d​4​​⋯d​n​​+⋯+i​n​​]。 例如，对于数组 int a[3][4][5]，有： a[i] 的地址是 a + (i * 4 * 5) * sizeof(int)； a[i][j] 的地址是 a + [(i * 4 * 5) + (j * 5)] * sizeof(int)； a[i][j][k] 的地址是 a + [(i * 4 * 5) + (j * 5) + k] * sizeof(int)。 下标操作 e1[e2] 需要分数组和指针来说，并且需要类型检查阶段所计算出的表达式类型信息。 如果 e1 是数组： 显然，e1[e2] 的地址是 e1 起始地址加上 e2 的值乘以 S，其中 S 为 e1 基类型的大小。 我们约定，任何数组类型类型表达式的 IR 执行后，栈顶正好多出一个元素，其为该数组的起始地址。 因此，为了生成 e1[e2] 的 IR，先生成 e1 的 IR，再生成 e2 的 IR，再生成三条指令：push S ; mul ; add； 这一步生成的是 e1[e2] 的地址，如果 e1[e2] 不是左值也不是数组，还需要一个 load。 例如 int a[10][20];，设 a 的 frameaddr 为 20，则 a 的 IR 如 frameaddr 20。 而 a[2+3] 的 IR 如下（其中 80 == 20 * sizeof(int)） frameaddr 20 push 2 ; push 3 ; add push 80 mul add 而 a[2+3][17] 作为非左值的 IR 如（如果是左值，去掉最后 load 即可） ...（和上面一样） push 17 push 4 mul add load 如果 e1 是指针： 类似上面，e1[e2] 的地址是 e1 的值加上 e2 的值乘以 S，其中 S 为 e1 的基类型的大小。 因此，为了生成 e1[e2] 的 IR，先生成 e1 的 IR（这里 e1 不是左值），然后生成 e2 的 IR，然后还是 push S ; mul ; add ; load。 不过 e1[e2] 可能作为左值，如果作为左值，那么生成地址的 IR 和上面一样，但去掉最后的 load。 指针算术 也分两类 指针加整数：e1 + e2，其中 e1 是指针、e2 是整数。 注意指针加整数的值是：指针的值，加上整数乘以 S，其中 S 为指针基类型的大小 1。 IR 生成类似上面，请自行设计。 例如 int *p;，设 p 的 frameaddr 是 20，那么 p+61 的 IR 如下（注意其中 push 4 ; mul） frameaddr 20 ; load ; push 61 ; push 4 ; mul ; add。 整数加指针、指针减整数类似。 指针减指针：同上，指针数值相减后，要除以基类型的大小。 因此 int *p 那么 (p+10) - (&p[3]) 等于 7。 汇编生成 无需特别修改。 思考题 设有以下几个函数，其中局部变量 a 的起始地址都是 0x1000(4096)，请分别给出每个函数的返回值（用一个常量 minidecaf 表达式表示，例如函数 A 的返回值是 *(int*)(4096 + 23 * 4)）。 int A() { int a[100]; return a[23]; } int B() { int *p = (int*) 4096; return p[23]; } int C() { int a[10][10]; return a[2][3]; } int D() { int *a[10]; return a[2][3]; } int E() { int **p = (int**) 4096; return p[2][3]; } C 语言规范规定，允许局部变量是可变长度的数组（Variable Length Array，VLA），在我们的实验中为了简化，选择不支持它。请你简要回答，如果我们决定支持一维的可变长度的数组(即允许类似 int n = 5; int a[n]; 这种，但仍然不允许类似 int n = ...; int m = ...; int a[n][m]; 这种)，而且要求数组仍然保存在栈上（即不允许用堆上的动态内存申请，如malloc等来实现它），应该在现有的实现基础上做出那些改动？ 提示：不能再像现在这样，在进入函数时统一给局部变量分配内存，在离开函数时统一释放内存。 当同时存在>= 2个可变长度的数组时，至少有一个数组的起始地址不能在编译时决定。 你可以认为可变长度的数组的长度不大于0是未定义行为，不需要处理。 总结 本节内容本身难度不大，但细节很多（尤其注意指针加整数时，整数要乘一个数），也有相当代码量。 备注 1. MiniDecaf 中指针基类型只能是 int、int*、int**……，所以这里 S 只可能等于 4。 ↩ "},"docs/step11/manual-parser.html":{"url":"docs/step11/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 引入了新类型数组，你可以这样定义类型。注意，你可以有自己的定义方式，这种定义稍显复杂。 enum TypeKind { TY_INT, TY_PTR, TY_ARR, }; struct Type { TypeKind kind; // 数组大小可变，其余类型皆为 4 // 数组 size = elem_size * arr_len int size; // 数组元素的类型，可能是另一个数组 Type* base; // 数组长度 int arr_len; // 数组元素大小， elem_size = base->size，可省略 int elem_size; // 数组维度 int arr_dim; }; struct Node { // 用于记录数组被引用时的 index + std::list arr_index; } 声明解析 注意对于类型的解析要分成两部分。 Node* declaration() { Type* ty = type(); char* name; assert(ty && parse_ident(name)); // 这里完成对 index 后缀的解析，最终确定类型 // suffix 消耗若干个 `[` num `]` ty = suffix(ty); // ... return node; } 引用解析 对于 index 后缀的解析比较简单，注意： minidecaf 允许数组和指针两种类型的变量进行 index 运算，但是意义完全不同。 仔细计算最终生成节点的类型。 "},"docs/step11/spec.html":{"url":"docs/step11/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step11 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step11 语义规范 11.1 一个数组类型描述了一组被连续分配在一段内存空间中的对象，所有对象都具有相同的类型（我们称之为元素类型）。数组类型包含两部分：元素类型，和数组的长度（即元素数量）。数组类型的表达式仅能参与下标运算。 11.2 我们仅要求支持固定长度的数组，即在数组的声明中，其长度是一个正整数字面量。 所以，我们不要求支持变长数组 int a[n]; 或不定长数组 int a[];。 11.3 我们不要求支持数组的初始化。 C 中可以写 int a[2]={1, 2}，但简单起见，我们不做要求。 由于我们不要求数组的初始化，根据 5.5，作为局部变量的数组中的元素初始值未定；根据 10.3，作为全局变量的数组中的元素初始值为 0。 11.4 对于下标运算 a[b]，要求 a 是一个数组类型，b 是一个整数类型，a[b] 是 a 中的第 b 个元素（从 0 开始计数）。 11.5 下标运算越界是未定义行为。 即便是类似 int a[4][5]; a[1][7] 这种，同样也是未定义行为。 "},"docs/step12/intro.html":{"url":"docs/step12/intro.html","title":"任务概述","keywords":"","body":"实验指导 step12：指针 step12 支持的是指针： 增加类型：指针类型 type : 'int' | type '*' 引入左值的概念，修改赋值 assignment : conditional | unary '=' expression 支持取地址操作符 & 和解引用操作符 * unary : postfix | ('-'|'~'|'!'|'&'|'*') unary 支持类型转换 unary : ... | '(' type ')' unary step12 相当复杂，需要我们引入类型系统、左值的概念，并且加入类型检查以及一大堆语义检查。 你需要： 首先实现左值分析（无指针的），并通过之前所有测例。 然后搭建类型检查的框架（无指针的），并通过之前所有测例。 最后，加入指针，并且适当修改你的左值分析和类型检查。完整支持本节引入的所有新特性，通过相关测试 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step12/guide.html":{"url":"docs/step12/guide.html","title":"实验指导","keywords":"","body":"step12 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 如果你是手写分析，参见这里。 名称解析 名称解析没有变化。 另外，step12 引入解引用操作符以后，左值的概念更加复杂，因此需要增加 左值分析 1， 排除 1+2=3 或 &(1+2) 这种代码，并且为后续阶段生成左值地址提供信息。 请看左值文档。 左值分析可以放到名称解析中，当然你愿意也可以放到其他阶段或作为一个独立的阶段。 类型检查 step12 开始，要增加一个新阶段：类型检查（type checking）；它在名称解析和 IR 生成之间。 它用于（一）完成和表达式类型相关的一大类语义检查，例如 11.4 和 11.5；（二）计算表达式的类型信息，提供给后续阶段使用。 这一大类的语义检查互相联系很紧密，所以它们被拿出来单独作为一个阶段。 类型检查的阶段文档请看类型检查 当然，指导书上划分的也是逻辑阶段，实现中不必严格遵循。有的助教代码中是 IR 生成和类型检查糅在一起做的。 IR 生成 无须新增 IR 指令。 新语言特性的支持分别需要 对于赋值，和 step5 一样：生成 = 右边的值和左边左值的地址，然后 store。 对于取地址 &，生成其操作数左值的地址作为其值。 解引用 * 的 IR 就是子表达式的 IR 接上一个 load。 类型转换只对类型检查有用，类型转换表达式的 IR 就是被转换的子表达式的 IR。 在实际中，类型转换（cast）可能导致真正的值转换（conversion），例如 (int) 4.5 == 4 就需要生成四舍五入的代码。 汇编生成 无须修改。 思考题 为什么类型检查要放到名称解析之后？ MiniDecaf 中一个值只能有一种类型，但在很多语言中并非如此，请举出一个反例。 在本次实验中我们禁止进行指针的比大小运算。请问如果要实现指针大小比较需要注意什么问题？可以和原来整数比较的方法一样吗？ 总结 本节概念不少，代码也相当多，你需要实现左值分析和类型检查。 备注 1. 这个名字是我们自己取的，但名称解析（name resolution）以及类型检查（type checking）都是约定俗成的专用术语。 ↩ "},"docs/step12/lvalue.html":{"url":"docs/step12/lvalue.html","title":"左值","keywords":"","body":"左值 step5 已经提过，赋值表达式中 = 左边必须是左值（lvalue），不能 1+3 = 5， 但当时我们直接在语法上限定了这个条件，没有深入讨论左值。 而 step12 中 & 的操作数也必须是左值，&(2+3) 是没有意义的， 但语法上已经没有这个的保证了 因此 lvalue 的 l 除了 left，又有人说是 location 的意思。 因为比起“能出现在赋值 = 的左边”，左值更本质的特征是，左值是一个 有地址的值（所以才能 &）。 一些例子如： int a; int* p; a = 1; // a 是左值； 1 不是 *&a = 2; // *&a 是左值； 2, &a 不是 p = &a; // p, a 都是左值； &a 不是 *p = 3+a; // *p 是左值； 3, a, 3+a 都不是 由上容易看出： 左值作为操作数时，进行操作需要的是 它的地址； 例如上面 a=1 不需要读取 a 的值，但需要 a 的地址以便把 1 保存到该地址。 非左值（即“右值”，像几个常量和最后一行的 a），操作需要知道的是 它的值； 例如上面 3+a 需要的是 a 的值（对 a 的地址做 load 操作就能加载到 a 的值）。 一个表达式（例如 a）可能有时是左值有时不是，取决于它出现在哪儿。 接着上面第 3. 点说，一个表达式要是左值，需要满足两个条件： 能利用如下规则（语义规范 11.1）构造出来 被声明过的变量是左值； 如果 e 是左值，那么括号括起的 (e) 也是左值。 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值。 如果程序没有类型错误，则 *e 一定是左值，地址是 e 的值。 出现在需要左值的地方（& 操作数、= 左边） 如果需要左值的地方不是左值（例如 1+2=3），那么就要报错。（语义规范 5.5, 11.3） 和上面说的一样，生成代码的过程中，对于左值要生成它们的地址，右值要生成它们的值。 生成左值地址比较容易： 如果左值是变量，其地址就是变量的地址（一个 frameaddr 或者 globaladdr） 如果左值是解引用得到的 *e，其地址就是 e 的值 （语义规范 11.3）所以 &*e 等价于 e，但它不是左值了 括起的左值 (e) 的地址就是 e 的地址 "},"docs/step12/typeck.html":{"url":"docs/step12/typeck.html","title":"类型检查","keywords":"","body":"类型检查 正如指导书所说，类型检查目的是 完成和表达式类型相关的一大类语义检查，例如 11.4 和 11.5； 计算表达式的类型信息，提供给后续阶段使用。 说类型检查之前，我们先提一下类型。 类型的概念大家都很熟悉了（非形式化地），无非就是一个值的集合； 然后称表达式 e 的类型是 T 当且仅当 e 的值在 T 的集合里。 就 step12 而言，我们只需要在编译器中定义两种类型： 整数 IntegerType()，表示 32 位有符号 int 指针 PointerType(baseType)，表示指向 baseType 的指针 例如 int** 就是 PointerType(PointerType(IntegerType()))。 文档中为了简洁我们会写成前者，但编译器代码中要写后者。 就 step12 而言实现上不需要这么复杂，甚至你可以就用整数表示类型，例如 0 表示 int，3 表示 int***。 一般不推荐这么做，因为这样对于更复杂的语言特性不是很好拓展，例如struct / 函数指针等等的类型。 但是实际上我们最复杂的类型，也只是在step12的基础上加上数组维度，可以用一个(int, 整数列表)的二元组表示step11中任何表达式的类型，所以这也不失为一种可行的做法。 对有兴趣的同学：这里也有一个概念上的区分，“指针类型（PointerType）” 并不是一个 “类型”。 回顾 step1，我们也说过 Integer 不是一个 Token 而是一个 Token 种类（TokenKind）。 同样的，指针类型是类型的类型，每个 PointerType 的实例对象才真正表示一个具体的指针类型。 有一门专门研究类型的理论叫 type theory，其中类型（type）的类型称为 kind，有兴趣的同学可以参考 Types and Programming Languages、Proofs and Types 等书。 在 step11 的某几条类型规则中，其实就蕴涵了上面的思想。 类型检查阶段是由一系列 类型规则 指导进行的，源代码中操作如果需要类型检查，那它需要先声明自己的类型规则。 对于某个操作，其类型规则包含两个部分： 各个源操作数的类型有什么限制； 如果源操作数的类型满足 1.，那么操作的结果（如果有）是什么类型。 一些类型规则的例子如下 加法 + 只能 int 加 int, 结果还是 int。 如果有了指针算术甚至浮点，加法的类型规则会更加复杂。 if 的条件表达式类型必须是 int，没有操作结果。 变量的类型就是它声明给出的类型。 整数字面量的类型就是整数类型。 解引用操作 *e 要求操作数类型 e 是指针类型 T*，结果类型是 T。 指针能执行的操作很有限，见语义规范 11.5 取地址操作符 &e 对源操作数类型没有要求，结果类型是 PointerType(源操作数类型)。 这里假设已经做过左值检查了，另一种选择是把左值检查和类型检查糅在一起。 另外，虽然操作数类型没有要求，但还是要做类型检查，保证操作数内部没有类型错误。 类型转换（cast）对源操作数类型没有要求，结果类型就是转换的目标类型。 函数调用：见语义规范 9.4，结果类型就是函数的返回类型。 类型检查阶段完成后，为了把类型信息传递给后续阶段，AST 中每个表达式结点都要新增一个属性 type 描述它的类型。 不然后续阶段看到 AST 里面的一个“加”，都不知道是整数加、指针算术（step11）还是浮点加，那 IR/汇编 就没法生成了。 我们还是可以使用一个 AST Visitor 实现类型检查，在其中 对于每个操作结点，先对所有子结点类型检查，完成后子结点的 type 就是源操作数的类型。 然后对照这个操作的类型规则，如果源操作数类型不对那么报错，否则计算该结点的 type。 碰到变量声明（包括形参），遍历声明类型子节点，然后设置其变量数据结构的类型。 如果有初始值，对它执行类型检查，如果它的类型和声明的类型不匹配则报错。 "},"docs/step12/manual-parser.html":{"url":"docs/step12/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 新增的两种单目操作和很容易实现，不做赘述。 你需要调整 type()使它能够正确的处理指针类型，一个循环的事，不做赘述。 类型系统 你可以在 parse 阶段一并完成类型检查。 首先，引入类型系统。注意，相关的结构体定义不一定要一样，你可以有自己的定义方式。 enum TypeKind { TY_INT, TY_PTR, }; // 事实上，minidecaf （即便是lab12）不需要这么复杂的类型，你可以仅仅记录指针的重数，请根据自己的理解灵活实现 struct Type { TypeKind kind; // int size; 目前的 minidecaf 中，为一常量 4，lab12 才出现其他长度的类型 // int align; 目前的 minidecaf 中，为一常量 4 Type* base; }; // 注意：Node 的类型的意义是，这个节点所代表的表达式的类型，语句节点没有类型。 struct Node { + Type* ty; // 你可以通过左值计算得到每个节点是不是左值，但真的需要这么复杂吗？ + bool is_lvalue; } // 函数和变量也需要增加类型字段 引入类型比较的函数 bool type_equal(Type*, Type*); 在 parse 的同时计算类型。基础节点（也就是 primary 节点，包含变量、函数调用、数字字面量）返回的类型可以直接确定，其余节点的类型需要根据操作数的类型做计算。比如：如果允许指针加减(这被放在了 lab12 )，那么加法运算的结果可能是整数，也可能是指针，对应节点的类型类似，但是乘法运算一定会返回一个整数。此外还需要在构造节点的同时进行类型检查，具体内容参见这里。 类型计算: Node* factor() { // function call node->ty = fu->ret_ty; // variable node->ty = var->ty; // num node->ty = int_type(); } Node* add() { // 如果允许指针加减，lab11 的加法运算和乘法的类型要求一致，只能计算整数 if(is_integer(node->lexpr) && is_integer(node->rexpr)) { node->ty = int_type(); } } 类型检查： Node* mul() { // 乘法两个操作数必须都是整数 assert(is_integer(node->lexpr) && is_integer(node->rexpr); // 必定产生整数 node->ty = int_type(); } Node* assign() { // 赋值要求双方类型相同 assert(type_equal(node->lexpr, node->rexpr)); // 节点类型就是左操作数或者右操作数的类型 node->ty = node->lexpr->ty; } 类型计算后，你必须保证每一个表达式节点都有正确的类型。类型检查需要在类型出错时报错报错。 此外，对函数的名称解析也需要调整。 左值计算 左值计算可以通过可类型计算相似的方式进行。 强制类型转换 强制类型转换容易与括号表达式（( expr )）相混淆，我们需们需要知道括号后的 token 类型才能作出判断，这里介绍一种作弊的方式：可以不必严格遵循 LL1 的解析方式，我们可以实现一个撤销操作。 void checkout_token(); 功能是与 next_token()相反，这样，我们可以在错误的消耗掉 token 之后回退到之前的状态。 强转可以这样写： Node* cast() { if (parse_reserved(\"(\")) { Type* ty; if(ty = parse_type()) { assert(parse_reserved(\")\")); Node* node = new_cast(unary(), ty); return node; } // 这表明这其实是一个括号表达式，我们应该撤销对于 `(` 的消耗。 // 当然，你也可以在解析 `(` expr `)` 的时候直接跳过对 `(` 的解析。 // 请灵活实现 checkout_token(); } } "},"docs/step12/spec.html":{"url":"docs/step12/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step12 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' | type '*' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!'|'&'|'*') unary | '(' type ')' unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step12 语义规范 11.1 构成左值表达式的必要条件除了能通过 5.5 中两条外新增一条： 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值。 因此 int a; *&a=2; 中 *&a 是左值。 11.2 step12 中类型只有 int 和指针类型。禁止隐式类型转换，但允许显式类型转换，只要不违反其他几条规范。 11.3 & 的操作数必须是左值。 所以 &*e 等价于 e，但它不是左值了 11.4 * 的操作数类型必须是指针类型。 11.5 指针类型的表达式仅能参与如下运算：类型转换、（一元）&、*、（二元）==、!=、=。 指针不得参与乘除模和、一元、比较大小、逻辑运算。step11 会支持算术。 所以 if、条件表达式和循环语句的条件也不能是指针类型的。 11.6 空指针是值为 0 的指针。 因为禁止隐式类型转换，所以空指针字面量必须由 0 显示转换而来，例如 (int*) 0。 判断空指针类似：if (p == (int**)0) ; 或 if ((int)p == 0) ;。 11.7 未对齐的指针是未定义行为。就 MiniDecaf 而言，指针必须对齐到 4 字节边界。 11.8 如果指针类型和被指向的对象的类型不匹配（例如 step11 的数组/指针越界），对这样的指针解引用就是未定义行为。 这样的指针也包含空指针，所以空指针解引用是未定义行为。 所以 int a; int *p = (int*)a; int x=&*p; 没有包含未定义行为，但 int y=*p; 包含了未定义行为。 这里我们其实和 C 不同，C 中只要指针指向的地方的值的类型和指针的不匹配就是未定义行为，但我们只要不解引用都可以。 11.9 条件表达式 : 前后的两个子表达式的类型必须相同，整个条件表达式的类型即为子表达式的类型。 "},"REFERENCE.html":{"url":"REFERENCE.html","title":"参考资料","keywords":"","body":"参考资料 Writing a C Compiler: by Nora Sandler An Incremental Approach to Compiler Construction : by Abdulaziz Ghuloum Monkey: The programming language that lives in books C17 标准草案 N2176（N2176 是 C17 标准正式发布前的最后一版草案，根据 C17 标准的编者之一 Jens Gustedt 的博文，其与 C17 标准相比只有表述上的差异） RISC-V 手册 RISC-V（非官方）汇编指令用法 "}}
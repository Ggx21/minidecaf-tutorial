{"./":{"url":"./","title":"实验简介","keywords":"","body":"MiniDecaf 编译实验 实验概述 MiniDecaf 1 是一个 C 的子集，去掉了include/define等预处理指令，多文件编译支持，以及struct/指针等语言特性。 本学期的编译实验要求同学们通过多次“思考-实现-重新设计”的过程，一步步实现从简单到复杂的 MiniDecaf 语言的完整编译器，能够把 MiniDecaf 代码编译到 RISC-V 汇编代码。进而深入理解编译原理和相关概念，同时具备基本的编译技术开发能力，能够解决编译技术问题。MiniDecaf 编译实验分为多个 stage，每个 stage 包含多个 step，共包含 11 个 step。每个 step 大家都会完成一个可以运行的编译器，把不同的 MiniDecaf 程序代码编译成 RISC-V 汇编代码，可以在 QEMU/SPIKE 硬件模拟器上执行。随着实验内容一步步推进，MiniDecaf 语言将从简单变得复杂。每个步骤都会增加部分语言特性，以及支持相关语言特性的编译器结构或程序（如符号表、数据流分析方法、寄存器分配方法等）。下面是采用 MiniDecaf 语言实现的快速排序程序，与 C 语言相同。为了简化实现，MiniDecaf 不支持以数组作为函数参数，因此快速排序的数组以全局数组的形式给出： int a[1000]; int qsort(int l, int r) { int i = l; int j = r; int p = a[(l+r)/2]; while (i p) j = j - 1; if (i > j) break; int u = a[i]; a[i] = a[j]; a[j] = u; i = i + 1; j = j - 1; } if (i l) qsort(l, j); return 0; } 2021 年秋季学期基本沿用了 2020 年秋季学期《编译原理》课程的语法规范，为降低实验难度，进一步去掉了指针等语言特性。和 2020 年秋季学期课程实验所不同的是，为了贴合课程教学内容，提升训练效果，课程组设计了比较完善的编译器框架，包括词法分析、语法分析、语义分析、中间代码生成、数据流分析、寄存器分配、目标平台汇编代码生成等步骤，并采用 C++ 与 Python 两种语言实现。每个 step 同学们都会面对一个完整的编译器流程，但不必担心，实验开始的几个 step 涉及的编译器框架知识都比较初级，随着课程实验的深入，将会循序渐进地引入各个编译器功能模块，并通过文档对相关技术进行分析介绍，便于同学们实现相关编译功能模块。 实验起点和基本要求 本次实验一共设置 12 个步骤（其中 step0 为环境配置，主要是 RISC-V 工具链和硬件模拟器的的安装与使用，以及学会使用助教提供的自动测试脚本）。后续的 step1-11 我们将由易到难完成 MiniDecaf 语言的所有特性，由于编译器的边界情况很多，因此你只需通过我们提供的正例与负例即可。 我们以 stage 组织和发布实验，各个 stage 组织如下： 第一个编译器（step1）。我们给的实验框架可以通过所有测试用例，你需要做的事情为跟着文档阅读学习实验框架代码。请各位同学注意，stage1 尤为重要，掌握好实验框架是高质量和高效率完成后续实验的保证。 常量表达式（step2-step4）。在这个 stage 中你将实现常量操作（加减乘除模等）。 变量和语句（step5-step6）。在这个 stage 中你将第一次支持变量声明与赋值，以及条件跳转语句。 块语句和循环（step7-step8）。在这个 stage 中你将支持块语句，所谓块语句，就是多个语句组成一个块，每个块都是一个作用域。作为一种特殊的块语句，你也将实现循环操作。 全局变量和函数（step9-step10）。在这个 stage 中你将支持声明全局变量，并且支持函数的声明和调用。 数组（step11）。在这个 stage 中，你将支持数组，包括全局数组和局部数组。 其中，stage1-stage4 为基础关卡，你需要通过它们以拿到一定的分数。stage5-stage6 为升级关卡，如果你学有余力，完成它们可以减少期末考试在总评中所占的比重。 TODO：需要根据教学安排更新比重。 关于文档，我们以 step 组织文档，每个 step 的文档都将以如下形式组织：首先我们会介绍当前 step 需要用到的知识点，其次我们会以一个当前 step 具有代表性的例子介绍它的整个编译流程。在之前 step 中已经介绍的知识点，我们会略过，新的知识点和技术会被详细介绍。 实验提交 TODO: 下面的是 2020 年的实验安排，需更新到 2021 年的版本。 你需要使用 git 对你的实验做版本维护，然后提交到 git.tsinghua.edu.cn。 大家在网络学堂提交帐号名后，助教给每个人会建立一个私有的仓库，作业提交到那个仓库即可。 关于 git 使用，大家也可以在网上查找资料。 每次除了实验代码，你还需要提交 实验报告，其中包括 你的学号姓名 简要叙述，为了完成这个 step 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 晚交扣分规则 是： 晚交 n 天，则扣除 n/15 的分数，扣完为止。例如，晚交三天，那你得分就要折算 80%。 备注 1. 关于名字由来，由于往年的实验叫 Decaf，我们在新的且更简单的语言规范下复用了 Decaf 的编译器框架，所以今年的实验就叫 MiniDecaf 了。 ↩ "},"docs/step0/todo.html":{"url":"docs/step0/todo.html","title":"待完善","keywords":"","body":"还需要完善的地方 [ ] 根据教学安排更新实验占比（README.md）@曾军 [ ] 更新 2021 年实验提交安排，为同学们创建清华 git 仓库（README.md，step0/testing.md）@杨耀良 [ ] 完善实验框架环境配置中各工具安装细节的Mac版本（step0/env.md）@曾军 [ ] 将实验框架放到 github 上（step0/testing.md）@陈之杨@曾军 "},"docs/step0/riscv_env.html":{"url":"docs/step0/riscv_env.html","title":"RISC-V环境配置","keywords":"","body":"RISC-V 环境配置 必做：RISC-V 的 gcc 和 qemu 我们的编译器只生成 RISC-V 汇编，然后再使用 gcc 把 RISC-V 汇编变成 RISC-V 可执行文件，最后用 qemu/spike 等模拟器来运行 RISC-V 可执行文件。 这里的 gcc 和常说的 gcc 不一样。 常说的 gcc 运行在我们的 x86 机器上、把 C 编译到 x86 可执行文件； 而这里的 gcc 虽然也运行在我们的 x86 机器上，却要编译到 RISC-V 可执行文件。 这种“gcc 跑在 x86 却编译出 RISC-V 代码”的操作被称为交叉编译（cross compilation）。 因此我们不能直接使用有些系统自带的 gcc，这种 gcc 生成的可执行程序只能在你本机（x86）上运行。 我们需要下载安装 riscv64-unknown-elf-gcc，用来生成 RISC-V 可执行程序。 我们提供了预编译的 riscv64-unknown-elf-gcc 和 qemu 模拟器，不过只能在 Linux/Mac 下运行，Windows 的同学可以使用 WSL，或者运行一个虚拟机。 命令行基础操作我们就不赘述了，大家可以自己在网上查找资料。 下面是环境配置指南，请阅读自己的系统的那一小节。 你的编译器 gcc qemu/spike C-- 源文件 ------------> RISC-V 汇编 -----> 可执行文件 --------> 输出 Windows 用户环境配置指南 下面描述了 WSL 的一种参考方法。 你还可以开一个 Linux 虚拟机，使用 Virtualbox 或 VMWare 等，然后参考下面 Linux 配置。 Win10 设置 参考 https://blog.csdn.net/daybreak222/article/details/87968078 ，设置“开发者模式”以及“启用子系统功能”。 打开Microsoft Store，搜索Ubuntu，选择ubuntu20.04. 按照下面的 Linux 用户环境配置指南安装 riscv 工具链。 Linux 用户环境配置指南 从网络学堂下载 riscv-prebuilt.tar.gz 压缩包并解压（命令是 tar xzf riscv-prebuilt.tar.gz） 安装工具链 cp riscv-prebuilt/* /usr/ -r 在第 2. 步，你可以选择不安装到系统目录下。相应的，你需要设置环境变量： export PATH=$PATH:/path/to/riscv-prebuilt/bin，把 /path/to 替换为你的解压目录。 把上面这条命令加到你的 ~/.bashrc 文件中，这样不用每次打开终端都要重新设置。 每次改完 ~/.bashrc 你都需要重启终端，以便改动生效。 （如果你不用系统自带的 bash 而是用 zsh 之类的 shell，那加到 ~/.zshrc 等 shell 配置文件里） macOS 用户环境配置指南 从这里下载预编译好的 RISC-V 工具链并解压到你喜欢的目录。 由于 macOS 不支持 QEMU 的用户态模式，我们使用 Spike 模拟器和一个简易内核 riscv-pk 提供用户态程序的运行环境。你可以选择下面两种安装方法中的任意一种： 从网络学堂上下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，不过还需要通过 Homebrew 安装依赖 device tree compiler： $ brew install dtc 通过 Homebrew 安装 Spike（会自动安装 dtc）： $ brew tap riscv/riscv $ brew install riscv-isa-sim 然后从网络学堂上下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，只用里面的 pk。 Homebrew 也提供了 riscv-pk，不过那是 64 位的，而我们需要 32 位的，请使用我们预编译的 riscv-pk 或自行编译。 （可选）设置环境变量，方法与 Linux 一样，见上一节。如果不设置每次使用 gcc 和 spike 时都要输入完整路径。不过对于 pk 设置环境变量不管用，要么把它放到系统目录 /usr/local/bin/pk，要么每次都用完整路径。 测试你 GCC 和 Spike 是否成功安装，详见RISC-V 的工具链使用。 必做：测试你是否正确配置好了环境 创建 test.c 文件，其中写入如下内容 #include int main() { printf(\"Hello world!\\n\"); } 编译 test.c 文件，gcc 应该输出一个可执行文件 a.out。但 a.out 是 RISC-V 可执行文件，所以我们的 X86 计算机无法运行。 $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 test.c $ ls a.out a.out $ ./a.out bash: ./a.out: cannot execute binary file: Exec format error 后面RISC-V 的工具链使用总结了 gcc 和 qemu 在编译实验中可能需要的用法。 使用 qemu 执行 a.out$ qemu-riscv32 a.out Hello world! 备注 1. 开头的 $ 表示接下来是一条命令，记得运行的时候去掉 $。例如，让你运行 $ echo x，那你最终敲到终端里的是 echo x（然后回车）。如果开头没有 $，那么这一行是上一条命令的输出（除非我们特别说明，这一行是你要输入的内容）。 ↩ "},"docs/step0/riscv.html":{"url":"docs/step0/riscv.html","title":"RISC-V 的工具链使用","keywords":"","body":"RISC-V 相关信息 RISC-V 是一个很像 MIPS 的 RISC 指令集架构，编译实验要求你的编译器把 MiniDecaf 程序编译到 RISC-V 汇编。 指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"。 另外这里也有（非官方的）指令用法说明。 不过事实上，很多时候看 gcc 输出的汇编比看什么文档都有用。 RISC-V 工具使用 我们提供预先编译好的 RISC-V 工具，在环境配置中已经叙述了安装和使用方法。 下面汇总一下。 注意，我们虽然是用的工具前缀是 riscv64， 但我们加上参数 -march=rv32im -mabi=ilp32 以后就能编译到 32 位汇编 1。 使用时记得加这个参数，否则默认编译到 64 位汇编。 我们假设你已经正确设置好了环境变量，否则运行 riscv64-unknown-elf-gcc 或 qemu-riscv32 或 spike 时请用完整路径。 gcc 编译 input.c 到汇编 input.s，最高优化等级（否则输出的汇编会很冗长） # input.c 的内容 $ cat input.c int main(){return 233;} # 编译到 input.s $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c # gcc 的编译结果 $ cat input.s .file \"input.c\" .option nopic .attribute arch, \"rv32i2p0_m2p0\" .attribute unaligned_access, 0 .attribute stack_align, 16 .text .section .text.startup,\"ax\",@progbits .align 2 .globl main .type main, @function main: li a0,233 ret .size main, .-main .ident \"GCC: (SiFive GCC 8.3.0-2020.04.0) 8.3.0\" gcc 编译 input.s 到可执行文件 a.out # input.s 的内容，就是上面汇编输出的简化版本 $ cat input.s .text .globl main main: li a0,233 ret # 编译到 a.out $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 input.s # 输出结果，能看到是 32 位的 RISC-V 可执行文件 $ file a.out a.out: ELF 32-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped 【Linux 用户】qemu 运行 a.out，获取返回码 # 运行 a.out $ qemu-riscv32 a.out # $? 是 qemu 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 【macOS 用户】Spike 模拟器运行 a.out，获取返回码 # 运行 a.out # /usr/local/bin/pk 替换为你自己的 pk 路径 $ spike --isa=RV32G /usr/local/bin/pk a.out bbl loader # $? 是 spike 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 1. 这里的 rv32im 表示使用 RV32I 基本指令集，并包含 M 扩展（乘除法）。本实验中我们不需要其他扩展。 ↩ "},"docs/step0/env.html":{"url":"docs/step0/env.html","title":"实验框架环境配置","keywords":"","body":"实验框架环境配置 C++ 实验框架环境配置 关于操作系统，助教推荐使用 Linux 环境（如 Ubuntu，Debain 或 Windows 下的 WSL 等），当然你也可以在类 Unix 系统环境（Mac OS）中进行开发。助教不推荐直接在 Window 中搭建开发环境。对于 C++ 实验框架，你需要安装或保证如下软件满足我们的要求： TODO：详细介绍一下Mac中各种工具安装的细节。 Flex Flex 是一个自动生成词法分析器的工具，它生成的词法分析器可以和 Bison 生成的语法分析器配合使用。我们推荐从 Github 下载安装最新版本(在2021.9.1, 最新版本是2.6.4,不推荐使用低于2.6的版本)。 在ubuntu下，apt-get install flex 安装的flex版本为2.6,是可用的。 Bison Bison是一个自动生成语法分析器的工具,它生成的语法分析器可以和Flex生成的词法分析器配合使用。我们推荐从官网下载安装最新版本（在2021.9.1, 最新版本是3.7.6，不推荐使用低于3.7的版本,如ubuntu apt-get install安装的3.0.4版本是不可用的）。 下载解压tar.gz文件后， 在路径下执行./configure && make && make install, 就应该能正确安装。如果发生失败，就尝试sudo ./configure sudo make, sudo make install, 然后bison --version检查一下版本是否为3.7.6就可以了。 Boehmgc C++ 语言的实验框架中，为了简化内存分配的处理，使用了一个第三方垃圾回收库，简单来说，使用这个垃圾回收库提供垃圾回收功能后，我们在框架里可以new了之后不用delete也不会出问题。 在ubuntu下,通过 apt-get install libgc-dev安装的boehmgc库是可用的。 gcc 助教推荐的 gcc 版本为 8.5.0。 需要注意的是，如果你使用 Mac OS 进行开发，Mac 自带的 g++ 命令极有可能软链接到了 clang，我们的实验框架在某些版本的 clang 下无法编译通过，因此推荐你使用如下方法安装特定版本的 gcc。安装完成之后，你需要使用 gcc-8，g++-8 来调用特定版本的 gcc，g++，同时你需要修改我们提供的 Makefile 中的 CC 与 CXX 选项。 # Mac OS $ brew install gcc@8 # Ubuntu $ sudo apt-get install gcc-8 python 实验框架环境配置 关于操作系统，类似 C++，但由于 python 的跨平台性，理论上也可以在 Windows 下进行开发。但不保证Windows和在线测试环境下程序行为的一致性。由于 python 自带的包管理系统 pip，安装推荐的依赖只需执行如下命令。 $ pip install -r ./requirements.txt python 3.9 框架本身在 python 3.9 下进行开发，使用了 python 3.9 的新特性并仅在这一版本下经过测试。请保证你所使用的 python 版本高于此版本。 argparse 框架使用了 argparse 以处理命令行参数。官方文档中提供了它的教程。 ply ply是一个自动生成词法分析器和语法分析器的工具，其中ply.lex为词法分析相关的模块而ply.yacc为语法分析相关。我们提供了 ply 的文档。 助教推荐使用类似 Miniconda 的系统以最小化出现奇怪依赖问题的风险。助教推荐在项目中使用 type hints，如果你习惯在 vscode 中进行开发的话同时推荐使用 pylance 这一插件。 必做：测试你是否正确配置好了环境 C++ 实验框架 确定各工具的版本 # g++ $ g++-8 -v # Flex $ flex --version # Bison $ bison --version "},"docs/step0/testing.html":{"url":"docs/step0/testing.html","title":"运行实验框架","keywords":"","body":"推荐：运行实验框架 配好环境以后，我们强烈推荐你构建运行我们提供的实验框架初始代码。 接下来我们会用到 git。 git 的安装和使用会在软件工程课上讲述，同学们也自行查阅相关资料，也可以参考这里 。 通过 git clone 把测例和实验框架实现克隆到同一个目录下面。 TODO：框架上传之后更新链接。 C++ 和 Python 框架在同一个仓库的不同分支里面。 按照参考实现的 README 配置好它的环境。 按照测例的 README 运行测试 step1，实验框架给出的初始代码可以通过 step1 的所有测例。 测试运行的 输出结果 大致如下。 $ STEP_UNTIL=1 ./check.sh gcc found qemu found parallel found OK testcases/step1/multi_digit.c OK testcases/step1/newlines.c ...... 其他测试点，太长省略 "},"docs/step0/faq.html":{"url":"docs/step0/faq.html","title":"常见问题","keywords":"","body":"常见问题 Invalid ELF image for this architecture $ qemu-riscv32 a.out a.out: Invalid ELF image for this architecture 解决方法： 注意编译时 gcc 要用 riscv64-unknown-elf-gcc，并且加上 -march=rv32im -mabi=ilp32。 command not found $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c riscv64-unknown-elf-gcc: command not found 或者运行 qemu-riscv32 时提示上面的错误。 解决方法： 你是否按照环境配置中指南配好环境？如果你没有安装到系统目录，是否设置 PATH，并且把 export PATH... 命令放到 ~/.bashrc？ Spike pk 卡死 执行 spike pk 直接卡死，需要按多次 Ctrl-C 后才能退出。 解决方法： 可能是忘加了 --isa=RV32G 选项，在用 64 位的 Spike 跑 32 位 pk。 如果你加了该选项也有这个问题，可能是你安装了 64 位的 pk 然后在用 32 位的 Spike 跑，请使用我们预编译的 32 位 pk。 Spike 运行报错：could not open pk $ spike --isa=RV32G pk libc++abi.dylib: terminating with uncaught exception of type std::runtime_error: could not open pk (did you misspell it? If VCS, did you forget +permissive/+permissive-off?) 解决方法： Spike 找不到 pk，请输入 pk 的完整路径。 Spike 运行报错：assertion failed: IS_ELF32(eh) $ spike --isa=RV32G pk a.out bbl loader ../pk/elf.c:42: assertion failed: IS_ELF32(eh) Power off 解决方法： 你可能编译出了 64 位的 a.out，注意编译时 gcc 要用 riscv64-unknown-elf-gcc，并且加上 -march=rv32im -mabi=ilp32。 Spike 运行报错：Child dtb process failed $ spike --isa=RV32G /usr/local/bin/pk a.out Failed to run dtc: No such file or directory Child dtb process failed 解决方法： 使用 Homebrew 安装 device tree compiler： $ brew install dtc macOS 下找不到 realpath 命令 macOS 下运行 minidecaf-tests 里的 check.sh 报错： ./check.sh: line 25: realpath: command not found ./check.sh: line 26: realpath: command not found ./check.sh: line 30: $asmfile: ambiguous redirect ...... 解决方法： 使用 Homebrew 安装 coreutils： $ brew install coreutils "},"docs/step1/part1.html":{"url":"docs/step1/part1.html","title":"从零开始的 lexer、parser 以及汇编生成","keywords":"","body":"实验指导 step1：词法分析、语法分析、目标代码生成 第一个步骤中，MiniDecaf 语言的程序就只有 main 函数，其中只有一条语句，是一条 return 语句，并且只返回一个整数（非负常量），如 int main() { return 233; }。 第一个步骤，我们的任务是把这样的程序翻译到汇编代码。 不过，比起完成这个任务，更重要的是你能 知道编译器包含哪些阶段，并且搭建起开发的框架 了解基本概念、包括 词法分析、语法分析、语法树、栈式机模型、中间表示 学会开发中使用的工具和设计模式，包括 ANTLR 工具， lalr1 工具，Visitor 模式 等。 根据你选择的语言和实现方式，需要了解的内容可能是不一样的，不是所有内容都需要了解。 step1 的任务很简单，暴力也能做。 但请一步一步按照指导书说的，搭建你的词法语法分析和汇编生成，否则后面你可能需要推翻重写。 词法分析 读内容 *词法分析* MiniDecaf 源文件 --------> 字节流 ----------> Tokens --> ...... --> RISC-V 汇编 词法分析（lexical analysis） 是我们编译器的第一个阶段，实现词法分析的代码称为 lexer ， 也有人叫 scanner 或者 tokenizer。 它的输入 是源程序的字节流 如 \"\\x69\\x6e\\x74\\x20\\x6d\\x61\\x69\\x6e\\x28\\x29\\x7b\\x72\\x65\\x74\\x75\\x72\\x6e\\x20\\x30\\x3b\\x7d\"。 上面的其实就是 \"int main(){return 0;}\"。 它的输出 是一系列 词（token） 组成的流（token stream）1 上面的输入，经过 lexer 以后输出如 [关键字(int)，空白、标识符(main)，左括号，右括号，左花括号，关键字(return)，空白、整数(0)，分号，右花括号]。 如果没有词法分析，编译器看到源代码中的一个字符 '0'，都不知道它是一个整数的一部分、还是一个标识符的一部分，那就没法继续编译了。 为了让 lexer 完成把字节流变成 token 流的工作，我们需要告诉它 有哪几种 token 如上，我们有：关键字，标识符，整数，空白，分号，左右括号花括号这几种 token token 种类和 token 是不一样的。例如 Integer(0) 和 Integer(222) 不是一个 token，但都是一种 token：整数 token。 有些实现把所有关键字都作为一种 token，把关键字 int 和 return 当成 Keyword(int) 和 Keyword(return)，就像上面 Integer(0) 和 Integer(222)。 但也可以把不同关键字作为不同种类的 token，int 是 Int 类型的 token，而 return 是 Return token。 对于每种 token，它能由哪些字节串构成 例如，“整数 token” 的字节串一定是 “包含一个或多个 '0' 到 '9' 之间的字节的字节串”。 词法分析的正经算法会在理论课里讲解，但我们可以用暴力算法实现一个 lexer。 例如我们实现了一个 minilexer（代码）当中， 用一个包含所有 token 种类的列表告诉 lexer 有哪几种 token（上面第 1. 点）， 对每种 token 用正则表达式描述它能被那些字节串构成（上面第 2. 点）。 minilexer 主要目的只是让大家熟悉词法分析的概念和其中涉及到的问题，不用于指导你的实现，在第二小节会给出实现 lexer 的具体指导。 如果你已经比较熟悉词法分析的概念，只是不知道怎么实现，那它对你不会有太大的帮助（但为了回答思考题还是要看）。 细化到代码，Lexer 的构造函数的参数就包含了所有 token 种类。 例如其中的 TokenKind(\"Integer\", f\"{digitChar}+\", ...) 就定义了 Integer 这种 token， 并且要求每个 Integer token 的字符串要能匹配正则表达式 [0-9]+，和上面第 2. 点一样。 你可尝试运行 minilexer，运行结果如下（我们忽略了空白） $ python3 minilexer.py token kind text ----------- ------------------- Int int Identifier main Lparen ( Rparen ) Lbrace { Return return Integer 123 Semicolon ; Rbrace } 本质上，token 是上下文无关语法的终结符，词法分析就是把一个字节串转换成上下文无关语法的 终结符串 的过程。 不过 token 比单纯的终结符多一个属性，就是它的字符串（如 Identifier(main) 的 main），你可以说 token 是有标注的终结符。 语法分析 词法分析 *语法分析* 字节流 ----------> Tokens ----------> 语法树 --> ...... --> RISC-V 汇编 语法分析（syntax analysis） 是紧接着词法分析的第二个阶段，实现语法分析的代码称为 parser 。 它的输入 是 token 流 就是 lexer 的输出，例子上面有 如果输入没有语法错误，那么 它的输出 是一棵 语法树（syntax tree） 比如上面的程序的语法树类似 编译原理的语法树就类似自动机的 语法分析树，不同的是语法树不必表示出实际语法中的全部细节。 例如上图中，几个表示括号的结点在语法树中是可以省略的。 语法分析在词法分析的基础上，又把程序的语法结构展现出来。 有了语法分析，我们才知道了一个 Integer(0) token 到底是 return 的参数、if 的条件还是参与二元运算。 为了完成语法分析，肯定要描述程序语言的语法，我们使用 上下文无关语法 描述 MiniDecaf。 就这一步来说，MiniDecaf 的语法很简单，产生式大致如下，起始符号是 program。 program : function function : type Identifier Lparen Rparen Lbrace statement Rbrace type : Int statement : Return expression Semicolon expression : Integer 一些记号的区别： 形式语言与自动机课上，我们用大写字母表示非终结符，小写字母表示终结符。 这里正好相反，大写字母开头的是终结符，小写字母开头的是非终结符。 并且我们用 : 而不是 -> 隔开产生式左右两边。 同样的，语法分析的正经算法会在课上讲到。 但我们实现了一个暴力算法 miniparser（代码）。 这个暴力算法不是通用的算法，但它足以解析上述语法。 与 minilexer 类似，miniparser 只用于说明概念和问题，不是实现上的指导。 如果你已经比较熟悉语法分析的概念，只是不知道怎么实现，那它对你不会有太大的帮助（但为了回答思考题还是要看）。 你可尝试运行，运行结果如下（下面输出就是语法树的先序遍历） $ python3 miniparser.py program(function(type(Int(int)), Identifier(main), Lparen((), Rparen()), Lbrace({), statement(Return(return), expression(Integer(123)), Semicolon(;)), Rbrace(}))) 前面提到，语法树可以不像语法分析树那样严格。 如果语法树里面抽象掉了程序的部分语法结构，仅保留后续处理实际关心的部分，那样的语法树可以称为 抽象语法树（AST, abstract syntax tree）；而和语法完全对应的树称为 具体语法树。 当然，AST 和语法树的概念没有清楚的界限，它们也常常混用，不必扣概念字眼。 上面 miniparser 的输出就是一棵具体语法树，而它的抽象语法树可能长成下面这样（取决于设计） $ python3 miniparser-ast.py # 假设有个好心人写了 miniparser-ast.py Prog(funcs=[ Func(name=\"main\", type=(\"int\", []), body=[ ReturnStmt(value=Integer(123)) ]) ]) 语义检查 有时我们会用 语法检查 这个词，因为语法分析能发现输入程序的语法错误。 对应语法检查，还有一个词叫 语义检查。 它检查源程序是否满足 语义规范，是否有 语义错误，例如类型错误、使用未定义变量、重复定义等等。 就 step1 来说，我们的语义规范如下。显然，我们要检查的就只是 Integer 字面量没有越界。 1.1. MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2147483648, 2147483647]，补码表示。 1.2. 编译器应当只接受 [0, 2147483647] 范围内的整数（step2 会添加负数支持）。 如果整数超过此范围，编译器应当报错。 1.3. 因为只有一个函数，故函数名必须是 main。 完整的语义规范应包含如下几点。指导书只会包含关键点，避免叙述太冗长。 什么样的代码是 不合法 的。对于不合法的代码，编译器必须报错而不是生成汇编。为了简单起见，我们不会规定和检查具体的报错信息，只是要求必须不能正常生成汇编。 例如 step1 中，如果程序中 int 字面量超过上面的范围，那编译器就应该报错。 如果函数名不是 main，也应该报错。 合法程序中，每个操作的行为应该是什么样的。 例如 return 执行结果是：对操作数求值并作为返回值，然后终止当前函数执行、返回 caller 或完成程序执行。 对于合法程序，你生成的汇编的运行结果须和 gcc 生成的汇编运行结果一致。 什么样的行为是 未定义 的。如果代码在运行时展现未定义行为，编译器不用报错，但它后果是不确定的。 例如有符号整数溢出、数组越界、除以零都是未定义行为。 测例代码不会有未定义行为，不必费心考虑。 语义检查的实现方式很灵活，可以实现成单独的一个阶段，也可以嵌在其他阶段里面。 第一种方式在后面的实验中有，但就 step1 而言，检查 int 范围的工作直接放进 parser 或 lexer 中就行了。 例如我们就把它放到了下一个阶段：目标代码生成里。 目标代码生成 词法分析 语法分析 *目标代码生成* 字节流 ----------> Tokens ----------> 语法树 ----------------> RISC-V 汇编 生成 AST 以后，我们就能够生成汇编了，所以 目标代码生成（target code emission） 是第三也是最后一个步骤，这里目标代码就指 RISC-V 汇编。 它的输入 是一棵 AST 它的输出 是汇编代码 这一步中，为了生成代码，我们只需要 遍历 AST，找到 return 语句对应的 stmt 结点，然后取得 return 的值, 设为 X 2 语义检查，若 X 不在 [0, 2147483647] 中则报错；并且检查函数名是否是 main。 打印一个返回 X 的汇编程序 针对第 1. 点，我们使用一个 Visitor 模式来完成 AST 的遍历。 同样，我们有一个 minivisitor（代码）作为这个阶段的例子。 Visitor 模式比简单的递归函数更强大，用它可以让以后的步骤更方便。 Visitor 模式速成请看 这里 另外，如果你用于实现编译器的语言支持抽象数据类型和模式匹配，那么 Visitor 模式可能用处有限，你可跳过相关教程。 在这样的语言中遍历 AST 是一件非常简单的事情，没有必要额外介绍方法。 你不用 Visitor 模式，表达程序逻辑也不会很麻烦，甚至还可能更清晰。 针对第 2. 点，我们用 (RISC-V) gcc 编译一个 int main(){return 233;} 就能知道这个汇编程序什么样。 gcc 的输出可以简化，去掉一些不必要的汇编指令以后，这个汇编程序长成下面这样。 编译方法请看 工具链使用。 汇编代码中，li 加载常数 X 到 a0 寄存器。RISC-V 约定 a0 保存返回值，之后 ret 就完成了 return X 的工作。 .text .globl main main: li a0,X ret 运行 minivisitor，输出就是模板中的 X 被替换为了一个具体整数 $ python3 minivisitor.py .text .globl main main: li a0,123 ret 至此，我们的编译器就完成了，它由三个阶段构成：词法分析、语法分析、目标代码生成。 每个阶段都有自己的任务，并且阶段和阶段之间的接口很明确：字节流、token 流、AST、汇编代码。 任务 在不同输入上，运行 minilexer, miniparser 和 minivisitor。 浏览它们的代码（不用完全看懂）。 完成实验报告（具体要求请看网络学堂的公告）。 思考题 修改 minilexer 的输入（lexer.setInput 的参数），使得 lex 报错，给出一个简短的例子。 修改 minilexer 的输入，使得 lex 不报错但 parse 报错，给出一个简短的例子。 在 riscv 中，哪个寄存器是用来存储函数返回值的？ 总结 本节引入了很多概念，请仔细消化 Lexer Token Parser 抽象语法树 语义检查 目标代码生成 Visitor 备注 1. 之所以说“流”而不是“列表”，是因为不一定 lexer 一下就把所有的 token 都拿出来，还可以按照后续阶段的需要按需返回 token。 ↩ 2. 当然，就第一个步骤来说，你直接找到 Integer 节点也可以 ↩ "},"docs/step1/part2.html":{"url":"docs/step1/part2.html","title":"词法语法分析工具","keywords":"","body":"实验指导 step1：词法语法分析工具 第一部分中，我们已经自己从零开始暴力实现了一个编译器，但是暴力的 minilexer/miniparser 有几个问题： 运行效率较低，minilexer 比正经 lexer 时间复杂度更高（lexer的耗时可以做到只与输入串长度成正比，而与token种类数无关）； 算法太弱，尤其是 miniparser，处理不了越来越复杂的 MiniDecaf。 接下来我们选择更成熟通用的方法，这里你有两种选择 使用工具辅助完成词法语法分析，而不是完全自己编写：请看下面的【工具概述】； 优点：代码量很少，方便。 缺点：要学工具，不能更深入理解 lexer/parser 底层。 完全自己编写 lexer/parser，请看下面的【手写 lexer 和 parser】。 优点：完整理解 lexer/parser。 缺点：要学算法，代码量更大，而且也不可能理解所有常见的parser算法，只能理解你选择的哪一个。 工具概述 从 minilexer/miniparser 的代码可以看出，lexer 和 parser 包含两部分： 被分析的词法/语法的描述。例如 minilexer 的 TokenKind 列表，以及 miniparser 的 rules 字符串； lexer 和 parser 的驱动代码。例如 lex 和 parse 函数。 使用工具，我们只需要完成第 1. 步，描述被分析的词法或者语法。 然后工具从我们的描述，自动生成 lexer 或者 parser 供你使用，十分方便。 所以这类工具被称为 lexer/parser generator，例子有：C 的 lex/yacc、往届使用的 Java 的 JFlex / Jacc、MashPlant 助教的 re2dfa/lalr1。 对有兴趣的同学：除了这类工具以外，还有一类工具称为 parser combinator，多在函数式语言中使用。 最有名的如 Haskell 的 parsec、scala 的 fastparse，rust 的 nom。课程不涉及其中内容。 下面是助教写的一些工具的速成介绍，你可根据你选择的语言和实现方式，从中选择一个学习使用， 你也可以自己另找其他工具自学使用。 ANTLR ANTLR 支持生成很多语言的代码，它的特点是方便易用人性化，请先仿照官网的 “Quick Start” 安装。 和前面环境配置一样，强烈推荐你把 export CLASSPATH... 和 alias... 那几条命令放进 ~/.bashrc 里。 上面官网截图是 MacOS 的用法，Linux 的用法如下： 上面的 wget 如果有 permission error，请运行 sudo wget ...。curl 也一样。 速成文档在这里。 特别注意：如果输入有错误，ANTLR 的 lexer 和 parser 默认会尝试从错误恢复。 但我们实验要求是：如果输入有错，那编译器应该立马报错退出。 因此我们要设置 ANTLR 的 lexer 和 parser 的错误处理方式，具体可见参考框架中的设置方式（python版、java版）。 lalr1 lalr1是 MashPlant 助教自己编写的 parser generator，它用 Rust 编写，可以生成多种目标语言（目前实现了 Rust, C++, Java）。虽然还不能和那些常用的成熟工具链相比，但也已经在 2019 年的编译原理课程中经受住了考验，可靠性是有一定保证的。 lalr1的使用指导在这里。 手写 lexer 和 parser 手写 lexer: 一种可行的做法是沿用minilexer的做法（虽然它效率低，但是我们对效率也没有要求），依次用所有token种类的正则表达式尝试匹配剩余字符串的开头，选择其中最长的匹配，如果有多个长度相等的匹配，则选择最先出现的。 另一种做法是手动模拟DFA执行的过程，根据当前状态和读入的字符转移到下一个状态。例如在初始状态0看到字符'i'，转移到状态1；接着看到'n'，转移到状态2；接着看到't'，转移到状态3。一部分状态下lexer已经识别出一个token，比如这里的状态3，这时如果看到' '，无法继续转移，那么就成功识别了int这个token。 手写 parser: 参见这里。 任务 二选一 如果你选择使用工具：按照你选择工具所需的格式，编写 step1 的 MiniDecaf 词法语法（可参考本章规范），以利用该工具进行解析。然后，从 AST 生成汇编。 如果你选择不使用工具：实现你自己的 lexer 和 parser，并生成汇编。 "},"docs/step1/part3.html":{"url":"docs/step1/part3.html","title":"使用中间码","keywords":"","body":"实验指导 step1：使用中间码 我们继续改进上一步我们得到的编译器，这次要做的是： 使用中间码让编译器更模块化。 栈机器和中间表示 词法分析 语法分析 IR生成 目标代码生成 字节流 ----------> Tokens ----------> 语法树 --------> *IR* --------------> RISC-V 汇编 中间表示（也称中间代码，intermediate representation / IR）是位于语法树和汇编之间的一种程序表示。 它不像语法树一样保留了那么多源程序的结构，也不至于像汇编一样底层。 我们的实验中，使用简单的栈式机 IR，这里是它的一个详细描述。 容易看出，IR 的好处有如下几点 缩小调试范围，通过把 AST 到汇编的步骤一分为二。 通过观察 IR 是否正确生成就能知道：到底是 IR 生成这一小步有问题，还是 IR 到汇编这一小步有问题。 比起 AST 到汇编当成一整个大步骤，分成两个小步，每步代码更少，更容易调试。 实际中，有了 IR 更容易适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, Decaf, C, Java...）。 不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块： 如果有了 IR，只需要写 N 个 IR 生成和 M 个汇编生成，一共 N + M 个模块： 我们使用的 IR 是栈式机 IR，它生成很简单、翻译到汇编也很简单。 一些助教的实现中显式地有 IR，以及对应的 IR 生成和从 IR 到目标代码这两个阶段；而另一些助教的实现则没有，他们是直接从 AST 生成汇编。 你的实现可以选择这两种方法中的任何一个，不一定非要显式地生成 IR。 指导书中的 IR 主要目的是更清晰地说明，栈机器上有哪些操作。 就算你直接从 AST 生成汇编，你生成的汇编也是栈机器上的操作，这些操作也需要被准确描述。 而 IR 就完成描述栈式机操作的任务。 从 AST 到 IR 词法分析 语法分析 *IR生成* 目标代码生成 字节流 ----------> Tokens ----------> 语法树 ---------> IR ---------------> RISC-V 汇编 显然，这一步的 输入 是 AST， 输出 是一个 IR 1 序列。 例如前面的 int main(){return 0;} 例子，输出如 [push 0, ret] 每步我们只介绍这一步必须用到的 IR 指令，而不是一开始就介绍所有指令。 对于 step1，我们只需要两个 IR 指令：push、ret，如下表。 指令 参数 含义 IR 栈大小变化2 push 一个整数常数 把一个常数压入栈中 增加 1 ret 无参数 弹出栈顶元素，将其作为返回值返回当前函数 减少 1 并且我们有如下的假设： 考虑源代码中某个表达式被翻译成了一系列 IR 指令，那么执行这些 IR 指令后，IR 栈大小必须恰好增加 1，栈顶就是表达式的值。 显然，整数常量作为表达式，它被翻译为 push 指令，满足假设。 执行任何语句对应的 IR 指令序列，执行完成后 IR 栈大小不变。 就 step1 而言，return 语句也满足这条假设。 执行任何 n 元操作之前，栈顶的 n 个元素就是操作数。 n 元操作将这 n 个元素弹出，进行操作，再把结果压回栈中。 由此，step1 中 AST 翻译到 IR 就很简单了，只需要按照如下规则访问 AST 中的节点： 遇到 Integer(X)：生成一条 push X。 遇到 Return expr ;：先生成 expr 对应的 IR，然后生成一条 ret。 IR 翻译到汇编 词法分析 语法分析 IR生成 *目标代码生成* 字节流 ----------> Tokens ----------> 语法树 ---------> IR ---------------> RISC-V 汇编 栈机器 IR 翻译到汇编非常简单，如下表，多条汇编指令用分号隔开： IR 汇编 push X addi sp, sp, -4 ; li t1, X ; sw t1, 0(sp) ret lw a0, 0(sp) ; addi sp, sp, 4 ; jr ra 简要解释：li t1 X 表示加载立即数 X 到寄存器 t1；RISC-V 和 x86 一样栈顶比栈底的地址低，所以压栈 4 字节是栈指针 sp 减 4。 （RISC-V 的栈顶指针是 sp，类似 MIPS 的 $sp 和 x86 的 %esp 或 %rsp。） a0 存放返回值，ra 存了调用者地址，jr ra 就是子函数返回。 t1 没有什么特殊的含义，只是用来临时存放数据，你可以换成 t0 / t2 / s1 等。 但不要用 s0，因为它保存了栈帧基地址（同 %ebp 和 $fp），后面要用到。 IR 栈的每个元素都是 32 位整数，所以 push 使得 IR 栈大小加 1 在我们这里就体现为 sp 减 4。 完成后，你对于 int main(){return 0;} 应该生成如下汇编 .text .globl main main: addi sp, sp, -4 li t1, 233 sw t1, 0(sp) lw a0, 0(sp) addi sp, sp, 4 jr ra 任务 （可选，推荐）改进你上一步的代码，先生成 IR，再从 IR 生成汇编。 （和 1. 二选一）改进你上一步的代码，用栈机器的思路直接从 AST 生成汇编。 总结 我们引入 IR 来说明栈机器上能执行那些操作，并用 IR 把目标代码生成阶段一分为二。 备注 1. 实际上 push 和 ret 是 IR 的 指令。我们为了简便，有时直接用 IR 代指 IR 指令。 ↩ 2. 注意区分 IR 栈和汇编中的栈。IR 的栈中包含的元素是整数，IR 栈的大小指栈中有多少个整数。对于 IR 的栈不存在“字节”这一概念。 ↩ "},"docs/step1/antlr.html":{"url":"docs/step1/antlr.html","title":"ANTLR 使用","keywords":"","body":"ANTLR 使用——以表达式语法为例 使用 ANTLR 工具，我们只需要写出词法和语法分析的 规范（specification）， 然后它会帮我们生成 lexer 和 parser 乃至 visitor，非常方便。 我们用一个简单的表达式语法 1 来介绍 ANTLR，表达式由一系列整数通过加减乘除以及括号构成，例如 (1+3)*4-3-3。 对于 ANTLR，词法和语法分析的规范都写在 .g4 2 文件中，例如我们的表达式的规范是文法: ExprLex.g4和语法: Expr.g4。 无论是词法规范还是语法规范，它们的规范文件结构是一样的，如下。 规范文件中，// 表示注释，规范是大小写敏感的，字符串常量用单引号括起。 开头声明 规范名，需要和文件名一致： // [ExprLex.g4] 词法规范，用 lexer grammar 标识，行尾有分号。 lexer grammar ExprLex; // [Expr.g4] 语法规范，用 grammar 标识，行尾有分号。 grammar Expr; 然后可能有一些 规范自身的设置，见后面 “语法规范” 然后是 一系列规则，规则类似上下文无关语法的产生式。 每条规则包含左右两边，用冒号隔开， 左边 是一个符号，可以由 右边 规约而来。 符号分为 终结符 和 非终结符 ，终结符用大写字母打头，非终结符用小写字母。 类似产生式，如果多条规则的左边相同，它们可以合并写在一起，它们的右手边用竖线隔开。 // [ExprLex.g4] 词法规则，规则末尾有分号。 Integer: [0-9]+; // [Expr.g4] 语法规则，规则末尾有分号 atom : '(' expr ')' // 一个括号括起来的表达式，它可以规约到 atom | Integer // 整数 token 可以规约到 atom ; 词法规范 词法规范描述了 lexer 应该怎么生成，显然词法规范中规则的左边只能是终结符。 除了上面所说的，词法规范还有一点是：规则的右手边是一个正则表达式。 详细用法在这里，一些常见用法如下： // 1. 为了匹配字符串常量，用单引号把它括起来 Lparen: '('; // 2. [0-9] 匹配 (char)'0' 到 (char)'9' 之间任何一个字符，类似其他 regex 的 \\d 或者 [[:digit:]] // 3. 加号 + 表示它前面的片段可以匹配一次或多次，类似有 * 的零次或多次，? 的零次或一次。 // 它们都是贪婪的，会匹配尽量多的次数。和其他 regex 一样，片段可以用 ( ) 分组。 Integer: [0-9]+; // 4. fragment 表示 WhitespaceChar 本身不是一个符号，它只是一个 regex 的片段，lexer 不会产生它的 token。 // 它和 minilexer 中的 whitespaceChar 是一样的。 // 5. [ \\t\\n\\r] 匹配一个空格 (ascii 码 0x20)，或者一个制表符 (0x9)，或者一个换行符 (0xa) 或者一个回车 (0xd) fragment WhitespaceChar: [ \\t\\n\\r]; // 6. Whitespace 匹配输入中的空白。类似 minilexer，\"-> skip\" 表示忽略此终结符，也就是匹配以后不产生对应的 token。 Whitespace: WhitespaceChar+ -> skip; 语法规范 语法规范描述了 parser 应该怎么生成。除了上面说的，还需注意： parser 依赖于 lexer，所以语法规范中需要 导入词法规范 // 导入词法规范 import ExprLex; 其实 ANTLR 不要求你分开 lexer 和 parser，你可以直接把 import 语句换成 ExprLex 里面的所有规则， 效果是一样的。 但分开 lexer 和 parser 更干净，并且也方便 lexer 复用。 各种语言虽然语法差别很大，词法（空白、整数、标识符、标点符号等）却没太大差别。 parser 规则的右手边除了符号以外，还可以有 字符串常量。 如果它能被规约到词法规范里某个符号，那它就等价于那个符号； 否则 ANTLR 内部会生成一个临时终结符 T__xxx，它的规则的右边是那个字符串常量。 mulOp : '*' | '/' ; // 等价于 mulOp : Mul | Div ; 你可以手动给 规则命名。 在生成的 AST 里，atom 对应的结点会被分为两类：atomParen 和 atomInteger， 它们拥有的字段不同，也对应不同的 visit 函数。 atom : '(' expr ')' # atomParen | Integer # atomInteger ; 规则其实是用 EBNF (extended Barkus-Naur form) 记号书写的，EBNF 也是描述上下文无关语法的一种方式。 相对普通的上下文无关语法记号，EBNF 允许你在规则内部使用 | 描述选择、* 或 ? 或 + 描述重复，(和) 分组 3。 例如下面的用法： add // 1. 使用括号分组，分组内部使用 | 描述选择 // 2. 和 EBNF 无关，但 op 是给这个符号的命名，然后 add 的 AST 结点会有一个 op 字段。 : add op=(Add|Sub) mul | mul ; mul // 3. 使用 * 描述零次或多次的重复。+ 和 ? 类似。 : atom (mul atom)* ; 关于 EBNF，再举一个例子：描述零个或多个用逗号隔开的 expr 列表，下面两种写法是等价的，但 EBNF 记号更简短。 // 传统写法 exprList : # emptyExprList | exprList2 # nonemptyExprList ; exprList2 : expr | expr ',' exprList2 ; // EBNF 写法 exprList : (expr (',' expr)*)? ; 运行 ANTLR 安装 ANTLR，设置 CLASSPATH 环境变量，配置 antlr4 和 grun 的 alias 后，运行以下命令 4： $ antlr4 Expr.g4 -visitor # 会自动拉取 import 的 ExprLex.g4。visitor 见后面一小节。 $ ls ExprLexer.java ExprParser.java # 默认生成 Java 的 lexer 和 parser，其他文件不用管 ExprLexer.java ExprParser.java $ javac *.java $ echo \"(1+3)*4-3-3\" > input # 输入文件内容是 (1+3)*4-3-3 $ grun Expr expr -gui input # 输出如下图 你可以尝试把最后一步的 -gui 换成 -tokens、-tree 看看。 接下来，我们给出示例代码，叙述如何使用生成的 lexer 和 parser。 Main.java 是 Java 的示例代码。做完上面步骤后，运行 Main： $ java Main main.py 是 Python 的示例代码。为了运行它，除了安装 ANTLR 你还需要安装 Python 的 ANTLR API，见这里。运行方法如下 $ antlr4 Expr.g4 -Dlanguage=Python3 $ ls ExprParser.py ExprLexer.py # 生成了 Python 的 lexer 和 parser ExprLexer.py ExprParser.py $ python3 main.py main.cpp 是 C++ 的示例代码。运行方法如下 $ antlr4 Expr.g4 -Dlanguage=Cpp $ ls ExprParser.cpp ExprLexer.cpp # 生成了 C++ 的 lexer 和 parser ExprLexer.cpp ExprParser.cpp $ g++ main.cpp ExprLexer.cpp ExprParser.cpp 你的antlr路径/antlr4-cpp-runtime/dist/libantlr4-runtime.a -I 你的antlr路径/antlr4-cpp-runtime/runtime/src -o main $ ./main 最后请你自行确认，对于不合法的输入（例如 1+2+），运行示例代码会发生什么。 Visitor 的使用 ANTLR 默认生成 listener，它允许你在遍历 AST 过程进入结点和离开结点的时候运行一些代码，但我们不用 listener，我们使用 visitor。 首先用参数 -visitor 告诉 ANTLR 生成 visitor 代码。 $ antlr4 Expr.g4 -visitor $ javac *.java visitor 代码在 ExprVisitor.java 和 ExprBaseVisitor.java 中。 前者定义接口，后者是默认实现：只遍历、不做其他事。 public class ExprBaseVisitor extends AbstractParseTreeVisitor implements ExprVisitor { @Override public T visitExpr(ExprParser.ExprContext ctx) { return visitChildren(ctx); } // ... } 从上可以看出，ANTLR 的 visitor 和我们的基本一致： visit 函数返回值的类型是 T 他所谓 context 就是 AST 的结点，每个 context 也有一个 accept 函数接受 visitor 但他的 visitor 还自带一个方法 visitChildren：遍历所有子结点。返回最后一个子结点的返回值。 ANTLR 生成的 python visitor 也差不多 $ antlr4 Expr.g4 -visitor -Dlanguage=Python3 visitor 在 ExprVisitor.py 里。 # ExprVisitor.py class ExprVisitor(ParseTreeVisitor): def visitExpr(self, ctx:ExprParser.ExprContext): return self.visitChildren(ctx) # ... MainEval.java 和 maineval.py 通过表达式求值展现了 visitor 的用法，如上编译后如下运行即可。 输出的 10 就等于 (1+3)*4-3-3。 $ python3 maineval.py 产生式动作 除 Visitor 之外，你也可以通过产生式动作使用 ANTLR。在这两种方式中选择一种即可。 若要使用产生式动作，你需要在产生式下方添加一对大括号，并在大括号里用你选择的编程语言编写动作。以 ANTLR for C++ 为例，产生式动作可以是： atom : '(' expr ')' # atomParen { std::cout 按下述参数告诉 ANTLR 既不用生成 Visitor 也不用生成 Listener。编译运行后，上述代码会在解析括号时输出\"parenthese\"，在解析整数时输出\"integer\"。 $ antlr4 Expr.g4 -no-listener -no-visitor 当然，仅仅输出常量字符串当然是不够的，我们还可以通过 $符号名.text 获得相关符号对应的字符串，例如： atom : '(' expr ')' # atomParen { std::cout 当一个产生式里有两个相同符号时，可以通过别名指定其中之一，例如： expr : lhs=expr '+' rhs=expr { std::cout 为了生成 AST，我们还可以给符号添加返回值。例如，我们定义类 AddNode 表示 AST 中的加法结点，它是 ExprNode 的子类，并具有一个通过左右子结点构造的构造器。我们给 expr 符号添加一个 ExprNode* 类型的返回值。在产生式中获取子符号的返回值，并以此生成当前符号的返回值，那么动作可以写作： expr [returns ExprNode *node] : lhs=expr '+' rhs=expr { $node = new AddNode($lhs.node, $rhs.node); } ; 为了使用你自己定义的 AddNode 结点，你可能还需要调用一些写在别的文件里面的代码，例如通过 C/C++ 中的 #include。在 ANTLR4 for C++ 中，这是通过在 Parser 的 .g4 文件头部添加 @parser::postinclude { #include \"你自己的头文件\" } 块来实现的，ANTLR4 对其它语言支持中可能有不同的使用方法。 最后，我们可以在主程序中获取根节点的返回值。例如： auto tree = parser.expr(); // 取得一棵以 expr 为根的 AST auto node = tree->node; // 根符号的返回值 常见问题 javac 报错一堆 cannot find symbol 没有设置 CLASSPATH，按官网 Quick Start 重新配置。 特别注意 CLASSPATH 最开始有个 .:，表示当前目录也是 classpath。 grun 报错 Can't load Expr as lexer or parser 你 antlr4 以后没有编译 java 文件 我的输入是 1+2 ((( 它竟然不报错 ANTLR 不强制消耗整个输入，所以 parser 做完 1+2 就停了。 可以把 expr: add; 改成 expr: add EOF; antlr4 报错 error(31): ANTLR cannot generate python3 code as of version 4.8 -Dlanguage=Python3 的 P 要大写 备注 1. step1 的 MiniDecaf 语法太简单，不能体现很多 ANTLR 的特性。 ↩ 2. g 是 grammar，4 是 ANTLR 的版本号 4。 ↩ 3. EBNF 本身又有很多记号，有的使用 { ... } 表示重复。我们描述的是 ANTLR 的 EBNF 记号。 ↩ 4. 命令从 https://www.antlr.org/ 中 Samples 的内容修改而来 ↩ "},"docs/step1/visitor.html":{"url":"docs/step1/visitor.html","title":"Visitor 模式","keywords":"","body":"Visitor 模式速成 编译器的构造中会使用到很多设计模式，Visitor 模式就是常见的一种。 基础的设计模式都在 OOP 课程中覆盖，这里重提一下 Visitor 模式，顺带介绍一些参考代码用到的 python 技巧。 我们知道，编译器里有很多的树状结构。 最典型的就是，源程序通过上下文无关文法解析后，得到的语法分析树。 Visitor 模式的目的，就是遍历这些树状结构，本质就是一个 DFS 遍历。 下面通过一个例子说明 Visitor 模式。 表达式语法、语法树定义 我们有一个很简单的表达式文法，终结符包括整数和加减乘除模操作符，起始符号是 expr，大致如下 expr -> int | binary int -> Integer binary -> expr '+' expr | expr '-' expr | expr '*' expr | expr '/' expr | expr '%' expr 这个文法有二义性，同样的字符串可能有多个语法分析树。 不过解析字符串、生成语法分析树不是 Visitor 模式的工作。 Visitor 模式只考虑某个确定的语法分析树。 如下面是 20-13*3 的一棵语法分析树 我们在代码里这样定义这个语法分析树（python>=3.6）： class Node: pass class IntNode(Node): def __init__(self, v:int): # 类型标注是给人看的，python 不检查 self.v = v def __str__(self): return f\"({self.v})\" # f-string 特性 class BinopNode(Node): _legalOps = { *\"+-*/%\" } # 使用 unpacking operator，等价于 set('+', '-', '*', '/', '%') def __init__(self, op:str, lc:Node, rc:Node): assert op in BinopNode._legalOps self.op, self.lc, self.rc = op, lc, rc def __str__(self): return f\"({self.lc} {self.op} {self.rc})\" # 我们通过某种手段，得到了这么一个语法分析树 expr1 = BinopNode('*', BinopNode('-', IntNode(20), IntNode(13)), IntNode(3)) print(expr1) # (((20) - (13)) * (3)) 我们忽略了 Expr，不过显然这无伤大雅。 表达式求值 显然，每个语法分析树都对应一个（加好括号）的表达式，比如上面的树就对应 (20-13)*3。 那么我们考虑一个问题：如何对这个表达式求值？ 当然，我们可以让 python 帮我们做 print(eval(str(expr1), {}, {}))， 不过我们下面会用 Visitor 模式实现表达式求值。 写 Visitor 之前，我们看自己实现表达式求值的最简单的方法，一个递归遍历： def dfs(node:Node): if isinstance(node, IntNode): return node.v if isinstance(node, BinopNode): lhs = dfs(node.lc) rhs = dfs(node.rc) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs print(dfs(expr1)) # 21 dfs 函数接受一个结点，然后对这个结点代表的子树进行求值，返回求值结果。 容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的求值逻辑。 那么我们把这些求值逻辑封装到一个类里面，就得到了一个最简单的 Visitor。 class EvaluationVisitor: def visit(self, node:Node): if isinstance(node, IntNode): return self.visitIntNode(node) if isinstance(node, BinopNode): return self.visitBinopNode(node) def visitIntNode(self, node:IntNode): return node.v def visitBinopNode(self, node:BinopNode): # 不确定子结点的类型，所以只能调用 visit 而非 visitIntNode 或者 visitBinopNode lhs = self.visit(node.lc) rhs = self.visit(node.rc) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs print(EvaluationVisitor().visit(expr1)) # 21 上面就是 Visitor 的核心思想，实际使用中我们一般会有两点改进 不使用 isinstance 来判断结点类型，而是调用结点自身的一个 accept 函数 把几个 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口 改进后的 Visitor 如下。 class Node: def accept(self, visitor): pass class IntNode(Node): # ... 同上 def accept(self, visitor): return visitor.visitIntNode(self) class BinopNode(Node): # ... 同上 def accept(self, visitor): return visitor.visitBinopNode(self) class Visitor: # 默认行为是遍历一遍，啥也不做，这样比较方便 def visitIntNode(self, node:IntNode): pass def visitBinopNode(self, node:BinopNode): node.lc.accept(self) node.rc.accept(self) class EvaluationVisitor(Visitor): def visitIntNode(self, node:IntNode): # ... 同上 def visitBinopNode(self, node:BinopNode): lhs = node.lc.accept(self) rhs = node.rc.accept(self) # ... 同上 总结 从上面可以看到，Visitor 模式的要素有 被访问的对象。例如上面的 Node。 Visitor 封装的 visitXXX，表示对上述对象实施的操作。例如 EvaluationVisitor。 每种被访问的对象在自己的定义中都有一个 accept 函数，并且在 Visitor 里面也对应一个 visitXXX 函数。 有状态的 Visitor subexpr = BinopNode('-', IntNode(20), IntNode(13)) expr1 = BinopNode('*', subexpr, IntNode(3)) 显然，表达式求值的过程中，所有子表达式也都会被求值。 如上，求值 expr1 的过程中，subexpr 也也会被求值。 我们想把子表达式的值记录下来，以后直接使用，就不需要对子表达式重新求值了。 为了实现这点，还是使用上面的 EvaluationVisitor，但我们用一个字典 Node -> int 记录求值结果，并且把字典作为 Visitor 的状态。 class EvaluationVisitor2(Visitor): def __init__(self): self.value = {} # Node -> int 每次 EvaluationVisitor2.visitXXX(self, node) 返回的时候，我们都记录一下 self.value[node] = value，其中 value 是返回值。 我们用一个函数修饰器来完成记录的动作，如下 class EvaluationVisitor2(Visitor): def __init__(self): self.value = {} # Node -> int def SaveValue(visit): # decorator def decoratedVisit(self, node): value = visit(self, node) self.value[node] = value return value return decoratedVisit @SaveValue def visitIntNode(self, node:IntNode): return node.v @SaveValue def visitBinopNode(self, node:BinopNode): lhs = node.lc.accept(self) rhs = node.rc.accept(self) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs subexpr = BinopNode('-', IntNode(20), IntNode(13)) expr1 = BinopNode('*', subexpr, IntNode(3)) visitor = EvaluationVisitor2() expr1.accept(visitor) print(visitor.value[subexpr]) # 7 print(visitor.value[expr1]) # 21 "},"docs/step1/ir.html":{"url":"docs/step1/ir.html","title":"IR 简明介绍","keywords":"","body":"中间代码 中间代码(也称中间表示，Intermediate Representation, IR)是表示程序结构的一种方式，在后续的实验指导中，我们会先介绍怎么由AST生成IR，再介绍怎么由IR生成汇编代码。尽管直接由AST生成汇编代码在我们的实验中也是完全可行的，我们也不强求你使用IR，但是保留这个中间步骤更加符合真实的编译器的工作流程，也能让你的程序结构更加清晰。 一般真实的编译器都有IR这个中间步骤，这是因为IR一般比AST更加接近汇编，同时仍然保存了一些程序中的高级信息，更加适合进行各种优化。IR有很多种类，包括三地址码(Three Address Code, TAC)，静态单赋值形式(Static Single Assignment Form, SSA)，基于栈的IR，等等。如果你感兴趣的话可以自行查阅了解，这里不做要求。 我们的实验指导选择使用基于栈的IR。这种IR的最大特点是中间代码生成和汇编代码生成(不追求性能的话)非常容易编写，但是一般实际的编译器都不会使用它，因为它并不适合进行优化1，这样其实也就失去了IR存在的根本意义之一了。尽管如此，我们的指导还是选择使用基于栈的IR，主要目的是希望体现IR这个结构在实际的编译器中的地位，尽量让大家体会感受编译器的工作流程，只是限于课程的工作量的限制还是没法和实际的编译器做到真正的一致。 基于栈的IR顾名思义需要维护一个运算栈，它最主要的特点在于它的运算指令，例如加法和减法指令这些，是没有显式的操作数的。例如在编程语言中常常会写a = b + c，这里的b和c就是加法操作的操作数，而基于栈的IR中则不存在这样的结构，相当于只用一个加号来表示加法，不给出这个加法的操作数。这样的的运算指令的语义都是从这个运算栈的顶部弹出操作数，进行运算后再把结果压回栈中。 例子：一加到一百 在之后的每个step中，我们都会介绍(我们推荐的)加入IR的新指令。尽管如此，这里为了给大家留下一些直观的印象，还是先定义一套简单的基于栈的IR，并且用它表示一个简单的例子：计算一加到一百的和。 定义如下指令： PUSH x: 往运算栈中压入常数x LOAD var: 将变量var的值读出，压入栈中 STORE var: 从栈顶弹出一个值，写入变量var LABEL l: 定义一个名为l的标号 BZ l: 从栈顶弹出一个值，如果该值等于0，则跳转到标号l执行，否则继续执行下一条指令 B l: 无条件跳转到标号l执行 CMP_LE/ADD: 两条二元运算指令，从栈上依次弹出两个值，分别作为右操作数和左操作数，执行整数二元运算/+，将结果压入栈中 有几点可能是比较容易引起疑惑的，这里简单解释一下： 很多指令(其实是除了CMP_LE/ADD之外的所有指令)都有额外的参数，看起来不符合上面说的\"运算指令没有显式的操作数\"的特点。可以理解成额外参数和操作数是不一样的，前者是静态确定的，例如LOAD var每次执行，读取的都是同一个变量的值；后者是动态确定的，例如ADD每次执行，弹出的栈上的两个值都可能是不一样的 上面提到了\"变量\"的概念，变量是保存在哪里的呢？假如要把这个IR最终翻译成汇编，运算栈显然会用栈来实现，而局部变量其实也只能保存在栈上，虽然保存在很接近的物理区域，但是它们逻辑上并不是运算栈的一部分，对局部变量的写入不应该影响到运算栈，在运算栈上进行的弹栈/压栈操作也不应该影响到局部变量。 上面提到的var，l这样的名字，实际实现的时候可以选择用整数来表示，而下面的程序中为了清晰起见，还是用人可读的名字来表示。 下面我们用这个IR来表示如下的C程序： int sum = 0; int i = 1; while (i 转化的结果如下(#后的是注释)： PUSH 0 STORE sum # int sum = 0; PUSH 1 STORE i # int i = 0; LABEL loop LOAD i PUSH 100 CMP_LE # 计算i 我们有一个 ir.py（代码）能运行上面程序，结果的确是 1+2+...+100=5050. $ python3 ir.py 5050 标有*和**的两条指令在i = 50时执行前后的状态变化如下： 这里局部变量sum和i的保存位置就和上面描述的差不多，与运算栈保存在接近的物理区域，但是二者互不干扰。 执行ADD前，运算栈上恰好有两个元素，也就是前两条指令依次压入栈中的sum和i的值，当前栈顶的值是i的值50。执行ADD时，将这两个值依次弹出，栈顶的值作为右操作数，栈顶下的一个值作为左操作数，执行加法得到1226，再把1226压回栈中，执行完后运算栈上恰好有一个元素1226。 执行STORE sum时，将栈顶的1226弹出，存入sum所在的位置，执行完后sum的值被更新为1226，运算栈为空。 备注 1. 类似Java Bytecode这样的，虽然也属于基于栈的IR，但是实际的Java虚拟机中都会先把它转化成其它容易优化的形式，所以它的意义仅仅是便于生成和传输，几乎不会用于优化。这也启示我们，尽管我们选择了不容易优化的基于栈的IR，但未来还是有拓展的空间，可以把它转化成其他形式再进行优化。类似的还有Python Bytecode。 ↩ "},"docs/step1/manual-parser.html":{"url":"docs/step1/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 该文档简单展示使用 c 风格代码手写 parser 的过程。 0. 定义 我们的最终目标是这样一个函数，接受 token list 作为输入，输出一个代表整个程序结构的 AST。 parse(token_list) -> Prog 但是在 lab9 之前我们都只有一个 main 函数，所以这里的 Prog 可以暂时简化为 Function。 首先我们先定义 token 和 AST node enum TokenKind { TK_RESERVED, // 保留字，包含关键字和各种符号 TK_IDENT, // 标识符，如变量名、函数名 TK_NUM, // 数字字面量，如 1, 0 }; struct Token { TokenKind kind; char* str; //对应的字符串 // int raw, col; //如果你想得到报错位置，需要在这里记录行号与列号信息 }; struct Prog { Function* func; } struct Func { list stmts; } enum NodeKind{ ND_RETURN, // return 语句 ND_NUM, // 数值字面量 }; struct Node { NodeKind kind; int val; // 用于储存 ND_NUM 类型节点的数值 Node* expr; // 用来储存 ND_RETURN 类型节点返回的表达式节点 }; statement 和 expression 两类节点有较大的区别，推荐区分为不同的两类 Node，这里未作区分，也不会有什么问题。 推荐使用 unique pointer 和 shared pointer 来构建 AST 树。 1. 访问 Token 在 lex 阶段，我们的到了一个 token list，在 parse 阶段，我们需要访问这个 list 构建 AST ，我们需要一套访问接口来方便操作。 // 获得当前正在处理的 token，处理完毕返回 NULL Token* take_token(); // 进入下一个 token 的处理 void next_token(); 这一步实现简单，甚至不一定要抽象为一个函数，请大家自行实现。 2. 框架 解析的过程是对产生式的还原。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer 最上层函数为解析一个 Prog，目前相当与解析一个函数。 Program* parse() { Program* prog = new Program(); Function *fn = function(); prog->func = fn; return prog; } 　非终结符解析函数 parse()中，function()函数代表解析一个非终结符 function，即：从当前的 token 开始，消耗若干个 token，直到解析完成一个function（一个非终极符）。该函数没有输入，返回一个 AST 结点，过程中消耗了 token。接下来本文中类似函数（名称与产生式中非终结符一致）都是类似的含义。 按照生成式，解析一个 function 需要依次解析 type Identifier ( ） { statement }，如下： Function *function() { parse_reserved(\"int\"); // 应该为 type(), 这里做了简化 char *name; parse_ident(name); Function *fn = new Function(name); parse_reserved(\"(\"); parse_reserved(\")\"); parse_reserved(\"{\"); while (!parse_reserved(\"}\")) { fn->nodes.push_back(stmt()); } return fn; } 其中 parser_xxx()代表解析一个终结符。为直接访问 token 的函数，仅仅处理一个 token，与 token 类别一一对应。正如上方的说明，stmt() 表示，消耗一系列 token，解析出一条语句。 对非终极符的解析函数是由其他的非终结符函数、终结符函数和处理AST节点的语句构成，如果你同时完成了名称解析或者类型检查等，你还需要其他功能语句。 终结符解析函数：parser_xxx() // 解析成功返回 true, 否则为 false bool parse_int_literal(int &val); // 解析一个数字字面量，结果通过 val 返回 bool parse_reserved(const char* str); // 解析一个保留字 str bool parse_ident(char* &ident); // 解析一个标识符，结果通过 ident 返回 这些底层的解析函数会处理当前的 token（通过 take_token()）拿到，如果成功会跳过当前 token（也就是调用 next_token()）。 如 parse_reserved() 会检查当前 token 的类型是否为 TK_RESERVED，如果是，检查其字符串是否与给出的一致,如果是，返回 true。以上任意一步失败，返回 false。 如果你想要自己的编译器在发生错误时停止，可以这样。 Function *function() { assert(parse_reserved(\"int\")); // ... } 当然，也可以输出一些错误信息。如果你想得到报错位置，可以令 parse_xxx()返回 token 位置信息。 stmt() 类似 function()的思路，对语句的解析也可以按照生成式进行，目前仅需要解析 return 一种类型的语句。 Node* stmt() { Node* node = NULL; if (parse_reserved(\"return\")) { node = new Node(ND_RETURN); node->expr = expr(); assert(parse_reserved(\";\")); return node; } return node; } 其中, expr()为解析一个表达式的函数，因为目前的 expr()仅仅需要解析一个数字，可以通过调用 parse_int_lliteral()轻松实现。返回一个类型为 ND_NUM的Node就好了。 总结 第一个 lab 的工作看似很简单，但是我们需要搭建一个比较完整的框架来便于后续工作，其实工作量较大。接下来工作会比较轻松。 "},"docs/step1/spec.html":{"url":"docs/step1/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step1 语法规范 我们采用 EBNF (extended Barkus-Naur form) 记号书写语法规范，采用类似 ANTLR 的记号： 小写字母打头的是非终结符（如 program），大写字母打头的是终结符（如 Identifier），可以用字符串字面量表示终结符（如 'int'） 后面会用到：( 和 ) 表示分组，| 表示选择，* 零或多次，+ 一或多次，? 零或一次。 很容易通过增加新的非终结符，去掉这些符号。例如 x+ 就可以被替换成新的非终结符 y，并且 y : x | x y。 EBNF 也有很多写法，另一种是用尖括号表示非终结符 ::= 等。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer step1 语义规范 1.1 MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2^31, 2^31-1]，补码表示。 1.2 编译器应当只接受 [0, 2^31-1] 范围内的整数常量, 不支持负整数常量，如果整数不在此范围内，编译器应当报错。引入负号-后，可以用负号配合正整数常量来间接表示负整数常量。 1.3 如果输入程序没有 main 函数，编译器应当报错。 "},"docs/step2/intro.html":{"url":"docs/step2/intro.html","title":"任务概述","keywords":"","body":"实验指导 step2：一元运算符 step2 中，我们要给整数常量增加一元运算：取负 -、按位取反 ~ 以及逻辑非 !。 语法上，我们需要修改 expression 的定义，从 expression : Integer 变成： expression : unary unary : Integer | ('-'|'!'|'~') unary 三个操作的语义和 C 以及常识相同，例如 ~0 == -1，!!2 == 1。 稍微一提，关于按位取反，我们使用补码存储 int；关于逻辑非，只有 0 表示逻辑假，其他的 int 都是逻辑真。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step2/guide.html":{"url":"docs/step2/guide.html","title":"实验指导","keywords":"","body":"step2 实验指导 我们按照上一节划分的编译器阶段，分阶段给出 step2 实验指导。 词法语法分析 如果你使用工具完成词法语法分析，修改你的规范以满足要求，剩下的交给工具即可。 语法规范已经给出，词法规范的变化也很简单，新增三个 token：-、~ 和 !。 你的规范和我们的要求等价、能通过测试即可，不用完全一样。 语义检查无需修改。 如果你是手写分析，参见这里。 IR 生成 显然，我们要引入一类 IR 表示一元操作。 一元操作 IR 的含义是：弹出栈顶，对弹出的值做某个一元操作，再把操作的结果值压入栈顶。 换言之，就是直接对栈顶做某个操作。 指令 参数 含义 IR 栈大小变化 neg 无参数 栈顶取负 不变 not 同上 栈顶按位取反 不变 lnot 同上 栈顶取逻辑非 不变 和 step1 一样，这一节所讲的领悟意思即可。 你不用照着实现。 例如你可以把三条指令变成一条 Unary(op)，其中 op 是 \"-\"、\"~\" 或 \"!\"。 你甚至也不必显式转成 IR。 和 step1 一样，采用 Visitor 模式遍历 AST 来生成 IR。除了 step1 的要求，step2 还要求你遍历 AST 时， 遇到一元表达式的时候，先生成子表达式的 IR，然后再根据操作类型生成一个 neg 或 not 或 lnot 所以，~!--3 会翻译成 push 3 ; neg ; neg ; lnot ; not 五条 IR 指令。 汇编生成 很简单，如下表。 IR 汇编 neg lw t1, 0(sp) ; neg t1, t1 ; sw t1, 0(sp) not …… lnot …… 要知道每个操作生成什么样的汇编，可以参考 gcc 的输出。 例如我们想知道取负的汇编，那我们用 gcc 编译 int foo(int x) { return -x; }， 结果如下（记得加 -O3），我们就知道取负是 neg 目标寄存器, 操作数寄存器。 foo: neg a0,a0 ret 仿照上面，自己确定 not 和 lnot 的汇编。 思考题 我们在语义规范中规定整数运算越界是未定义行为，运算越界可以简单理解成理论上的运算结果没有办法保存在32位整数的空间中，必须截断高于32位的内容。请设计一个 minidecaf 表达式，只使用-~!这三个单目运算符和从 0 到 2147483647 范围内的非负整数，使得运算过程中发生越界。 提示：发生越界的一步计算是-。 总结 本节内容不多。 "},"docs/step2/manual-parser.html":{"url":"docs/step2/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 节点定义变化 增加三种表达式节点，分别为：按位取反、取负、逻辑取反 struct NodeKind { + ND_NEG, + ND_NOT, + ND_BITNOT, } 这一变化很简单，以后省略。 parse 过程变化 按照产生式变化对应修改即可，很简单。 expression : unary unary : Integer | ('-'|'!'|'~') unary Node* expr() { return unary(); } Node* unary() { if(parse_reserved(\"-\")) { Node* neg = new Node(ND_NEG); neg->expr = unary(); return neg; } //...　`!``~`同理 return num(); } 注意，unary()的解析是递归的，这与产生式是一致的。 "},"docs/step2/spec.html":{"url":"docs/step2/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step2 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : unary unary : Integer | ('-'|'!'|'~') unary step2 语义规范 2.1 运算符 - 的结果是其操作数的相反数。 2.2 运算符 ~ 的结果是其操作数的二进制反码（也就是说，结果中的每一个二进制位是 1 当且仅当其对应的二进制位是 0）。 2.3 当操作数不等于 0 时，逻辑非运算符 ! 的结果为 0；当操作数等于 0 时，其结果为 1。 2.4 MiniDecaf 中，负数字面量不被整体作为一个 token。它被看成是一个取负符号、后面是它的绝对值。 所以我们无法用字面量表示 -2147483648，但可以写成 -2147483647-1（待我们加上四则运算后）。 2.5 整数运算越界是未定义行为（undefined behavior），即对程序的行为无任何限制。 例如 -(-2147483647-1) 是未定义行为。这一条规则对于后续 step 引入的运算符也都适用。 对于含有未定义行为的 C/C++ 程序，在启用优化选项编译时，编译器可能产生意料之外的结果。 "},"docs/step3/intro.html":{"url":"docs/step3/intro.html","title":"任务概述","keywords":"","body":"实验指导 step3：加减乘除模 step3 我们要增加的是：加 +、减 -、乘 *、整除 /、模 % 以及括号 ( )。 语法上我们继续修改 expression，变成 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1+2*(4/2+1) == 7。 我们这种表达式语法写法可能比较繁琐，但它有几个好处： 和C99 标准草案保持一致 把优先级和结合性信息直接编码入语法里，见优先级和结合性一节。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step3/guide.html":{"url":"docs/step3/guide.html","title":"实验指导","keywords":"","body":"step3 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 对有兴趣的同学：虽然 -2 和 2-3 里面的 - 意义不同，但 lexer 不知道这点（parser 才知道），所以它们都会用同样的 token kind - 表示。 但有时，可能需要后续阶段告诉 lexer（或 parser）一些信息，最经典的例子是 “typedef-name identifier problem”。 我们的表达式语法规范和 C 标准的基本相同，但略显繁琐。 如果你选择的语法分析工具支持优先级和结合性，并且你希望用这些信息来简化语法分析工具的编写，请参考这里。 语义检查无需修改。 如果你是手写分析，参见这里。 IR 生成 我们同样引入一类 IR 表示二元操作。 执行二元操作的 IR 时，两个操作数需要位于栈顶，然后它们被弹出、进行相应操作，再把结果压入栈顶。 指令 参数 含义 IR 栈大小变化 add 无参数 弹出栈顶两个元素，压入它们的和 减少 1 sub 无参数 弹出栈顶两个元素，压入它们的差，顺序如上 减少 1 mul、div、rem 无参数 ……乘除模 减少 1 其中我们规定二元操作的右操作数在栈顶，左操作数在右操作数下面。 举个例子，(10-3)%5 翻译成 IR 是 [push 10 ; push 3 ; sub ; push 5 ; rem] 五条指令， 执行过程中栈变化如图。 类比 step2，生成 IR 时 Visitor 遍历 AST 遇到二元操作，需要（注意 1. 和 2. 的顺序） 首先生成左操作数的 IR（左操作数入栈，栈顶是左操作数） 然后生成右操作数的 IR（右操作数入栈，栈顶是右操作数) 根据操作不同生成对应的二元 IR 上面的 3 步执行完后，栈大小比执行第 1. 步以前增加 1，栈顶就是二元操作的结果。 这符合我们在 step1 中的假设： 考虑源代码中某个表达式被翻译成了一系列 IR 指令，那么从任何初始状态出发执行这些 IR 指令， 完成后 IR 栈大小增加 1，栈顶就是表达式的值。 汇编生成 仿照 step2 所说，用 gcc 自己确定 sub/mul/div/rem 的汇编。 IR 汇编 add lw t1, 4(sp) ; lw t2, 0(sp) ; add t1, t1, t2 ; addi sp, sp, 4 ; sw t1, 0(sp) sub,mul,div,rem …… 思考题 请给出将寄存器 t0 中的数值压入栈中所需的 riscv 汇编指令序列；请给出将栈顶的数值弹出到寄存器 t0 中所需的 riscv 汇编指令序列。 我们知道“除数为零的除法是未定义行为”，但是即使除法的右操作数不是 0，仍然可能存在未定义行为。请问这时除法的左操作数和右操作数分别是什么？请将这时除法的左操作数和右操作数填入下面的代码中，分别在你的电脑（请标明你的电脑的架构，比如 x86-64 或 ARM）中和 RISCV-32 的 qemu 模拟器中编译运行下面的代码，并给出运行结果。（编译时请不要开启任何编译优化） #include int main() { int a = 左操作数; int b = 右操作数; printf(\"%d\\n\", a / b); return 0; } 总结 本节重点是执行过程中栈的变化，以及上面提到的 step1 的假设，参见上面 IR 生成一节。 "},"docs/step3/precedence.html":{"url":"docs/step3/precedence.html","title":"优先级和结合性","keywords":"","body":"优先级和结合性 操作符有优先级和结合性的概念，在之前的编程经历中大家应该已经对这两个概念已经有了直观的理解，这里用例子进一步解释一下： 优先级是两个操作符之间的关系，例如*的优先级比+高，所以表达式1 + 2 * 3应该解析成语法树add (1 mul (2 3))（前序表示），不能解析成mul (add (1 2) 3) 结合性是一个操作符的性质，例如-是左结合的，所以表达式1 - 2 - 3应该解析成sub (sub (1 2) 3)，不能解析成sub (1 sub (2 3)) 我们给出的语法规范已经表示了这样的性质，因此理论上我们不需要再额外定义操作符的优先级和结合性了。你可以自己试试，按照本步给出的语法规则，上面的两个表达式确实只能解析成我们期望的结果。 但是有一个问题：这样的语法规范虽然是正确的，也确实可以直接用来实现语法分析器了，但并不符合直观：我们一开始学习C或者别的编程语言的时候，讲的就是一个二元表达式由两个子表达式和中间的操作符组成，并且操作符有优先级和结合性。也就是这样的： expression : expression ('+'|'-') expression | expression ('*'|'/'|'%') expression | ('-'|'~'|'!') expression | Integer | '(' expression ')' 当然，它是有歧义的，你也可以自己试试，如果只有这些产生式的话，上面的两个表达式都可以解析成正确或者错误的结果。所以如果想基于这个规范来实现语法分析器，就必须告诉语法分析工具这些操作符的优先级和结合性是什么。 之后每一步给出的语法都是没有歧义，本身就能体现优先级和结合性的。如果你确实想借助优先级和结合性来实现，需要两个步骤： 把我们给出的语法规范转化成类似上面这样“更模糊”，有歧义的语法规范。我们相信这个方向的转化应该是容易的。 指定每个操作符的优先级和结合性。可以参考https://en.cppreference.com/w/c/language/operator_precedence，它给出了C语言操作符的优先级和结合性，因为我们的MiniDecaf语言是C语言的一个子集，所以这张表格也足够我们的语言使用了。 "},"docs/step3/manual-parser.html":{"url":"docs/step3/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 struct Node { - Node* expr; + Node* lexpr; + Node* rexpr; } 现在需要储存两个 expression。 parse 过程变化 按照产生式变化对应修改即可，很简单。 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative // ... primary : Integer | '(' expression ')' 加法示例： Node* additive() { Node* node = multiplicative(); while(parse_reserved(\"+\")) { //这里只展示了 `+`, `-`同理 node = new_binary(ND_ADD, node, multiplicative()); } return node; } Node* new_binary(NodeKind kind, Node* lexpr, Node* rexpr); // 类似构造函数，简单赋值 注意左结合性，请思考为何这么写能够保证左结合。如果一种算法是右结合的，应该怎样写呢？ "},"docs/step3/spec.html":{"url":"docs/step3/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step3 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step3 语义规范 3.1 二元操作符 * 的结果是操作数的乘积。 3.2 二元操作符 / 的结果是第一个操作数除以第二个操作数所得的商的整数部分（即所谓“向零取整”），二元操作符 % 的结果是第一个操作数除以第二个操作数所得的余数。在两种操作中，如果第二个操作数为 0，则其行为都是未定义的。当 b 不为 0 时，表达式 (a/b)*b + a%b 应该等于 a。 3.3 二元操作符 + 的结果是操作数的和。 3.4 二元操作符 - 的结果是第一个操作数减去第二个操作数所得的差。 3.5 除非特别声明，子表达式求值顺序是未规定行为（unspecified behavior），即其行为可以是多种合法的可能性之一。也就是说，以任意顺序对子表达式求值都是合法的。 例如：执行 int a=0; (a=1)+(a=a+1); 之后 a 的值是未规定的（待我们加上变量和赋值运算符后，这个问题才会产生真正切实的影响）。 "},"docs/step4/intro.html":{"url":"docs/step4/intro.html","title":"任务概述","keywords":"","body":"实验指导 step4：比较和逻辑表达式 step4 我们要增加的是： 比较大小和相等的二元操作：、、>=, >, ==, != equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive 逻辑与 &&、逻辑或 || expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1=2 是逻辑真（int 为 1）。 但特别注意，C 中逻辑运算符 || 和 && 有短路现象，我们不要求。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step4/guide.html":{"url":"docs/step4/guide.html","title":"实验指导","keywords":"","body":"step4 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查无需修改。 手写分析根据生成式变化修改即可，变化很小。 IR 生成 沿用 step3 加入的二元操作 IR（以及左右操作数的位置），新的 IR 如下。 指令 参数 含义 IR 栈大小变化 eq 无参数 ==（弹出栈顶两个元素，如果相等压入 1，否则压入 0） 减少 1 ne 无参数 ……!= 减少 1 le 无参数 …… 减少 1 ge 无参数 ……>= 减少 1 lt 无参数 …… 减少 1 gt 无参数 ……> 减少 1 land 无参数 ……&& 减少 1 lor 无参数 弹出栈顶两个元素，将其逻辑或压入栈 减少 1 这样设计的IR中，&&和||都是没有短路性质的。我们的语义规范要求是否实现短路性质都可以。 汇编生成 对于比较大小和相等的操作，参照 gcc 结果，自行完成汇编生成。 逻辑表达式会麻烦一点，因为 gcc 可能会用跳转来实现&&和||，比较难以理解，所以下面直接给出 land 和 lor 对应的不使用跳转的汇编。 表格中，我们省略了汇编的前缀 lw t1, 4(sp) ; lw t2, 0(sp) 和后缀 addi sp, sp, 4 ; sw t1, 0(sp)。 注意 RISC-V 汇编中的 and 和 or 都是位运算指令，不是逻辑运算指令。 IR 汇编 lor or t1,t1,t2 ; snez t1,t1 land snez t1,t1 ; snez t2,t2 ; and t1,t1,t2 思考题 在表达式计算时，对于某一步运算，是否一定要先计算出所有的操作数的结果才能进行运算？ 在 MiniDecaf 中，我们对于短路求值未做要求，但在包括 C 语言的大多数流行的语言中，短路求值都是被支持的。为何这一特性广受欢迎？你认为短路求值这一特性会给程序员带来怎样的好处？ 总结 step4 和 step3 差别不大。 "},"docs/step4/spec.html":{"url":"docs/step4/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step4 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step4 语义规范 4.1 关系操作符 （小于）、>（大于）、（小于等于）和>=（大于等于）的结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。 关系操作符可能导致表达式的含义与数学文献中常见的含义不同，例如 0 的含义与 (0 相同，即“如果 0 小于 1，那么判断是否有 1 小于 2，否则判断是否有 0 小于 2”。 4.2 判等操作符 ==（等于）和 !=（不等于）类似于关系操作符，结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。但判等操作符的优先级比关系操作符更低。对于任意一对操作数，这两个操作符中有且仅有一个结果为 1。 其优先级的设定会导致其含义在某些时候可能会反直观，例如，0 的运算结果为 1。 4.3 当操作数都非 0 时，逻辑与操作符 && 的结果为 1；否则其结果为 0。 4.4 当操作数有一个非 0 时，逻辑或操作符 || 的结果为 1；否则其结果为 0。 4.5 逻辑操作符 || 和 && 依然遵循语义规范 3.5，即其操作数的求值顺序是未指定行为。 换言之，我们不对逻辑表达式的短路求值做要求，可以将操作数两个以任意顺序计算出，再计算逻辑操作的结果。 "},"docs/step5/intro.html":{"url":"docs/step5/intro.html","title":"任务概述","keywords":"","body":"实验指导 step5：局部变量和赋值 这一步我们终于要增加变量了，包括 变量的声明 变量的使用（读取/赋值） 并且，虽然还只有一个 main 函数，但 main 函数可以包含多条语句和声明了。 为了加入变量，我们需要确定：变量存放在哪里、如何访问。 为此，我们会引入 栈帧 的概念，并介绍它的布局。 语法上，step5 的改动如下： function : type Identifier '(' ')' '{' statement* '}' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression primary : Integer | '(' expression ')' | Identifier 并且我们也要增加语义检查了：变量不能重复声明，不能使用未声明的变量。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step5/guide.html":{"url":"docs/step5/guide.html","title":"实验指导","keywords":"","body":"step5 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查部分，我们需要检查是否（一）使用了未声明的变量、（二）重复声明变量。 为此，我们在生成 IR 的 Visitor 遍历 AST 时，维护当前已经声明了哪些变量。 遇到变量声明（declaration）和使用（primary 和 assignment）时检查即可。 可以把这个要求和后面提到的符号表结合，放到 IR 生成去做。 如果你是手写分析，参见这里。 IR 生成 为了完成 step5 的 IR 生成，我们需要确定 IR 的栈帧布局，请看 这里。 step1提到，局部变量保存在栈上，这个栈和IR中的运算栈并不是一个概念。 前者指的是汇编中一片可以增长的物理空间（可以称之为物理栈），后者是一个逻辑上的概念。 这二者的关系是，我们之前一直在使用物理栈的空间来实现运算栈。 局部变量存放在物理栈上，运算栈也在物理栈上，它们的内存空间很接近，但是二者是互不干扰的，对运算栈的压栈弹栈操作，不能影响到局部变量的值。 因此我们需要加入访问物理栈内部的 load/store，以及生成栈上地址的 frameaddr 指令。 此外我们还加入一个pop指令，这与上面的讨论没有什么关系，是用于别的用途： 指令 参数 含义 IR 栈大小变化 frameaddr 一个非负整数常数 k 把当前栈帧底下开始第 k 个元素的地址压入栈中 增加 1 load 无参数 将栈顶弹出，作为地址 1 然后加载该地址的元素（int），把加载到的值压入栈中 不变 store 无参数 弹出栈顶作为地址，读取新栈顶作为值，将值写入地址开始的 int 减少 1 pop 无参数 弹出栈顶，忽略得到的值 减少 1 IR 生成还是 Visitor 遍历，并且 遇到读取变量 primary: Identifier 的时候，查符号表确定变量是第几个，然后生成 frameaddr 和 load。 如果查不到同名变量，应当报错：变量未定义 遇到变量赋值的时候，先生成等号右手边的 IR，同上对等号左手边查符号表，生成 frameaddr 和 store。 注意赋值表达式是有值的，执行完它的 IR 后栈顶还保留着赋值表达式的值。这就是为什么 store 只弹栈一次。 遇到表达式语句时，生成完表达式的 IR 以后记得再生成一个 pop，保证栈帧要满足的第 1. 条性质（这里有说） 遇到声明时，除了记录新变量，还要初始化变量。 为了计算 prologue 中分配栈帧的大小，IR 除了一个指令列表，还要包含一个信息：局部变量的个数。 main 有多条语句了，它的 IR 是其中语句的 IR 顺序拼接。 例如 int main(){int a=2; a=a+3; return a;}，显然 a 是第 0 个变量。 那它的 IR 指令序列是（每行对应一条语句）： push 2 ; frameaddr 0 ; store ; pop ; frameaddr 0 ; load ; push 3 ; add ; frameaddr 0 ; store ; pop ; frameaddr 0 ; load ; ret ; 汇编生成 IR 指令到汇编的对应仍然很简单，如下表。 IR 汇编 frameaddr k addi sp, sp, -4 ; addi t1, fp, -12-4*k ; sw t1, 0(sp) load lw t1, 0(sp) ; lw t1, 0(t1) ; sw t1, 0(sp) store lw t1, 4(sp) ; lw t2, 0(sp) ; addi sp, sp, 4 ; sw t1, 0(t2) pop addi sp, sp, 4 但除了把 IR 一条一条替换成汇编，step5 还需要生成 prologue 和 epilogue，并且 ret 也要修改了， 参见栈帧文档。 IR 汇编 ret lw a0, 0(sp) ; addi sp, sp, 4 ; j FUNCNAME_epilogue 另外我们还要求 main 默认返回 0： 5.4 执行完 main 函数但没有通过 return 结束时，返回值默认为 0。 显然，如果 main 是通过 return 结束的，按照上面的修改一定是跳到 main_epilogue，否则是顺序执行到 main_epilogue 的。 因此我们在 main_epilogue 之前，所有语句之后，加上 push 0 的汇编即可，表示默认返回 0。 思考题 描述程序运行过程中函数栈帧的构成，分成哪几个部分？每个部分所用空间最少是多少？ 有些语言允许在同一个作用域中多次定义同名的变量，例如这是一段合法的 Rust 代码（你不需要精确了解它的含义，大致理解即可）： fn main() { let a = 0; let a = f(a); let a = g(a); } 其中f(a)中的a是上一行的let a = 0;定义的，g(a)中的a是上一行的let a = f(a);。 如果 MiniDecaf 也允许多次定义同名变量，并规定新的定义会覆盖之前的同名定义，请问在你的实现中，需要对定义变量和查找变量的逻辑做怎样的修改？ 备注 1. 我们规定 load 的地址必须对齐到 4 字节，生成 IR 时需要保证。store 也是。 ↩ "},"docs/step5/stackframe.html":{"url":"docs/step5/stackframe.html","title":"栈帧","keywords":"","body":"栈帧 所以我们需要确定栈（包括 IR 的栈和汇编的栈）上面到底有那些元素，这些元素在栈上的布局如何。 汇编语言课上提到过 栈帧（stack frame） 的概念，简单回想一下： 每次调用和执行一个函数，都会在栈空间上开辟一片空间，这篇空间就叫“栈帧”。 栈帧里存放了执行这个函数需要的各种数据，包括局部变量、callee-save 寄存器等等。 当然，既然汇编有栈帧, 栈式机 IR 也有栈帧。 我们只有一个函数 main，直到 step9 我们才会有多函数支持。 所以现在关于栈帧的讨论，我们就只考虑一个栈帧。 后面的 step 会深入讨论。 关于栈帧，有两个问题需要说明 栈帧长什么样？即、栈帧上各个元素的布局如何？ 栈帧是如何建立与销毁的？ 第 1. 点，我们规定，程序执行的任何时刻，栈帧分为三块： 栈顶是计算表达式用的运算栈，它可能为空（当前不在计算某表达式的过程中） 然后一片空间存放的是当前可用的所有局部变量 返回地址、老的栈帧基址等信息 下图展现了汇编栈的栈帧结构，以及执行过程中栈中内容的变化。 栈左上方是源代码，右上方是 IR。 粉色背景表示已经执行完的汇编对应的源代码/IR。 假设用户给的输入是 24 12。 从中可以看出，栈帧满足如下性质 每条语句开始执行和执行完成时，汇编栈帧大小都等于 8 + 4 * 局部变量个数 个字节，其中 4 == sizeof(int) 是一个 int 变量占的字节数 （就是 step1 中的假设）任何表达式对应的 IR 序列执行结果一定是：栈帧大小增加 4，栈顶四字节存放了表达式的值。 汇编栈帧底部还保存了 fp 和返回地址，使得函数执行完成后能够返回 caller 继续执行。 把栈帧设计成这样，访问变量就可以直接用 fp 加上偏移量来完成。 例如第 1. 小图中，“读取 a” 就是加载 -12(fp)；第 3. 小图中，“保存到 c” 就是保存到 -20(fp)。 我们只叙述了汇编的栈帧，但 IR 的和汇编的一样（就我们的设计而言），也是三个部分，也要有 old fp 和返回地址。 建立栈帧 进入一个函数后，在开始执行函数体语句的汇编之前，要做的第一件事是：建立栈帧。 每个函数最开始、由编译器生成的用于建立栈帧的那段汇编被称为函数的 prologue。 就 step5 而言，prologue 要做的事情很简单 分配栈帧空间 保存 fp 和返回地址（在寄存器 ra 里） 举个例子，下面是一种可能的 prologue 写法。 其中 FRAMESIZE 是一个编译期已知的常量，等于 8 + 4 * 局部变量个数（这名字不太准确，因为有运算栈，栈帧大小其实不是常量） addi sp, sp, -FRAMESIZE # 分配空间 sw ra, FRAMESIZE-4(sp) # 储存返回地址 sw fp, FRAMESIZE-8(sp) # 储存 fp addi fp, sp, FRAMESIZE # 更新 fp 当然，开始执行函数时需要建立栈帧，结束执行时就需要销毁栈帧。 函数末尾、用于销毁栈帧的一段汇编叫函数的 epilogue，它要做的是： 设置返回值 回收栈帧空间 恢复 fp，跳回返回地址（ret 就是 jr ra） 返回值我们可以直接放在 a0 中，也可以放在栈顶让 epilogue 去加载。 如果是后者，那么上面“栈帧满足如下性质”的 1. 要把 return 作为例外了。 把返回值放在栈顶的话，下面是 epilogue 一种可能的写法。 前缀 FUNCNAME 是当前函数函数名，例如 main，加上前缀以区分不同函数的 epilogue。 FUNCNAME_epilogue: # epilogue 标号，可作为跳转目的地 lw a0, 0(sp) # 从栈顶加载返回值，此时 sp = fp - FRAMESIZE - 4 addi sp, sp, 4 # 弹出栈顶的返回值 lw fp, FRAMESIZE-8(sp) # 恢复 fp lw ra, FRAMESIZE-4(sp) # 恢复 ra addi sp, sp, FRAMESIZE # 回收空间 jr ra # 跳回 caller 就 step5，保存恢复 fp/ra 的确不必要。但是加上会让后面步骤更方便。 需要注意的是，IR 的 ret 指令不能直接 jr ra 了，而是要跳转执行 epilogue，即 j FUNCNAME_epilogue。 变量声明 对于每个变量声明，我们需要 设定变量相对 fp 的偏移量。 在栈帧上预留保存变量空间 第 2. 点已经在 prologue 中完成了，所以重点是第 1. 点。 对每个变量用一个数据结构维护其信息，如：名称、类型（step12）、声明位置、初始值等。 目前阶段，你可以简单的使用一个简单的链表或者数组来保存变量的信息。 这个保存变量符号的表被称为 符号表（symbol table）。 那偏移量可以（一）作为变量数据结构的一个字段、（二）也可以维护一个变量到偏移量的映射、（三）像下面通过某种方法计算得到。 当然，不能用一张符号表覆盖整个程序，程序中不同位置的符号表是不同的。 例如，符号表只会包含被声明的变量的信息，因此在 int a=0; 之后的符号表比之前的多了一个条目表示 a 对应的变量数据结构。 确定变量的偏移量本身倒很容易：从前往后每一个声明的变量偏移依次递减，从 -12(fp) 开始，然后是 -16(fp)、-20(fp) 以此类推。 所以对于每个变量，我们只需在其数据结构中记录：它是从前往后第几个变量。 第 k>=0 个变量的偏移量就是 -12-4*k。 目前我们没有作用域的概念，这样做是没问题的，在第7章引入作用域后，会有一种更加节约空间的做法。 "},"docs/step5/manual-parser.html":{"url":"docs/step5/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 推荐你先阅读本节其他部分，了解栈帧和对局部变量的处理方式。 定义变化 struct Node { + Var* var; } // 为了维护变量信息的结构体 + struct Var { + char* name; + int offset; // 在栈中距离 fp 的 offset + Node* init; // 初始化的值 + } parse 变化 语句类别变多了： Node* stmt() { Node* node = NULL; Type* ty; // Return statement if (parse_reserved(\"return\")) { node = new_stmt(ND_RETURN, expr()); assert(parse_reserved(\";\")); return node; } // 局部变量声明 if (type()) { return declaration(); } // 直接由表达式构成的语句，注意 a = 1; 就是此类，有一个表达式的值没有用到 node = expr(); assert(parse_reserved(\";\")); return new_stmt(ND_UNUSED_EXPR, node); } 具体的 declaration()等按照生成式很容易写出来。 declaration : type Identifier ('=' expression)? ';' Node* declaration() { // type() 已经在 stmt() 中完成 char* name; assert(parse_ident(name)); Var* var = new Var(name); // 这里储存已经声明变量的信息，为名称解析做准备 add_local(var); // 如果进行了初始化 if (parse_reserved(\"=\")) { var->init = expr(); } assert(parse_reserved(\";\")); Node* node = new_stmt(ND_DECL); node->var = var; return node; } 在被引用时： Node* primary() { // ... char* name; if (parse_ident(name)) { // find_var 负责寻找同名变量, 在 add_local 维护的数据结构中寻找即可 Var* var = find_var(name); // 引用未声明变量的检查 assert(var); return new_var_node(var); } // ... } [可选]变量信息维护 变量信息的维护可以在 IR 生成中进行，也可以在 parser 的同时进行（本文中就是这样做的），也可以专门作为一个步骤进行。 在处理变量声明时需要维护已声明变量的信息(add_local())，可以使用链表，也可以使用你喜欢的数据结构来维护它。不过要注意 add_local()中应该同时完成 offset 的确定和变量重复定义的检查。在变量被引用时，你需要通过名称找到对应的结构体。 "},"docs/step5/spec.html":{"url":"docs/step5/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step5 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement* '}' type : 'int' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step5 语义规范 5.1 每一条变量声明（定义）指定了对标识符的解释和属性。当变量被定义时，应当有一块存储空间为这个变量所保留。当变量声明之后，若与这个变量的名称相同的标识符作为操作数（operand）出现在一个表达式中时，其就应被指派（designate）为这个变量。 5.2 变量的初始化表达式指定了变量的初始值。 5.3 同一个标识符应只能作为至多一个变量的名字，即是说，不允许声明重名变量。 5.4 对未声明的变量的使用是错误。 5.5 没有被初始化的（局部）变量的值是不确定的。 在初始化表达式中，正在被初始化的变量已被声明，但其值尚未被初始化。 例如，int a = a + 1;，这样一条声明在语义上等价于 int a; a = a + 1; 5.6 局部变量的名字可以为 main。 5.7 赋值运算 = 的左操作数必须是一个可修改的左值（modifiable lvalue）。左值（lvalue）即一个会被指派为某个变量的表达式，如在 int a; a = 1; 中，a 即是一个会被指派为变量的表达式。的左值可修改是指被指派的变量不能是一个左值数组。 就 step5 来说，这一点其实几乎已经被语法保证，因为其 = 的左边只能是一个标识符，只需再要求其是一个已经声明过的变量的名字即可。 详见后面 step12 的讨论。 5.8 在赋值运算（=）中，右操作数的值会被存在左操作数所指派的变量中。 5.9 赋值表达式的结果，为赋值运算完成后左操作数所指派的变量的值，但这个结果本身并非左值。 5.10 一个函数中可以有任意多条 return 语句。 5.11 当 main 函数执行至 } 时，应终止执行并返回 0。 "},"docs/step6/intro.html":{"url":"docs/step6/intro.html","title":"任务概述","keywords":"","body":"实验指导 step6： step6 我们要支持 if 语句和条件表达式（又称三元/三目表达式，ternary expression）。 语法上的改动是： if 表达式 statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? 条件表达式 assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional block_item：为了下一阶段做准备 function : type Identifier '(' ')' '{' block_item* '}' block_item : statement | declaration if 语句的语义和 C 以及常识相同，条件表达式优先级只比赋值高。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step6/guide.html":{"url":"docs/step6/guide.html","title":"实验指导","keywords":"","body":"step6 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查无需修改。 如果你是手写分析，参见这里。 注意 step6 引入 block_item 后，declaration 不再是语句，所以 if (a) int b; 不是的合法代码。 这和 C 标准是一致的（不过在C++中这样的代码是合法的，也许这更加符合你的常识）。 悬吊 else 问题 这一节引入的 if 语句既可以带 else 子句也可以不带，但这会导致语法二义性：else 到底和哪一个 if 结合？ 例如 if(a) if(b) c=0; else d=0;，到底是 if(a) {if(b) c=0; else d=0;} 还是 if(a) {if(b) c=0;} else d=0;（其中有大括号，step7中会支持，不过意思不难理解）？ 这个问题被称为 悬吊 else（dangling else） 问题。 如果程序员没有加大括号，那么我们需要通过一个规定来解决歧义。 我们人为规定：else 和最近的 if 结合，也就是说上面两种理解中只有前者合法。 为了让 parser 能遵守这个规定，一种方法是设置产生式的优先级，优先选择没有 else 的 if。 按照这个规定，parser 看到 if(a) if(b) c=0; else d=0; 中第一个 if 时，选择没有 else 的 if； 而看到第二个时只能选择有 else 的 if 1，也就使得 else d=0; 被绑定到 if(b) 而不是 if(a) 了。 IR 生成 显然，我们需要跳转指令以实现 if，同时还需要作为跳转目的地的标号（label）。 我们的跳转指令和汇编中的类似，不限制跳转方向，往前往后都允许。 指令 参数 含义 IR 栈大小变化 label 一个字符串 什么也不做，仅标记一个跳转目的地，用参数字符串标识 不变 beqz 同上 弹出栈顶元素，如果它等于零，那么跳转到参数标识的 label 开始执行 减少 1 bnez 同上 弹出栈顶元素，如果它不等于零，那么跳转到参数标识的 label 开始执行 减少 1 br 同上 无条件跳转到参数标识的 label 开始执行 不变 注意一个程序中的标号，也就是 label 的参数，必须唯一，否则跳转目的地就不唯一了。 简单地维护一个计数器即可，例如 label l1, label l2, label l3 ... Visitor 遍历 AST 遇到一个有 else 的 if 语句，为了生成其 IR，要生成的是 首先是 条件表达式的 IR：计算条件表达式。 beqz ELSE_LABEL：判断条件，若条件不成立则执行 else 子句 跳转没有执行，说明条件成立，所以之后是 then 子句的 IR br END_LABEL：条件成立，执行完 then 以后就结束了 label ELSE_LABEL，然后是 else 子句的 IR label END_LABEL：if 语句结束。 例子：if (a) return 2; else a=2+3; 的 IR 是 frameaddr k ; load，其中 k 是 a 的 frameaddr beqz else_label1，数字后缀是避免标号重复的 push 2 ; ret br end_label1 label else_label1，然后是 push 2 ; push 3 ; add ; frameaddr k ; store ; pop label end_label1 仿照上面，容易写出条件表达式的 IR 应该如何生成，并且同时也能保证满足语义规范 6.4 和 3.2 不同，条件表达式规定了子表达式的求值顺序。 首先对条件求值。如果条件值为真，然后仅对 ? 和 : 之间的子表达式求值，作为条件表达式的值， 不得对 : 之后的子表达式求值。 如果条件为假，类似地，仅对 : 之后的子表达式求值。 类似，无 else 的 if 语句的 IR 包含 条件表达式的 IR beqz END_LABEL then 子句的 IR label END_LABEL 汇编生成 如下表： IR 汇编 label LABEL_STR LABEL_STR: br LABEL_STR j LABEL_STR2 beqz LABEL_STR lw t1, 0(sp) ; addi sp, sp, 4 ; beqz t1, LABEL_STR bnez LABEL_STR lw t1, 0(sp) ; addi sp, sp, 4 ; bnez t1, LABEL_STR 思考题 Rust 和 Go 语言中的 if-else 语法与 C 语言中略有不同，它们都要求两个分支必须用大括号包裹起来，而且条件表达式不需要用括号包裹起来： if 条件表达式 { // 在条件为 true 时执行 } else { // 在条件为 false 时执行 } 请问相比 C 的语法，这两种语言的语法有什么优点？ 总结 本节主要就是引入了跳转，后面 step8 循环语句还会使用。 备注 1. 见思考题 ↩ 2. 如果 LABEL_STR 在当前函数内，j LABEL_STR 就等于 beqz x0, LABEL_STR ↩ "},"docs/step6/manual-parser.html":{"url":"docs/step6/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 增加两种新节点的同时，需要增加 Node 的内容。 struct NodeKind { + ND_IF, + ND_TERN, // :? 运算 } struct Node { + Node* cond; // 储存条件表达式 + Node* then; // 储存条件判断成功时执行的语句（返回的表达式） + Node* else; // 储存条件判断失败时执行的语句（返回的表达式） } 注意，对于 :?运算符，then 和 else 是两个表达式节点， 对于 if 语句，这两个变量是两个语句节点。 解析变化 按照生成式变化改变即可。if 语句示例如下： Node* stmt() { // ... // IF statement if (parse_reserved(\"if\")) { assert(parse_reserved(\"(\")); node = new_node(ND_IF); node->cond = expr(); assert(parse_reserved(\")\")); node->then = stmt(); if(parse_reserved(\"else\")) node->els = stmt(); return node; } // ... } 以后同质化的内容不再展示。 "},"docs/step6/spec.html":{"url":"docs/step6/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step6 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' block_item* '}' type : 'int' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier 注意：if 的 then 分支和 else 分支需要是一个语句（statement）而非声明（declaration）。 例如 if (1) int a; 不是合法的 MiniDecaf 程序。 step6 语义规范 6.1 条件表达式会先对第一个操作数求值，再根据其值选择计算第二个或第三个操作数。当且仅当第一个操作数的值不等于 0，我们会对第二个操作数求值。当且仅当第一个操作数的值等于 0，我们会对第三个操作数求值。当第一个操作数的值为 0 时，条件表达式的求值结果为第二个操作数所求得的值；当第一个操作数的值非 0 时，条件表达式的求值结果为第三个操作数所求得的值。 不论选择第二个操作数或者是第三个操作数去求值，都必须首先计算完第一个操作数，之后才能开始第二个或第三个操作数的求值计算。 6.2 对于 if 语句而言，当控制条件不等于 0 时，会执行第一个子句；当控制条件等于 0 时，如果有 else 分支，就会执行第二个语句，否则整个 if 语句的执行便已经完成。 6.3 如果出现悬吊 else（dangling else），要求 else 优先和最接近的没有匹配 else 的 if 匹配。 例如 if (0) if (0) ; else ; 等价于 if (0) { if (0) ; else; } 而非 if (0) { if (0) ; } else ;。 "},"docs/step7/intro.html":{"url":"docs/step7/intro.html","title":"任务概述","keywords":"","body":"实验指导 step7：作用域和块语句 step7 我们要增加块语句的支持。 虽然块语句语义不难，就是把多个语句组成一个块，每个块都是一个作用域。 随之而来一个问题是：不同变量可以重名了。 重名的情况包括作用域内部声明覆盖（shadowing）外部声明，以及不相交的作用域之间的重名变量。 因此，变量名不能唯一标识变量了，同一个变量名 a 出现在代码不同地方可能标识完全不同的变量。 我们需要进行 名称解析（name resolution），确定 AST 中出现的每个变量名分别对应那个变量。 语法上改动不大 function : type Identifier '(' ')' compound_statement compound_statement : '{' block_item* '}' statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement 语义检查我们也要修改了，只有在同一个作用域里，变量才不能重复声明。 当然，如果变量在使用前还是必须先被声明。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step7/guide.html":{"url":"docs/step7/guide.html","title":"实验指导","keywords":"","body":"step7 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 至于变量相关的语义检查，因为它们和名称解析密切相关，所以可以放到那里面去，参见后文。 手写分析只需根据产生式变化增量变化即可，如果你将名称解析在语法解析中完成，你可能需要按照本章指导调整你的这部分代码，一点提示。 名称解析 step7 我们需要给自己的编译器新增一个阶段：名称解析，它位于语法分析和 IR 生成之间。 这个词广义上的含义就是：把名称关联到对应的实体。例如网络原理中的 DNS 也是名称解析。 我们所谓 “阶段” 只是逻辑上的。就 MiniDecaf 的实现而言，名称解析也可以放在 IR 生成这一步里，在生成 IR 的同时进行名称解析。 名称解析的阶段任务就是把 AST 中出现的每个变量名关联到对应的变量，它需要遍历 AST，所以实现为 AST 上的一个 Visitor 它的输入 是 parser 给的 AST 它的输出 是上面那棵 AST，但 AST 中所有涉及变量名的结点都增加一个属性，表示此处的变量名到底标识哪个变量 这样的结点有：primary、assignment 和 declaration。 代码中，这样的属性可以实现为指向 变量数据结构 的一个指针。 也可以实现为一个从 AST 结点到变量的映射。 下面是一个例子： 考虑我们有一段代码： { int a=0; a= a+1; if (a) { int a=2; return a; } return a; { int b=12; return a +b; } } 显然其中有三个变量，两个的名字是 a 一个的是 b。不妨把这三个变量记为 a0, a1, b0。 名称解析应当发现这点，并且还要把每个变量名关联到变量，所以它提供的信息类似： { int a=0; // a0 a= // a0 a+1; // a0 if (a) { // a0 int a=2; // a1 return a; // a1 } return a; // a0 { int b=12; // b0 return a // a0 +b; // b0 } } 如果按照定义把这个结果画在语法树上，那么大致如（仅示意，省略了一些不重要的中间结点） 用于储存变量信息的 符号表 的结构也需要改进，以支持作用域。具体的，它需要支持 符号表中，区分不同作用域的变量：支持声明覆盖（shadowing)、检查重复声明 离开某作用域时，要把其中的变量从符号表中删除 为此，我们把符号表改造为一个栈。 (对应上面 1.）栈中每个元素都对应一个开作用域，是一个列表，包含该作用域中至今声明过的所有变量。 程序中不同位置的符号表是不同的；某位置的 开作用域（open scope） 指的是包含该位置的所有作用域。 例如上图中 return a+b; 处，有两个开作用域（声明 a0 和 b0 的），而声明 a1 的作用域不是开作用域。 （对应上面 2.) 每进入一个作用域，就压栈一个空列表；离开作用域就弹栈 在符号表中查找变量名，从栈顶往下查找（所以内层声明才能覆盖外层声明）。 另外， 变量偏移量 和 栈帧大小 的计算方法可以做出修改。例如上面的代码中，我们很清楚a1和b0不可能同时有用，所以它们可以使用同一片物理空间来保存，这样可以节约空间。 如果我们还假设偏移量是 -12-4*frameaddr，那变量的 frameaddr 意义需要变化。 为了保证 step5 中叙述的栈帧性质，变量 frameaddr 的含义要改为是 “在此变量刚声明之前，所有开作用域中的变量总数”。 例如上图中，frameaddr(a1) == frameaddr(b0) == frameaddr(a0)+1。 栈帧大小也 FRAMESIZE 也不能等于 8 + 4 * 局部变量个数 了，它应该是 8 + 4 * 最大的frameaddr。 但是，原来的计算方法也并不是不行，我们完全可以让a1和b0使用不同的物理空间来保存，只是会浪费一些空间而已。 依然可以记录曾经出现过的变量的总数，以此为每个变量分配一个独特的地址，完全不考虑作用域的结构。 最后，名称解析 Visitor 需要 维护符号表，进入块语句（compound_statement）时压栈、离开时弹栈 每次遇到变量名（Identifier）时查找符号表，将其关联到具体的变量，或者报错变量未声明 每次遇到声明（declaration），确定 frameaddr、建立变量并插入符号表，或者报错变量重复声明 IR 生成 无须新增 IR 语句。 块语句的 IR 由其中子语句 IR 顺序拼接而成即可。 汇编生成 无须修改。 思考题 请将下述 MiniDecaf 代码中的 ??? 替换为一个 32 位整数，使得程序运行结束后会返回 0。 int main() { int x = ???; if (x) { return x; } else { int x = 2; } return x; } 在实验指导中，我们提到“就 MiniDecaf 而言，名称解析的代码也可以嵌入 IR 生成里”，但不是对于所有语言都可以把名称解析嵌入代码生成。试问被编译的语言有什么特征时，名称解析作为单独的一个阶段在 IR 生成之前执行会更好？ 总结 本节最重要的内容是名称解析。 "},"docs/step7/manual-parser.html":{"url":"docs/step7/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 处理块语句时需要记录块若干条语句的信息，可以对 Node 进行这样的修改: struct Node { + std::list body; } "},"docs/step7/spec.html":{"url":"docs/step7/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step7 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step7 语义规范 7.1 根据其声明的位置，每一个标识符都属于一个作用域。目前我们有两种作用域：文件级和块级。如果是在块中声明，则标识符其声明所属的块的作用域中，例如局部变量；否则标识符在文件级（全局）作用域中，例如全局变量。 7.2 （更新 5.6）如果一个标识符在两个作用域里面，这两个作用域必然是嵌套的，即一个内层作用域完全被另一个外层作用域所覆盖。且在内层作用域中，外层作用域里该标识符所指派（designate）的变量或函数是不可见的。 在初始化表达式中，其正在初始化的变量已被声明，会隐藏（shadow）外层作用域的同名变量，但其值不确定。例如在下面的代码片段中，a + 1 的值是不确定的。 int a = 1; { int a = a + 1; } 7.1 （更新 5.3）对于同一个标识符，在同一个作用域中至多有一个声明。 7.3 （更新 5.4）使用不在当前开作用域中的变量名是不合法的。 "},"docs/step8/intro.html":{"url":"docs/step8/intro.html","title":"任务概述","keywords":"","body":"实验指导 step8：循环语句 step8 我们要增加对循环语句，以及 break/continue 的支持： statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' 循环语句的语义和 C 的也相同，并且我们要检查 break/continue 不能出现在循环外。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step8/guide.html":{"url":"docs/step8/guide.html","title":"实验指导","keywords":"","body":"step8 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 值得一提的是，四种循环大同小异，都可以写成 Loop(pre, cond, body, post)，AST 中可以用一个统一的节点表示。 Loop(pre, cond, body, post) AST 结点表示如下的一个循环 { // pre 里面可能有声明，所以需要这个作用域 pre; // 可能是空、也可能是一个 declaration 或者 expression while (cond) { // 可能是空、也可能是一个 expression body; // body 里的 continue 会跳转到这里 post; // 是一个 expression } // break 跳转到这里 } 手写分析只需根据产生式变化增量变化即可。 名称解析 变量名相关的解析不变，但注意按照语义规范 8.2，for 要自带一个作用域，for 的初始化语句中声明的变量相当于在这个作用域中声明的。 因此 for (int i=0; i 是合法的代码， 这是符合C标准的（不过在C++中这样的代码是不合法的，也许这更加符合你的常识）， 它的名称解析如 for (int i=0; // i0 i 另外，我们需要确定：每个 break 和 continue 跳转到的标号是哪个。 实现很容易，类似符号表栈维护 break 标号栈和 continue 标号栈。 遇到 Loop(...) 就（一）创建这个循环的 break 标号和 continue 标号（以及起始标号）； （二）把两个标号压入各自栈里； （三）离开 Loop 的时候弹栈。 和 step6 一样，各个循环的标号需要唯一，简单地后缀一个计数器即可。 每次遇到 break 语句，其跳转目标就是 break 标号栈的栈顶，如果栈为空就报错。continue 语句类似。 IR 生成 无新增 IR。 这一阶段 Visitor 遍历 AST 时，遇到 Loop(pre, cond, body, post)，生成的 IR 如 pre 的 IR label BEGINLOOP_LABEL：开始下一轮迭代 cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 body 的 IR label CONTINUE_LABEL：continue 跳到这 post 的 IR br BEGINLOOP_LABEL：本轮迭代完成 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 其中 XXX_LABEL 要和上一步名称解析生成的标号名一样。 遇到 break 语句的 AST 结点时，生成一条 br BREAK_LABEL，其中 BREAK_LABEL 是名称解析确定的标号。 汇编生成 不变。 思考题 将循环语句翻译成 IR 有许多可行的翻译方法，例如 while 循环可以有以下两种翻译方式： 第一种（即实验指导中的翻译方式）： label BEGINLOOP_LABEL：开始下一轮迭代 cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 body 的 IR label CONTINUE_LABEL：continue 跳到这 br BEGINLOOP_LABEL：本轮迭代完成 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 第二种： cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 label BEGINLOOP_LABEL：开始下一轮迭代 body 的 IR label CONTINUE_LABEL：continue 跳到这 cond 的 IR bnez BEGINLOOP_LABEL：本轮迭代完成，条件满足时进行下一次迭代 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 从执行的指令的条数这个角度（label 指令不计算在内，假设循环体至少执行了一次），请评价这两种翻译方式哪一种更好？ 总结 step8 相对容易。 "},"docs/step8/spec.html":{"url":"docs/step8/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step8 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step8 语义规范 方便起见，我们称 for 循环括号中的三个表达式/声明自左向右依次为 init、ctrl 和 post。 例如 for (i=0; i 中，i=0 是 init，i 是 ctrl，i=i+1 是 post。 8.1 有三种循环语句：for 循环、while 循环和 do 循环。执行一条循环语句，意味着反复执行一条语句（即循环体），直到其控制表达式等于 0。 8.2 while 循环的控制表达式的求值在循环体的每次执行之前。 8.3 do 循环的控制表达式的求值在循环体的每次执行之后。 8.4 对于 for 循环而言：如果 init 是一个声明，其声明发生在控制表达式的第一次求值之前；如果 init 是一个表达式，其求值会在控制表达式的第一次求值之前。ctrl 即是控制表达式，其求值在循环体的每次执行之前。post 的求值在循环体的每次执行之后。 8.5 for 循环的 init、ctrl 和 post 都可以被省略。省略 ctrl 等价于将其替换为一个非零常数，比如 1。 8.6 循环语句有其自己的作用域，且是它所在的作用域的子集。循环体也有其作用域，且是循环语句的作用域的子集。如果 for 循环的 init 是一条声明，则其所声明的变量所属的作用域是整个 for 循环语句的作用域（包含 init、ctrl、post 和循环体）。 例如，for (int i=0;;i=i+1) { int i=1; return i; } 是合法的代码片段。 8.7 continue 语句和 break 语句要么出现在循环体里，要么其就是循环体。 8.8 执行一条 continue 语句，意味着将程序的执行跳转至该条 continue 语句所在的最小的循环语句的循环体的末尾。 例如，for (int i=0;i 等价于 for (int i=0;i。 8.9 执行一条 break 语句，意味着终止该条 break 语句所在的最小的循环语句的执行。 "},"docs/step9/intro.html":{"url":"docs/step9/intro.html","title":"任务概述","keywords":"","body":"实验指导 step9：函数 step9 开始，我们要支持多函数了。 我们需要支持函数的声明和定义： program : function* function : type Identifier '(' parameter_list ')' (compound_statement | ';') parameter_list : (type Identifier (',' type Identifier)*)? 我们还需要支持函数调用： expression_list : (expression (',' expression)*)? unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' 语义检查部分，我们需要检查函数的重复定义、检查调用函数的实参（argment）和形参（parameter）的个数类型一致。 我们不支持 void 返回值，直接忽略 int 返回值即可。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step9/guide.html":{"url":"docs/step9/guide.html","title":"实验指导","keywords":"","body":"step9 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 如果你是手写分析，参见这里。 名称解析 类似符号表，我们需要一张表维护函数的信息。 当然，函数不会重名，所以不用解析名称。 这张表主要目的是记录函数本身的信息，方便语义检查。 就 step9 而言，这个信息包括 参数个数（step12 开始还需要记录参数和返回值类型）。对应的语义检查：9.4 是否已经有定义，还是只有声明。对应的语义检查：9.2 IR 生成 step9 之前因为只有一个函数，所以一个 MiniDecaf 程序的 IR 就只是一个指令序列。 现在有了函数了，一个 MiniDecaf 程序的 IR 应当包含一系列 IR 函数，源代码中每个函数都对应一个 IR 函数。 而一个 IR 函数 需要包含 函数自身的信息：函数名、需要 prologue 中分配的“栈帧”大小 3 等； 函数体对应的 IR 指令序列。 对于函数声明和定义，IR 生成的 Visitor 遍历 AST 时， 函数声明结点：没有函数体，无须生成任何 IR 函数定义结点：继续遍历子结点，拿到上面的两种信息，然后创建一个 IR 函数 函数调用是一个比较复杂的操作，见 这里。 为了支持它，我们需要引入 call 指令，并且修改 ret 指令让它不要把栈顶返回值弹出。 指令 参数 含义 IR 栈大小变化 call 一个字符串表示函数名 调用作为参数的函数1，调用完后栈顶是 callee 的返回值 增加 12 ret 无参数 （返回值已经在栈顶了）终止当前函数执行，返回 caller 不变 汇编生成 ret 的汇编不变，call 的如下表。 IR 汇编 call FUNC call FUNC，然后有几个参数就执行几次 pop，然后 addi sp, sp, -4 ; sw a0, 0(sp) 我们已经在 IR 处理了传参，所以汇编生成时不用再考虑传参。 如果你采用非标准的调用约定，prologue 和 epilogue 也不用改，也不用处理 caller-save 寄存器。 否则你可能还需要增加 caller/callee-save 寄存器保存与恢复的代码。 总结 引入了概念 调用约定，并且描述了栈帧的变化。 思考题 MiniDecaf 的函数调用时参数求值的顺序是未定义行为。试写出一段 MiniDecaf 代码，使得不同的参数求值顺序会导致不同的返回结果。 备注 1. call 指令不包含准备参数。 ↩ 2. call 的变化是指，整个 callee 执行完成返回 call 指令后，IR 栈大小相对执行 call 前的大小变化。 ↩ 3. 这个栈帧加了引号，因为它没有包含运算栈 ↩ "},"docs/step9/calling.html":{"url":"docs/step9/calling.html","title":"函数调用","keywords":"","body":"函数调用 函数调用是最复杂的一种表达式结构了。 源代码里的一个函数调用，其实包含了下面几个步骤 准备参数，完成传参 （汇编）保存 caller-save 寄存器 真正执行 call 指令（汇编上是 jalr 指令） 执行 call 然后是子函数执行的时间, 直到子函数 ret（汇编上是 jr ra）返回 （汇编）恢复 caller-save 寄存器 拿到返回值，作为函数调用这个表达式的值 这几步操作有时又被称为调用序列（calling sequence） 上面几步都需要我们确定 调用约定（calling convention）： （第 1.、5. 步）参数和返回值都如何准备、该放哪儿？ （第 2.、4. 步）哪些寄存器是 caller-save 的？ （在 prologue/epilogue 中）那些寄存器是 callee-save 的？ 调用约定通常是在汇编层级用到的，汇编语言课上也讲过。 因为汇编语言很底层，没有函数/参数的语言支持，只有标号/地址/寄存器，所以需要规定如何用汇编的语言机制模拟函数调用。 我们为了简单，IR 不提供对函数的语言支持，所以我们同样需要有 IR 的调用约定。 需要注意的是，调用约定只是一种约定，它不唯一。 x86 上常见的就有默认的 cdecl（汇编课讲过）、stdcall、fastcall 等好几种。 只要 caller 和 callee 的调用约定相同，那么函数调用就不会出问题。 RISC-V 的调用约定 32 位 RISC-V 的标准（指 gcc 使用的）的调用约定中，和我们相关的是： caller-save 和 callee-save 寄存器在 \"Unprivileged Spec\" 的 109 页。 返回值（32 位 int）放在 a0 寄存器中 参数（32 位 int）从左到右放在 a0、a1……a7 中。如果还有，则从右往左压栈，第 9 个参数在栈顶。 自己使用 gcc 编译一个有很多参数的函数调用即可验证。 为了简便和方便描述，我们下面使用一种非标准的调用约定。 callee 只需要保存 fp 和 ra，caller 无须保存寄存器 callee 把返回值放在 a0 中，caller 看到返回之后把返回值压入运算栈 参数不用寄存器传递，所有参数从右往左压栈，第 1 个参数在栈顶。 这个调用约定的优点是叙述和实现简单，但不标准。 你当然可以选择实现标准的调用约定，这样你的汇编能够和 gcc 的汇编互相调用，但是难度会大一些。 助教的实现用的也不一定是这个调用约定。 采用这个非标准的调用约定，仿照 step5 我们可以画出函数调用过程中栈帧的变化图。 可见现在栈帧包含四块，从顶向下依次是运算栈、实参、局部变量、fp 和 ra（下图 1.）。 其中还有一个问题就是形参的处理，例如上面 3. 到 4. 过程中，bar 要访问 a，那 a 放在哪儿？ 可以直接使用 foo 栈帧上的实参，那么 a 相对 fp 的偏移量为 0，同理 b 偏移量为 4。 因此 step7 中的偏移量计算方法仅限非参数的局部变量，而第 k>=0 个参数相对于 fp 的偏移量是 4*k。 还有一种方法是把参数当成普通局部变量，在 prologue 中复制到栈帧中局部变量的区域。 IR 的调用约定 对于 IR 类似上面简便的约定： 传参从右到左压栈 返回值放在栈顶 另外，IR 也需要保存返回地址，如果它要作为一门独立的语言，需要被执行的话。 但我们暂时没有这个需求，可以不管它。可以假设 call 指令会把返回地址保存到其他地方，并且同时把当前栈帧设为新函数的。 汇编的 call（就是 jalr）会保存返回地址到 ra，然后 prologue 里会保存 ra 到 callee 栈帧中。 "},"docs/step9/manual-parser.html":{"url":"docs/step9/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 程序定义出现变化： struct Program { - Function* func; + std::list funcs; } 程序解析对应发生变化： Program* parse() { Program* prog = new Program(); while(not_end()) { Function *fn = function(); prog->funcs.push_back(fn); } return prog; } 函数解析需要新增对于函数参数的解析，同时函数定义发生变化。 struct Function { + std::list args; } Function *function() { assert(type()); char *name; parse_ident(name); Function *fn = new Function(name); parse_reserved(\"(\"); + fn->args = func_args(); parse_reserved(\")\"); parse_reserved(\"{\"); while (!parse_reserved(\"}\")) { fn->nodes.push_back(stmt()); } return fn; } 对函数调用的节点定义： struct FuncCall { char* name; std::list args; }; struct Node { + FuncCall* func_call; } 对函数调用的解析，同时完成名称解析和参数检查（目前之要求数量相同）。 Node* primary() { // ... char* name; if (parse_ident(name)) { parse_reserved(\"(\") Node *node = new_node(ND_FUNC_CALL); // func_call() 完成对于 args 的解析，循环解析 expr, `,` 即可 assert(node->func_call = func_call(name)); // 不能调用未声明函数 Function* fn; assert(fn = find_func(node->func_call->name)); // 参数必须相同 assert(fn->args.size() == node->func_call->args.size()); return node; } // ... } 这里没有展示如何与局部变量应用做区分，想想该如何做？ "},"docs/step9/spec.html":{"url":"docs/step9/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step9 语法规范 灰色部分表示相对上一节的修改。 program : function* function : type Identifier '(' parameter_list ')' compound_statement type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier 我们暂不要求支持不包含函数体的函数声明。 step9 语义规范 9.1 在函数调用中，实参和形参的参数个数必须相同，同一位置的参数类型也必须相同。 9.2 在准备函数的调用时，所有的实参会被求值，然后赋给相应位置上的形参。 在函数体中，形参的值可能会被改变，但即便实参是一个可修改的左值，被调用函数中形参的改变也不会影响实参的值。 9.3 函数是可以递归调用的。 9.4 （更新 5.10）执行一条 return 语句，意味着终止当前函数的执行，并将控制权交还给调用当前函数的 caller，语句中的表达式的值会返还给 caller 作为函数调用的表达式的值。一个函数可以有任意多条 return 语句。 9.5 函数的形参可以被视为在函数体的开头被定义（被以实参的值初始化）的局部变量。所有形参均为左值，且不能被在函数体中直接重定义（除非是在一个更小的嵌套的块中）。 例如，int f(int x) { int x; } 不合法，但 int f(int x) { { int x; } } 合法。 9.6 如果一个不是 main 的函数执行到了它的 }，且其返回值被 caller 所使用，则这是一个未定义行为。 对于感兴趣的同学：C 语言中规定只有使用了返回值才是未定义行为，而 C++ 中规定不管返回值有没有被使用，都是未定义行为。 我们没有支持 void 类型，但可以忽略返回值达到类似的效果。 “执行到了 }” 意味着执行时没有通过 return 返回，例如 int f(){if(0) return 0;}。 实现的时候，你可以直接让所有函数都默认返回 0，语义规范说 main 之外的函数没有 return 是未定义行为，未定义行为的意思就是你想怎么处理都可以，所以全部默认返回 0 当然也是可以的，而且更清晰简单。 "},"docs/step10/intro.html":{"url":"docs/step10/intro.html","title":"任务概述","keywords":"","body":"实验指导 step10：全局变量 step10 我们要支持的是全局变量，语法改动非常简单： program : (function | declaration)* 全局变量和局部变量不同，它不是分配在栈上，而是放在某个固定地址，写在汇编的 .bss 段或 .data 段里。 访问它也不能通过 fp 加偏移量，而是需要通过它的符号加载它的地址，通过它的地址访问它。 汇编课上应该讲过，实际中（包括 gcc 和 qemu）使用的可执行文件的格式是 ELF（Executable and Linking Format）。 .text 是其中存放代码的段（section），.bss 和 .data 都是其中存放数据的段，前者零初始化后者须指定初始值。 对有兴趣的同学： 全局变量地址不是被狭义上的编译器（compiler）确定的，也不是被汇编器（assembler）确定的，而是被链接器（linker）或加载器（loader）确定的。 简单的说，狭义上的编译器把源代码变成文本汇编，汇编器把文本汇编给编码到二进制代码，然后通过链接器变成可执行文件，运行时由加载器加载到内存中运行。 当然，广义上的编译器就囊括了这所有阶段。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step10/guide.html":{"url":"docs/step10/guide.html","title":"实验指导","keywords":"","body":"step10 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 如果你是手写分析，参见这里。 名称解析 和局部变量一样，全局变量要放进符号表里，名称解析才能解析到它们。 和 step7 一样，符号表是一个栈，其中每个元素对应一个作用域。 全局变量就放在栈底，它们位于全局作用域；名称分析遍历 AST 过程中，栈底元素一直都在，不会被弹出。 全局变量相关的语义检查有： 初始值只能是整数字面量。 有以下几种可行的实现方法： 直接取得初始值对应源代码的字符串，按整数解析（int(text) 或 Integer.parse(text)）即可。 修改语法，全局变量是一个新的 global_declaration : type Identifier ('=' Integer)? ';'。 判断这个expr节点的具体类型，要求它必须是整数常量，并且获取常量值。各种语言中都有相应的机制，只是语法不太一样。 不能重复声明：step7 已经要求同一作用域中不能重复声明变量了。 IR 生成 局部变量需要通过 frameaddr 访问，但全局变量不行，所以我们引入新的 IR 指令用于加载全局变量的地址 指令 参数 含义 IR 栈大小变化 globaladdr 一个字符串，表示符号名 取得符号名对应的全局变量的地址，压入栈中 增加 1 例如 int a=2; int main(){return a;} 中 main 的 IR 是 globaladdr a ; load ; ret。 并且现在，一个 MiniDecaf 程序的 IR 除了一系列 IR 函数，还要包含一系列 IR 全局变量 了，每个需要记录的信息类似： 大小有多少字节 是否有初始值，初始值是多少 汇编生成 汇编可以直接用 la 加载全局变量地址 IR 汇编 globaladdr SYMBOL addi sp, sp, -4 ; la t1, SYMBOL ; sw t1, 0(sp) 每个全局变量还对应一段汇编，不过这段汇编基本就是一个模板替换，我们直接给出结果。 例如 int compiler = 2020; 放到 .data，其汇编如下，compiler 和 2020 可替换成其他变量名和初始值： .data .globl compiler .align 4 .size compiler, 4 compiler: .word 2020 汇编命令（assembler directive）的标准文档在 这里。 不用深入学习汇编命令，它们不是课程内容。 简要解释一下：.data 表示输出到 data 段；.globl a 定义一个全局符号；.word 后是一个四字节整数，是 a 符号所在内存的初始值。 而 int tsinghua; 放到 .bss 的汇编如下，第一个 4 表示大小，第二个 4 表示对齐要求 .comm tsinghua,4,4 思考题 请给出将全局变量 a 的值读到寄存器 t0 所需的 riscv 指令序列。 总结 我们实验中，全局变量相对简单。 但其实全局变量可以展开讲到 linker 和 loader，可惜我们课容量有限不能讨论。 "},"docs/step10/manual-parser.html":{"url":"docs/step10/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 Program的构成再次发生变化，需要调整相关定义和解析方式，总体难度较小。这里仅作简单提示。 如何区分全局变量和函数？ 根据产生式，二者关键不同在于名称之后是否带一个　(　。 // 实际上这么写肯定不好 bool is_func() { return type() && parse_ident() && parser_reserved(\"(\"); } "},"docs/step10/spec.html":{"url":"docs/step10/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step10 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step10 语义规范 10.1 对于全局变量的初始化，我们仅对初始化表达式是整数字面量的情况做要求（例如 2123），对初始化表达式是非字面量的情况不做任何要求（例如 a 或 f() 或 2+3）。 C 其实也支持非字面量的编译期常量，例如 int a=1+3;。编译器可以计算出 1+3==4 然后让它等价于 int a=4;。 但为了实现简便，我们就不要求支持这点。 C 不允许 int a=f(); 因为 f() 不是编译器常量； 而 C++ 甚至可以支持 int a=f();，其大致实现为 int a=0; 然后在 main 之前执行的初始化函数中 a=f();。 10.2 我们对全局变量的重复声明不做任何要求或限定；但全局变量不能被重复定义，即不能有同名的被初始化的全局变量。 int a; int a=2; int a; int main(){ return a;} 是合法的 C 代码，不过不是合法的 C++ 代码，也许 C++ 的处理方式更符合你的直觉。 为了简单，我们不要求这点。比如对于形如 int a; int a=2; 或 int a; int a; 的代码片段，你可以以任意方式处理。 10.3 如果一个全局变量没有被初始化，我们认为其拥有一个默认初始值 0。 "},"docs/step11/intro.html":{"url":"docs/step11/intro.html","title":"任务概述","keywords":"","body":"实验指导 step11：数组 step11 支持的是数组和指针算术： 语法上没有太大改动， 数组的声明： declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' 数组和指针的下标操作 postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' 指针算术：语法不变，但允许：指针加/减整数、整数加指针、指针减指针了。 step11 难度不大，但有了数组让我们能够写很多有意思的程序了，step11 之前甚至 MiniDecaf 连快速排序都写不了。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step11/guide.html":{"url":"docs/step11/guide.html","title":"实验指导","keywords":"","body":"step11 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 你可能注意到，虽然数组是一种类型，但我们没有把数组放到 type 中，而是只放在 declaration 里。 这一方面是因为我们并不完全支持 C 的数组（例如我们没有指向数组的指针），另一方面 C 语言本身设计就如此。 对有兴趣的同学：C 的这个设计很麻烦…… 你能区分 int*[] 和 int(*)[] 哪个是指针的数组、哪个是数组的指针吗？ 加上函数指针就更麻烦了，例如声明 int (*(*vtable)[])(void*); 中变量 vtable 的类型是 int (*(*)[])(void*)，含义是 “是一个指针，指向一个数组，数组每个元素是函数指针，函数接受一个 void* 参数，函数返回 int”。 当然，实际中我们一般不会写出这样的代码，更好的方法是用 typedef 包装一下，例如上面的会写成 typedef int (*funcptr_t)(void*) ; typedef funcptr_t vtable_t[] ; vtable_t *vtable。 至于为什么 C 声明被设计成这样，有一个说法是设计者希望声明能够体现变量的用法。例如上面 vtable 的用法是 int v= (*(*vtable)[0])(voidptr_expr)，非常类似其声明。 当然这些都和我们 课程无关 ，我们更不用实现它们。 如果你是手写分析，参见这里。 名称解析 引入数组后，变量的大小不一定是 4 了，例如 int a[5][4] 大小是 80。 因此变量的数据结构还需要增加一个 size 属性，并且变量的 frameaddr 不一定连续了（但每个变量所占的一片内存空间一定连续）。 例如，某种实现中 int main(){ int a[2][2]; int b[2]; int c; } 中， a 的 frameaddr 是 0，b 的是 4，c 的是 6。 另外，我们修改了左值的定义 12.9： 12.9 (更新 11.1）表达式是左值的必要条件是它能被下面几条规则构造出来 被声明过的变量，如果声明类型不是数组，那么它是左值； 如果 e 是左值，那么括号括起的 (e) 也是左值； 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值； 下标运算的结果，如果其类型不是数组类型，那么它是左值。 因为本质上，int a; 的 a 的值被存放在内存中，需要一次访存 load 它的frameaddr 才能取得。 而局部变量 int a[2]; 中的 a 是一个编译期就确定的偏移量常数，它的值就是 fp 加上这个偏移量常数，无须访存。 全局变量 int a[2]; 也是类似的。 另外，数组各维长度必须是正整数，别忘实现对应的语义检查。 类型检查 除了 step12 的 IntegerType 和 PointerType， 我们还需要增加数组类型 ArrayType(baseType, length)。 例如 int *a[10][20] 就是 ArrayType(ArrayType(PointerType(IntegerType()), 20), 10)，特别注意 20 和 10 的位置。 当然，就 MiniDecaf 而言，实现中你可以一口气把所有维长度都存起来，变成 ArrayType(baseType, lengthList)，如上就是 ArrayType(PointerType(IntegerType()), [10, 20]) 如step12中所说，你也可以用不那么通用的方法来表示类型。 因为我们不允许指向数组的指针，所以可以用一个(int, 整数列表)的二元组表示step11中任何表达式的类型。 其中int部分表示数组的元素类型，它只可能是int的若干重指针，比如用 0 表示 int，3 表示 int***。 整数列表部分表示数组维度，如果为空，就是一个普通变量，否则就和上面的lengthList的含义一致。 不管你怎么表示类型，类型检查的规则是不会变的，int *a[10][20]可以表示成ArrayType(ArrayType(PointerType(IntegerType()), 20), 10)或者(1, [10, 20])，但是这只是同一个类型的两种的记录方式而已，不会影响到上层的逻辑。 并且相关类型规则是（语义规范 12.12, 12.13） 对于下标操作 e1[e2]，要求 e1 是指针类型或者数组类型，e2 是整数类型；结果类型是指针/数组的基类型。 注意，这里判断不要写 e1.type == PointerType, 而要写 e1.type instanceof PointerType（或者类似的手段）。 可以写 e2.type == IntegerType() 或者 e2.type instanceof IntegerType。 对于加法操作，除了最基础的 int 加法还要支持指针加法：两个操作数中一个是指针、另一个是 int；结果类型和指针操作数的类型一致。 对于减法操作，除了 int 减法还可能有两种情况 指针减整数：左操作数是指针类型、右操作数是 int；结果类型和第一个操作数的类型相同。（当然，MiniDecaf 禁止 int 减指针） 指针减指针：左右操作数是相同的指针类型，结果类型是 int IR 生成 无须新增 IR 指令。 数组声明 无需 IR 上特别处理，只要注意变量大小不一定是 4 即可。 并且，数组中数据的内存空间是连续的，因此无论数组的原型是几维的，都可以看做是一个一维的大数组。 对于一个数组 int a[d1][d2]⋯[dn]\\mathtt{int}~a[d_1][d_2]\\cdots[d_n]int a[d​1​​][d​2​​]⋯[d​n​​]，可看做是 int a′[d1d2⋯dn]\\mathtt{int}~a'[d_1d_2\\cdots d_n]int a​′​​[d​1​​d​2​​⋯d​n​​]。访问 a[i1][i2]⋯[in]a[i_1][i_2]\\cdots[i_n]a[i​1​​][i​2​​]⋯[i​n​​]，就是访问 a′[i1d2d3⋯dn+i2d3d4⋯dn+⋯+in]a'[i_1d_2d_3\\cdots d_n + i_2d_3d_4\\cdots d_n + \\cdots + i_n]a​′​​[i​1​​d​2​​d​3​​⋯d​n​​+i​2​​d​3​​d​4​​⋯d​n​​+⋯+i​n​​]。 例如，对于数组 int a[3][4][5]，有： a[i] 的地址是 a + (i * 4 * 5) * sizeof(int)； a[i][j] 的地址是 a + [(i * 4 * 5) + (j * 5)] * sizeof(int)； a[i][j][k] 的地址是 a + [(i * 4 * 5) + (j * 5) + k] * sizeof(int)。 下标操作 e1[e2] 需要分数组和指针来说，并且需要类型检查阶段所计算出的表达式类型信息。 如果 e1 是数组： 显然，e1[e2] 的地址是 e1 起始地址加上 e2 的值乘以 S，其中 S 为 e1 基类型的大小。 我们约定，任何数组类型类型表达式的 IR 执行后，栈顶正好多出一个元素，其为该数组的起始地址。 因此，为了生成 e1[e2] 的 IR，先生成 e1 的 IR，再生成 e2 的 IR，再生成三条指令：push S ; mul ; add； 这一步生成的是 e1[e2] 的地址，如果 e1[e2] 不是左值也不是数组，还需要一个 load。 例如 int a[10][20];，设 a 的 frameaddr 为 20，则 a 的 IR 如 frameaddr 20。 而 a[2+3] 的 IR 如下（其中 80 == 20 * sizeof(int)） frameaddr 20 push 2 ; push 3 ; add push 80 mul add 而 a[2+3][17] 作为非左值的 IR 如（如果是左值，去掉最后 load 即可） ...（和上面一样） push 17 push 4 mul add load 如果 e1 是指针： 类似上面，e1[e2] 的地址是 e1 的值加上 e2 的值乘以 S，其中 S 为 e1 的基类型的大小。 因此，为了生成 e1[e2] 的 IR，先生成 e1 的 IR（这里 e1 不是左值），然后生成 e2 的 IR，然后还是 push S ; mul ; add ; load。 不过 e1[e2] 可能作为左值，如果作为左值，那么生成地址的 IR 和上面一样，但去掉最后的 load。 指针算术 也分两类 指针加整数：e1 + e2，其中 e1 是指针、e2 是整数。 注意指针加整数的值是：指针的值，加上整数乘以 S，其中 S 为指针基类型的大小 1。 IR 生成类似上面，请自行设计。 例如 int *p;，设 p 的 frameaddr 是 20，那么 p+61 的 IR 如下（注意其中 push 4 ; mul） frameaddr 20 ; load ; push 61 ; push 4 ; mul ; add。 整数加指针、指针减整数类似。 指针减指针：同上，指针数值相减后，要除以基类型的大小。 因此 int *p 那么 (p+10) - (&p[3]) 等于 7。 汇编生成 无需特别修改。 思考题 设有以下几个函数，其中局部变量 a 的起始地址都是 0x1000(4096)，请分别给出每个函数的返回值（用一个常量 minidecaf 表达式表示，例如函数 A 的返回值是 *(int*)(4096 + 23 * 4)）。 int A() { int a[100]; return a[23]; } int B() { int *p = (int*) 4096; return p[23]; } int C() { int a[10][10]; return a[2][3]; } int D() { int *a[10]; return a[2][3]; } int E() { int **p = (int**) 4096; return p[2][3]; } C 语言规范规定，允许局部变量是可变长度的数组（Variable Length Array，VLA），在我们的实验中为了简化，选择不支持它。请你简要回答，如果我们决定支持一维的可变长度的数组(即允许类似 int n = 5; int a[n]; 这种，但仍然不允许类似 int n = ...; int m = ...; int a[n][m]; 这种)，而且要求数组仍然保存在栈上（即不允许用堆上的动态内存申请，如malloc等来实现它），应该在现有的实现基础上做出那些改动？ 提示：不能再像现在这样，在进入函数时统一给局部变量分配内存，在离开函数时统一释放内存。 当同时存在>= 2个可变长度的数组时，至少有一个数组的起始地址不能在编译时决定。 你可以认为可变长度的数组的长度不大于0是未定义行为，不需要处理。 总结 本节内容本身难度不大，但细节很多（尤其注意指针加整数时，整数要乘一个数），也有相当代码量。 备注 1. MiniDecaf 中指针基类型只能是 int、int*、int**……，所以这里 S 只可能等于 4。 ↩ "},"docs/step11/manual-parser.html":{"url":"docs/step11/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 引入了新类型数组，你可以这样定义类型。注意，你可以有自己的定义方式，这种定义稍显复杂。 enum TypeKind { TY_INT, TY_PTR, TY_ARR, }; struct Type { TypeKind kind; // 数组大小可变，其余类型皆为 4 // 数组 size = elem_size * arr_len int size; // 数组元素的类型，可能是另一个数组 Type* base; // 数组长度 int arr_len; // 数组元素大小， elem_size = base->size，可省略 int elem_size; // 数组维度 int arr_dim; }; struct Node { // 用于记录数组被引用时的 index + std::list arr_index; } 声明解析 注意对于类型的解析要分成两部分。 Node* declaration() { Type* ty = type(); char* name; assert(ty && parse_ident(name)); // 这里完成对 index 后缀的解析，最终确定类型 // suffix 消耗若干个 `[` num `]` ty = suffix(ty); // ... return node; } 引用解析 对于 index 后缀的解析比较简单，注意： minidecaf 允许数组和指针两种类型的变量进行 index 运算，但是意义完全不同。 仔细计算最终生成节点的类型。 "},"docs/step11/spec.html":{"url":"docs/step11/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step11 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step11 语义规范 11.1 一个数组类型描述了一组被连续分配在一段内存空间中的对象，所有对象都具有相同的类型（我们称之为元素类型）。数组类型包含两部分：元素类型，和数组的长度（即元素数量）。数组类型的表达式仅能参与下标运算。 11.2 我们仅要求支持固定长度的数组，即在数组的声明中，其长度是一个正整数字面量。 所以，我们不要求支持变长数组 int a[n]; 或不定长数组 int a[];。 11.3 我们不要求支持数组的初始化。 C 中可以写 int a[2]={1, 2}，但简单起见，我们不做要求。 由于我们不要求数组的初始化，根据 5.5，作为局部变量的数组中的元素初始值未定；根据 10.3，作为全局变量的数组中的元素初始值为 0。 11.4 对于下标运算 a[b]，要求 a 是一个数组类型，b 是一个整数类型，a[b] 是 a 中的第 b 个元素（从 0 开始计数）。 11.5 下标运算越界是未定义行为。 即便是类似 int a[4][5]; a[1][7] 这种，同样也是未定义行为。 "},"docs/step12/intro.html":{"url":"docs/step12/intro.html","title":"任务概述","keywords":"","body":"实验指导 step12：指针 step12 支持的是指针： 增加类型：指针类型 type : 'int' | type '*' 引入左值的概念，修改赋值 assignment : conditional | unary '=' expression 支持取地址操作符 & 和解引用操作符 * unary : postfix | ('-'|'~'|'!'|'&'|'*') unary 支持类型转换 unary : ... | '(' type ')' unary step12 相当复杂，需要我们引入类型系统、左值的概念，并且加入类型检查以及一大堆语义检查。 你需要： 首先实现左值分析（无指针的），并通过之前所有测例。 然后搭建类型检查的框架（无指针的），并通过之前所有测例。 最后，加入指针，并且适当修改你的左值分析和类型检查。完整支持本节引入的所有新特性，通过相关测试 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step12/guide.html":{"url":"docs/step12/guide.html","title":"实验指导","keywords":"","body":"step12 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 如果你是手写分析，参见这里。 名称解析 名称解析没有变化。 另外，step12 引入解引用操作符以后，左值的概念更加复杂，因此需要增加 左值分析 1， 排除 1+2=3 或 &(1+2) 这种代码，并且为后续阶段生成左值地址提供信息。 请看左值文档。 左值分析可以放到名称解析中，当然你愿意也可以放到其他阶段或作为一个独立的阶段。 类型检查 step12 开始，要增加一个新阶段：类型检查（type checking）；它在名称解析和 IR 生成之间。 它用于（一）完成和表达式类型相关的一大类语义检查，例如 11.4 和 11.5；（二）计算表达式的类型信息，提供给后续阶段使用。 这一大类的语义检查互相联系很紧密，所以它们被拿出来单独作为一个阶段。 类型检查的阶段文档请看类型检查 当然，指导书上划分的也是逻辑阶段，实现中不必严格遵循。有的助教代码中是 IR 生成和类型检查糅在一起做的。 IR 生成 无须新增 IR 指令。 新语言特性的支持分别需要 对于赋值，和 step5 一样：生成 = 右边的值和左边左值的地址，然后 store。 对于取地址 &，生成其操作数左值的地址作为其值。 解引用 * 的 IR 就是子表达式的 IR 接上一个 load。 类型转换只对类型检查有用，类型转换表达式的 IR 就是被转换的子表达式的 IR。 在实际中，类型转换（cast）可能导致真正的值转换（conversion），例如 (int) 4.5 == 4 就需要生成四舍五入的代码。 汇编生成 无须修改。 思考题 为什么类型检查要放到名称解析之后？ MiniDecaf 中一个值只能有一种类型，但在很多语言中并非如此，请举出一个反例。 在本次实验中我们禁止进行指针的比大小运算。请问如果要实现指针大小比较需要注意什么问题？可以和原来整数比较的方法一样吗？ 总结 本节概念不少，代码也相当多，你需要实现左值分析和类型检查。 备注 1. 这个名字是我们自己取的，但名称解析（name resolution）以及类型检查（type checking）都是约定俗成的专用术语。 ↩ "},"docs/step12/lvalue.html":{"url":"docs/step12/lvalue.html","title":"左值","keywords":"","body":"左值 step5 已经提过，赋值表达式中 = 左边必须是左值（lvalue），不能 1+3 = 5， 但当时我们直接在语法上限定了这个条件，没有深入讨论左值。 而 step12 中 & 的操作数也必须是左值，&(2+3) 是没有意义的， 但语法上已经没有这个的保证了 因此 lvalue 的 l 除了 left，又有人说是 location 的意思。 因为比起“能出现在赋值 = 的左边”，左值更本质的特征是，左值是一个 有地址的值（所以才能 &）。 一些例子如： int a; int* p; a = 1; // a 是左值； 1 不是 *&a = 2; // *&a 是左值； 2, &a 不是 p = &a; // p, a 都是左值； &a 不是 *p = 3+a; // *p 是左值； 3, a, 3+a 都不是 由上容易看出： 左值作为操作数时，进行操作需要的是 它的地址； 例如上面 a=1 不需要读取 a 的值，但需要 a 的地址以便把 1 保存到该地址。 非左值（即“右值”，像几个常量和最后一行的 a），操作需要知道的是 它的值； 例如上面 3+a 需要的是 a 的值（对 a 的地址做 load 操作就能加载到 a 的值）。 一个表达式（例如 a）可能有时是左值有时不是，取决于它出现在哪儿。 接着上面第 3. 点说，一个表达式要是左值，需要满足两个条件： 能利用如下规则（语义规范 11.1）构造出来 被声明过的变量是左值； 如果 e 是左值，那么括号括起的 (e) 也是左值。 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值。 如果程序没有类型错误，则 *e 一定是左值，地址是 e 的值。 出现在需要左值的地方（& 操作数、= 左边） 如果需要左值的地方不是左值（例如 1+2=3），那么就要报错。（语义规范 5.5, 11.3） 和上面说的一样，生成代码的过程中，对于左值要生成它们的地址，右值要生成它们的值。 生成左值地址比较容易： 如果左值是变量，其地址就是变量的地址（一个 frameaddr 或者 globaladdr） 如果左值是解引用得到的 *e，其地址就是 e 的值 （语义规范 11.3）所以 &*e 等价于 e，但它不是左值了 括起的左值 (e) 的地址就是 e 的地址 "},"docs/step12/typeck.html":{"url":"docs/step12/typeck.html","title":"类型检查","keywords":"","body":"类型检查 正如指导书所说，类型检查目的是 完成和表达式类型相关的一大类语义检查，例如 11.4 和 11.5； 计算表达式的类型信息，提供给后续阶段使用。 说类型检查之前，我们先提一下类型。 类型的概念大家都很熟悉了（非形式化地），无非就是一个值的集合； 然后称表达式 e 的类型是 T 当且仅当 e 的值在 T 的集合里。 就 step12 而言，我们只需要在编译器中定义两种类型： 整数 IntegerType()，表示 32 位有符号 int 指针 PointerType(baseType)，表示指向 baseType 的指针 例如 int** 就是 PointerType(PointerType(IntegerType()))。 文档中为了简洁我们会写成前者，但编译器代码中要写后者。 就 step12 而言实现上不需要这么复杂，甚至你可以就用整数表示类型，例如 0 表示 int，3 表示 int***。 一般不推荐这么做，因为这样对于更复杂的语言特性不是很好拓展，例如struct / 函数指针等等的类型。 但是实际上我们最复杂的类型，也只是在step12的基础上加上数组维度，可以用一个(int, 整数列表)的二元组表示step11中任何表达式的类型，所以这也不失为一种可行的做法。 对有兴趣的同学：这里也有一个概念上的区分，“指针类型（PointerType）” 并不是一个 “类型”。 回顾 step1，我们也说过 Integer 不是一个 Token 而是一个 Token 种类（TokenKind）。 同样的，指针类型是类型的类型，每个 PointerType 的实例对象才真正表示一个具体的指针类型。 有一门专门研究类型的理论叫 type theory，其中类型（type）的类型称为 kind，有兴趣的同学可以参考 Types and Programming Languages、Proofs and Types 等书。 在 step11 的某几条类型规则中，其实就蕴涵了上面的思想。 类型检查阶段是由一系列 类型规则 指导进行的，源代码中操作如果需要类型检查，那它需要先声明自己的类型规则。 对于某个操作，其类型规则包含两个部分： 各个源操作数的类型有什么限制； 如果源操作数的类型满足 1.，那么操作的结果（如果有）是什么类型。 一些类型规则的例子如下 加法 + 只能 int 加 int, 结果还是 int。 如果有了指针算术甚至浮点，加法的类型规则会更加复杂。 if 的条件表达式类型必须是 int，没有操作结果。 变量的类型就是它声明给出的类型。 整数字面量的类型就是整数类型。 解引用操作 *e 要求操作数类型 e 是指针类型 T*，结果类型是 T。 指针能执行的操作很有限，见语义规范 11.5 取地址操作符 &e 对源操作数类型没有要求，结果类型是 PointerType(源操作数类型)。 这里假设已经做过左值检查了，另一种选择是把左值检查和类型检查糅在一起。 另外，虽然操作数类型没有要求，但还是要做类型检查，保证操作数内部没有类型错误。 类型转换（cast）对源操作数类型没有要求，结果类型就是转换的目标类型。 函数调用：见语义规范 9.4，结果类型就是函数的返回类型。 类型检查阶段完成后，为了把类型信息传递给后续阶段，AST 中每个表达式结点都要新增一个属性 type 描述它的类型。 不然后续阶段看到 AST 里面的一个“加”，都不知道是整数加、指针算术（step11）还是浮点加，那 IR/汇编 就没法生成了。 我们还是可以使用一个 AST Visitor 实现类型检查，在其中 对于每个操作结点，先对所有子结点类型检查，完成后子结点的 type 就是源操作数的类型。 然后对照这个操作的类型规则，如果源操作数类型不对那么报错，否则计算该结点的 type。 碰到变量声明（包括形参），遍历声明类型子节点，然后设置其变量数据结构的类型。 如果有初始值，对它执行类型检查，如果它的类型和声明的类型不匹配则报错。 "},"docs/step12/manual-parser.html":{"url":"docs/step12/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 新增的两种单目操作和很容易实现，不做赘述。 你需要调整 type()使它能够正确的处理指针类型，一个循环的事，不做赘述。 类型系统 你可以在 parse 阶段一并完成类型检查。 首先，引入类型系统。注意，相关的结构体定义不一定要一样，你可以有自己的定义方式。 enum TypeKind { TY_INT, TY_PTR, }; // 事实上，minidecaf （即便是lab12）不需要这么复杂的类型，你可以仅仅记录指针的重数，请根据自己的理解灵活实现 struct Type { TypeKind kind; // int size; 目前的 minidecaf 中，为一常量 4，lab12 才出现其他长度的类型 // int align; 目前的 minidecaf 中，为一常量 4 Type* base; }; // 注意：Node 的类型的意义是，这个节点所代表的表达式的类型，语句节点没有类型。 struct Node { + Type* ty; // 你可以通过左值计算得到每个节点是不是左值，但真的需要这么复杂吗？ + bool is_lvalue; } // 函数和变量也需要增加类型字段 引入类型比较的函数 bool type_equal(Type*, Type*); 在 parse 的同时计算类型。基础节点（也就是 primary 节点，包含变量、函数调用、数字字面量）返回的类型可以直接确定，其余节点的类型需要根据操作数的类型做计算。比如：如果允许指针加减(这被放在了 lab12 )，那么加法运算的结果可能是整数，也可能是指针，对应节点的类型类似，但是乘法运算一定会返回一个整数。此外还需要在构造节点的同时进行类型检查，具体内容参见这里。 类型计算: Node* factor() { // function call node->ty = fu->ret_ty; // variable node->ty = var->ty; // num node->ty = int_type(); } Node* add() { // 如果允许指针加减，lab11 的加法运算和乘法的类型要求一致，只能计算整数 if(is_integer(node->lexpr) && is_integer(node->rexpr)) { node->ty = int_type(); } } 类型检查： Node* mul() { // 乘法两个操作数必须都是整数 assert(is_integer(node->lexpr) && is_integer(node->rexpr); // 必定产生整数 node->ty = int_type(); } Node* assign() { // 赋值要求双方类型相同 assert(type_equal(node->lexpr, node->rexpr)); // 节点类型就是左操作数或者右操作数的类型 node->ty = node->lexpr->ty; } 类型计算后，你必须保证每一个表达式节点都有正确的类型。类型检查需要在类型出错时报错报错。 此外，对函数的名称解析也需要调整。 左值计算 左值计算可以通过可类型计算相似的方式进行。 强制类型转换 强制类型转换容易与括号表达式（( expr )）相混淆，我们需们需要知道括号后的 token 类型才能作出判断，这里介绍一种作弊的方式：可以不必严格遵循 LL1 的解析方式，我们可以实现一个撤销操作。 void checkout_token(); 功能是与 next_token()相反，这样，我们可以在错误的消耗掉 token 之后回退到之前的状态。 强转可以这样写： Node* cast() { if (parse_reserved(\"(\")) { Type* ty; if(ty = parse_type()) { assert(parse_reserved(\")\")); Node* node = new_cast(unary(), ty); return node; } // 这表明这其实是一个括号表达式，我们应该撤销对于 `(` 的消耗。 // 当然，你也可以在解析 `(` expr `)` 的时候直接跳过对 `(` 的解析。 // 请灵活实现 checkout_token(); } } "},"docs/step12/spec.html":{"url":"docs/step12/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step12 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' | type '*' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!'|'&'|'*') unary | '(' type ')' unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step12 语义规范 11.1 构成左值表达式的必要条件除了能通过 5.5 中两条外新增一条： 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值。 因此 int a; *&a=2; 中 *&a 是左值。 11.2 step12 中类型只有 int 和指针类型。禁止隐式类型转换，但允许显式类型转换，只要不违反其他几条规范。 11.3 & 的操作数必须是左值。 所以 &*e 等价于 e，但它不是左值了 11.4 * 的操作数类型必须是指针类型。 11.5 指针类型的表达式仅能参与如下运算：类型转换、（一元）&、*、（二元）==、!=、=。 指针不得参与乘除模和、一元、比较大小、逻辑运算。step11 会支持算术。 所以 if、条件表达式和循环语句的条件也不能是指针类型的。 11.6 空指针是值为 0 的指针。 因为禁止隐式类型转换，所以空指针字面量必须由 0 显示转换而来，例如 (int*) 0。 判断空指针类似：if (p == (int**)0) ; 或 if ((int)p == 0) ;。 11.7 未对齐的指针是未定义行为。就 MiniDecaf 而言，指针必须对齐到 4 字节边界。 11.8 如果指针类型和被指向的对象的类型不匹配（例如 step11 的数组/指针越界），对这样的指针解引用就是未定义行为。 这样的指针也包含空指针，所以空指针解引用是未定义行为。 所以 int a; int *p = (int*)a; int x=&*p; 没有包含未定义行为，但 int y=*p; 包含了未定义行为。 这里我们其实和 C 不同，C 中只要指针指向的地方的值的类型和指针的不匹配就是未定义行为，但我们只要不解引用都可以。 11.9 条件表达式 : 前后的两个子表达式的类型必须相同，整个条件表达式的类型即为子表达式的类型。 "},"REFERENCE.html":{"url":"REFERENCE.html","title":"参考资料","keywords":"","body":"参考资料 Writing a C Compiler: by Nora Sandler An Incremental Approach to Compiler Construction : by Abdulaziz Ghuloum Monkey: The programming language that lives in books C17 标准草案 N2176（N2176 是 C17 标准正式发布前的最后一版草案，根据 C17 标准的编者之一 Jens Gustedt 的博文，其与 C17 标准相比只有表述上的差异） RISC-V 手册 RISC-V（非官方）汇编指令用法 "}}
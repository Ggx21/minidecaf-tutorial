{"./":{"url":"./","title":"实验简介","keywords":"","body":"MiniDecaf 编译实验 实验概述 MiniDecaf 1 是一个 C 的子集，去掉了如 include/define/多文件/struct 等特性。 这学期的编译实验要求同学通过多次“思考-实现-重新设计”从简单到相对复杂的Minidecaf语言的完整编译器， 能够把 MiniDecaf 代码编译到 RISC-V 汇编。 从而能够理解并解决编译真实的程序设计语言时遇到的问题，并能与编译的原理进行对照。 下面是 MiniDecaf 的快速排序，和 C 是一样的 int qsort(int *a, int l, int r) { int i = l; int j = r; int p = a[(l+r)/2]; while (i p) j = j - 1; if (i > j) break; int u = a[i]; a[i] = a[j]; a[j] = u; i = i + 1; j = j - 1; } if (i l) qsort(a, l, j); } 如目录所示，MiniDecaf 实验分为六大阶段，由十二个小步骤组成。 每个步骤，你的任务都是把 MiniDecaf 程序编译到 RISC-V 汇编，并能在QEMU硬件模拟器上运行。 每步做完以后，你都有一个完整能运行的编译器。 随着实验一步一步进行，MiniDecaf 语言会从简单变复杂，每步都会增加部分的语言特性。 实验的关键目标是理解和掌握编译器的设计与实现方法，并能与编译原理课程的知识互补与相互印证。 我们提供一系列的参考实现，包含 Python/Rust/Java/C++ 的。 同学遇到困难可以分析了解参考实现、也可以复用他们的代码。不论同学采用那种方式，都希望能达到实验目标。 编译器边边角角的情况很多，所以你的实现只要通过我们的测例就视为正确。 实验提交 你需要使用 git 对你的实验做版本维护，然后提交到 git.tsinghua.edu.cn。 大家在网络学堂提交帐号名后，助教给每个人会建立一个私有的仓库，作业提交到那个仓库即可。 关于 git 使用，大家也可以在网上查找资料。 每次除了实验代码，你还需要提交 实验报告，其中包括 指导书里面思考题的回答 声明你参考以及复用了谁的代码 晚交扣分规则 是： 晚交 n 天，则扣除 n/15 的分数，扣完为止。例如，晚交三天，那你得分就要折算 80%。 备注 1. 关于名字由来，往年实验叫 Decaf，所以今年就叫 MiniDecaf 了。不过事实上现在的 MiniDecaf 和原来的 Decaf 没有任何关系。 ↩ "},"docs/log.html":{"url":"docs/log.html","title":"更新日志","keywords":"","body":"更新日志 2020.08.29：讨论准备实验帮助文档的改进，开始进行实验帮助文档v0.2 2020.08.26：完成实验帮助文档v0.1，进行文档review 2020.08.19：讨论准备实验帮助文档和分工 2020.08.15：各位助教基于不同的编程语言进一步完善改进基于v2的step1-12 2020.08.05：大致确定实验方案，确定目标语言的语法规范v2，设计基于v2的step1-12 2020.08.01：开始进行基于目标语言的语法规范v1的step，部分助教基于不同编程语言完成基于v1的step1~15的大部分 2020.07.29：大致确定实验方案，不限定实现编译器的编程语言和词法/语法解析方法，确定目标语言的语法规范v1，设计基于v1的step1-15，设定汇编语言 2020.07.20：minidecaf实验准备，方案设计 "},"docs/lab0/env.html":{"url":"docs/lab0/env.html","title":"环境配置","keywords":"","body":"环境配置 必做：RISC-V 的 gcc 和 qemu 我们的编译器只生成 RISC-V 汇编，但是提供预编译的 gcc 和 qemu 模拟器。 gcc 用来把 C 编译到汇编、以及把汇编变成 RISC-V 可执行文件；qemu 用来运行 RISC-V 可执行文件。 不过我们提供的 gcc 和 qemu 只能在 Linux/Mac 下运行，Windows 的同学 可以使用 WSL，或者运行一个虚拟机。 关于 WSL / 虚拟机使用，以及 Linux 基础操作，大家可以自己在网上查找资料。 你的编译器 gcc qemu MiniDecaf 源文件 ------------> RISC-V 汇编 -----> 可执行文件 --------> 输出 这一步的环境配置指南 Windows 用户 暂不支持 Windows，请自行配置好 WSL / 虚拟机。 Linux 用户 从网络学堂下载 riscv-prebuilt.tar.gz 压缩包并解压（命令是 tar xzf riscv-prebuilt.tar.gz） 安装工具链 cp riscv-prebuilt/* /usr/ -r 在第 2. 步，你可以选择不安装到系统目录下。相应的，你需要设置环境变量： export PATH=$PATH:/path/to/riscv-prebuilt/bin，把 /path/to 替换为你的解压目录 执行下面命令测试你 gcc 和 qemu 是否成功安装 1： 创建 test.c 文件，其中写入如下内容 #include int main() { printf(\"Hello world!\\n\"); } 编译 test.c 文件，gcc 应该输出一个可执行文件 a.out。但 a.out 是 RISC-V 可执行文件，所以我们的 X86 计算机无法运行。 $ riscv64-unknown-elf-gcc test.c $ ls a.out a.out $ ./a.out bash: ./a.out: cannot execute binary file: Exec format error 使用 qemu 执行 a.out $ qemu-riscv64 a.out Hello world! macOS 用户 从这里下载预编译好的 RISC-V 工具链并解压。 由于 macOS 不支持 QEMU 的用户态模式，我们使用 Spike 模拟器和一个简易内核 riscv-pk 提供用户态程序的运行环境。网络学堂上提供了我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz。你也可以使用 Homebrew 安装 Spike 2： $ brew tap riscv/riscv $ brew install riscv-isa-sim （可选）设置环境变量，以便每次使用时不需要输入完整路径。 测试你 GCC 和 Spike 是否成功安装，详见RISC-V 的工具链使用。 推荐：参考实现的环境 我们强烈推荐你选择一个参考实现，并且先测试运行（见下一节）一下，为此你需要配置参考实现的环境。 现在已有如下的参考实现，请根据自己的喜好选择一个，git clone 到本地，然后按照它的 README 配置好它的环境。 Python-ANTLR 地址 https://github.com/decaf-lang/minidecaf/tree/md-dzy clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-dzy Rust-lalr1 地址 https://github.com/decaf-lang/minidecaf/tree/mashplant clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b mashplant Rust-manual 地址 https://github.com/decaf-lang/minidecaf/tree/md-cy clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-cy Java-ANTLR 地址 https://github.com/decaf-lang/minidecaf/tree/md-xxy clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-xxy C++-ANTLR 有两个，第一个： 地址 https://github.com/decaf-lang/minidecaf/tree/md-tsz clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-tsz 第二个： 地址 https://github.com/decaf-lang/minidecaf/tree/md-zj clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-zj C++-manual 地址 https://github.com/decaf-lang/minidecaf/tree/md-zyr clone 命令：git clone git@github.com:decaf-lang/minidecaf.git -b md-zyr 备注 1. 开头的 $ 表示接下来是一条命令，记得运行的时候去掉 $。例如，让你运行 $ echo x，那你最终敲到终端里的是 echo x（然后回车）。如果开头没有 $，那么这一行是上一条命令的输出（除非我们特别说明，这一行是你要输入的内容）。 ↩ 2. Homebrew 也提供了 riscv-pk，不过那是 64 位的，而我们预编译的是 32 位的。 ↩ "},"docs/lab0/testing.html":{"url":"docs/lab0/testing.html","title":"运行测试样例","keywords":"","body":"运行测试样例 测试相关的文件在 minidecaf-tests 里面，其中 examples/ 是各个步骤的输入输出，测试脚本是 check.sh。 测试的运行步骤 如下 用 git clone 把 minidecaf-tests 和一个参考实现克隆到同一个目录下面。 进入 minidecaf-tests/，修改 check.sh 的 gen_asm，根据你选择的参考代码反注释某条命令 [可选] sudo apt install parallel 安装 parallel 以便并行测试，测试时间可缩短百分之七八十 [可选] 修改 check.sh 里面的 JOBS，控制要运行哪些测试点 运行 ./check.sh 即可。 测试运行的 输出结果 如下，OK 表示通过，FAIL 表示输出不对，ERR 表示编译错误。 $ ./check.sh gcc found qemu found parallel found OK testcases/step1/multi_digit.c OK testcases/step1/newlines.c ...... 其他测试点，太长省略 OK testcases/step12/matmul.c OK testcases/step12/quicksort.c "},"docs/lab0/riscv.html":{"url":"docs/lab0/riscv.html","title":"RISC-V 的工具链使用","keywords":"","body":"RISC-V 相关信息 RISC-V 是一个 RISC 指令集架构，你实现的编译器要编译到 RISC-V 汇编。 指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"。 RISC-V 工具使用 我们提供预先编译好的 RISC-V 工具，在环境配置中已经叙述了安装和使用方法。 下面汇总一下。 注意，我们虽然是用的工具前缀是 riscv64， 但我们加上参数 -march=rv32im -mabi=ilp32 以后就能编译到 32 位汇编 1。 使用时记得加这个参数，否则默认编译到 64 位汇编。 gcc 编译 input.c 到汇编 input.s，最高优化等级 # input.c 的内容 $ cat input.c int main(){return 233;} # 编译到 input.s $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c # gcc 的编译结果 $ cat input.s .file \"input.c\" .option nopic .attribute arch, \"rv32i2p0_m2p0\" .attribute unaligned_access, 0 .attribute stack_align, 16 .text .section .text.startup,\"ax\",@progbits .align 2 .globl main .type main, @function main: li a0,233 ret .size main, .-main .ident \"GCC: (SiFive GCC 8.3.0-2020.04.0) 8.3.0\" gcc 编译 input.s 到可执行文件 a.out # input.s 的内容，就是上面汇编输出的简化版本 $ cat input.s .text .globl main main: li a0,233 ret # 编译到 a.out $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 input.s # 输出结果，能看到是 32 位的 RISC-V 可执行文件 $ file a.out a.out: ELF 32-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped *【Linux 用户】qemu 运行 a.out，获取返回码 # 运行 a.out $ qemu-riscv32 a.out # $? 是 qemu 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 *【macOS 用户】Spike 模拟器运行 a.out，获取返回码 # 运行 a.out $ spike --isa=RV32G /path/to/pk a.out bbl loader # $? 是 spike 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 1. 这里的 rv32im 表示使用 RV32I 基本指令集，并包含 M 扩展（乘除法）。本实验中我们不需要其他扩展。 ↩ "},"docs/lab0/ir.html":{"url":"docs/lab0/ir.html","title":"中间代码","keywords":"","body":"中间代码 中间代码(Intermediate Representation, IR)是表示程序结构的一种方式，在后续的实验中，我们会先由AST生成IR，再由IR生成汇编代码。尽管直接由AST生成汇编代码在我们的实验中也是完全可行的，但是保留这个中间步骤更加符合真实的编译器的工作流程。一般真实的编译器都有IR这个中间步骤，这是因为IR一般比AST更加接近汇编，同时仍然保存了一些程序中的高级信息，更加适合进行各种优化。 IR有很多种类，包括三地址码(Three Address Code, TAC)，静态单赋值形式(Static Single Assignment Form, SSA)，基于栈的IR，等等。如果你感兴趣的话可以自行查阅了解，这里不做要求。 我们的教程选择使用基于栈的IR。这种IR的最大特点是中间代码生成和汇编代码生成(不追求性能的话)非常容易编写，但是一般实际的编译器都不会使用它，因为它并不适合进行优化1，这样其实也就失去了IR存在的根本意义之一了。尽管如此，我们这个教学用的编译器还是选择使用基于栈的IR，主要目的是希望体现IR这个结构在实际的编译器中的地位，尽量让大家体会感受编译器的工作流程，只是限于课程的工作量的限制还是没法和实际的编译器做到真正的一致。 基于栈的IR顾名思义需要维护一个运算栈，它最主要的特点在于它的运算指令，例如加法和减法指令这些，是没有显式的操作数的。例如在编程语言中常常会写a = b + c，这里的b和c就是加法操作的操作数，而基于栈的IR中则不存在这样的结构，相当于只用一个加号来表示加法，不给出这个加法的操作数。这样的的运算指令的语义都是从这个运算栈的顶部弹出操作数，进行运算后再把结果压回栈中。 例子：一加到一百 在之后的每个step中，我们都会介绍(我们推荐的)加入IR的新指令。尽管如此，这里为了给大家留下一些直观的印象，还是先定义一套简单的基于栈的IR，并且用它表示一个简单的例子：计算一加到一百的和。 定义如下指令： PUSH x: 往运算栈中压入常数x LOAD var: 将变量var的值读出，压入栈中 STORE var: 从栈顶弹出一个值，写入变量var LABEL l: 定义一个名为l的标号 BZ l: 从栈顶弹出一个值，如果该值等于0，则跳转到标号l执行，否则继续执行下一条指令 B l: 无条件跳转到标号l执行 CMP_LE/ADD: 两条二元运算指令，从栈上依次弹出两个值，分别作为右操作数和左操作数，执行整数二元运算/+，将结果压入栈中 有几点可能是比较容易引起疑惑的，这里简单解释一下： 很多指令(其实是除了CMP_LE/ADD之外的所有指令)都有额外的参数，看起来不符合上面说的\"运算指令没有显式的操作数\"的特点。可以理解成\"运算指令\"指的就是CMP_LE/ADD这样的狭义地进行计算操作的指令，其他的都不属于运算指令。 上面提到了\"变量\"的概念，变量是保存在哪里的呢？假如要把这个IR最终翻译成汇编，运算栈显然会用栈来实现，而局部变量其实也只能保存在栈上，虽然保存在很接近的物理区域，但是它们逻辑上并不是运算栈的一部分，对局部变量的写入不应该影响到运算栈，在运算栈上进行的弹栈/压栈操作也不应该影响到局部变量。 上面提到的var，l这样的名字，实际实现的时候基本都是用整数来表示，而下面的程序中为了清晰起见，还是用人可读的名字来表示。 下面我们用这个IR来表示如下的C程序： int sum = 0; int i = 1; while (i 转化的结果如下(#后的是注释)： PUSH 0 STORE sum # int sum = 0; PUSH 1 STORE i # int i = 0; LABEL loop LOAD i PUSH 100 CMP_LE # 计算i 我们有一个 ir.py（代码）能运行上面程序，结果的确是 1+2+...+100=5050. $ python3 ir.py 5050 标有*和**的两条指令在i = 50时执行前后的状态变化如下： 这里局部变量sum和i的保存位置就和上面描述的差不多，与运算栈保存在接近的物理区域，但是二者互不干扰。 执行ADD前，运算栈上恰好有两个元素，也就是前两条指令依次压入栈中的sum和i的值，当前栈顶的值是i的值50。执行ADD时，将这两个值依次弹出，栈顶的值作为右操作数，栈顶下的一个值作为左操作数，执行加法得到1226，再把1226压回栈中，执行完后运算栈上恰好有一个元素1226。 执行STORE sum时，将栈顶的1226弹出，存入sum所在的位置，执行完后sum的值被更新为1226，运算栈为空。 备注 1. 类似Java Bytecode这样的，虽然也属于基于栈的IR，但是实际的Java虚拟机中都会先把它转化成其它容易优化的形式，所以它的意义仅仅是便于生成和传输，几乎不会用于优化。这也启示我们，尽管我们选择了不容易优化的基于栈的IR，但未来还是有拓展的空间，可以把它转化成其他形式再进行优化。 ↩ "},"docs/lab1/part0-intro.html":{"url":"docs/lab1/part0-intro.html","title":"摘要","keywords":"","body":"Lab1：整数 这是关于编写minidecaf编译器的第一个步骤。 编写minidecaf编译器是参考了使用Abdulaziz Ghuloum的An Incremental Approach to Compiler Construction和Nora Sandler的Writing a C Compiler作为路线图。这里的minidecaf语言基本上是C语言的一个子集。你通过从编译minidecaf源语言的一个微不足道的子集开始，能够生成RISC-V汇编代码，并能在RISC-V机器（目前是基于QEMU模拟器）上运行/测试你写的编译器生成的最终机器代码。然后你再一步一步地添加新的语言特性。在第一步中，你只是返回常量；在后面的步骤中，你处理加法和减法；以此类推。每一步都小到足以让人感觉到易于管理，而在每一步结束时，你都有一个可以工作的编译器。另外，通过足够详尽的测试程序，你可以随时验证你的编译器在每次更新后是否正常工作。 前言 在你开始之前，你需要决定两件事：用什么语言来写你的编译器，以及如何处理词法分析（lexing）和语法解析（parsing ） 。你可以用任何你喜欢的语言来实现编译器 提示：建议使用具有和sum type和模式匹配（ pattern matching）的语言，比如OCaml、Haskell或Rust。如果你这样做的话，构建和遍历一个AST会变得更加简单。前提是你能接受学习和掌握这些编程语言的所投入的时间与精力。 你还需要决定是自己写语法解析器和词法分析器，还是使用自动解析器和扫描器生成器（例如flex，bison，antlr4）。在整个实验环节中，两种方式都会提供。我们将展示如何手工编写一个词法器（或扫描器）和递归下降解析器。使用解析器生成器可能更容易，缺点是了解底层运行细节和调试bug可能会困难一些。如果能够直接设计实现解析器生成器，那么对编译课上讲的很多原理、算法的理解会更加深入。 注意：设计实现解析器生成器不是基本实验要求。 本阶段我们将编译一个返回单个整数的minidecaf程序。我们还将建立编译器的三个基本阶段（pass）：词法、解析和代码生成。。第一步将有比较大的工作量，即建立了一个编译器的框架，该框架将使以后添加更多语言特性变得容易，对后续实验步骤有较大的帮助， 下面是一个我们要编译的程序 return_2.c int main() { return 2; } 我们将只处理有一个函数 \"main \"的程序，它由一个返回语句组成。唯一不同的是返回的整数的值，我们不会处理十六进制或八进制的整数，只处理十进制。我们不会处理十六进制或八进制的整数，只处理十进制。为了验证你的编译器是否正常工作，你需要编译一个程序，运行它，并检查它的返回代码。 $ YOUR_COMPILER return_2.c # 用例的编译器会把return_2.c编译为 return.s 汇编程序 $ riscv64-unknown-elf-gcc return_2.s -o return_2 # riscv-64汇编器把return.s翻译为return_2执行程序 $ qemu-riscv64 ./return_2 # 用QEMU for riscv-64硬件模拟器运行return_2执行程序 $ echo $? # 检查return_2执行程序的执行结果，应该是 2 2 你的编译器会产生risc-v汇编代码。我们不会自己将汇编文件转化为可执行文件--那是汇编器和链接器的工作（最好有个链接介绍汇编器和连接器）。为了看看这个程序在汇编中的样子，让我们用GCC来编译它。 $ riscv64-unknown-elf-gcc -S -O3 return_2.c $ cat return_2.s .file \"return_2.c\" ...... .globl main .type main, @function main: li a0,2 ret ...... 现在，让我们看看汇编程序本身。我们可以忽略.section、.align等指令，这些汇编原语可参加这里的介绍。--如果你删除它们，你仍然可以生成并运行return_2执行程序。.globl main表示main符号应该对链接器可见，否则它找不到程序的入口点。 最后，我们有了实际的汇编指令。 main: ; label for start of \"main\" function movl $2, %eax ; move constant \"2\" into the a0 register ret ; return from function 这里最重要的一点是，当一个函数返回时，a0寄存器将包含其返回值。main函数的返回值将是程序的退出代码。在上面的汇编片段中，唯一可以改变的是返回值。 注意：每当你在阅读汇编时，请确保你知道它使用的是什么语法! "},"docs/lab1/part1-parse.html":{"url":"docs/lab1/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 词法解析 词法分析器（也叫扫描器或标记器）是编译器的一个阶段，它将一个字符串（源代码）分解成一个标记列表（token list）。一个标记（token）是语法解析器（parser）能够理解的最小单位。如果一个程序就像一个段落，那么标记就像一个个单词（许多标记是用空格隔开的独立的单词）。变量名（variable names）、关键字（keywords）、常量（constants）以及像括号（braces）这样的标点符号都是标记的例子。 下面是词法分析器（lexer）需要识别的所有标记，以及定义每个标记的正则表达式（regular expression）。 Open brace { Close brace } Open parenthesis \\( Close parenthesis \\) Semicolon ; Int keyword int Return keyword return Identifier [a-zA-Z]\\w* Integer literal [0-9]+ 直接使用 \"keyword\" 这样统一的一个标记类型（token type），而不是为每个关键词使用不同的标记类型也是一种可行的方法。 语法解析 我们需要一个形式化的语法，它定义了一系列标记如何组合成语言构造。我们将基于Backus-Naur Form来定义： ::= ::= \"int\" \"(\" \")\" \"{\" \"}\" ::= \"return\" \";\" ::= 上面的每一行都是一个产生式（production ），定义了如何从一种形式语言（BNF）的构造和标记来建立另外一个语言（minidecaf）的构造。每一个出现在产生式左侧的符号（即、、）都是一个非终结符（non-terminal symbol）。个别标记（keywords、id、punctuation等）是终结符（terminal symbols）。请注意，虽然这个语法告诉我们什么样的标记序列构成了一个有效的minidecaf程序，但它*没有告诉我们到底如何将这个程序转化为AST--例如，在AST中没有对应Constant节点的产生式。我们可以重写我们的语法，让常量有一个产生式，但这不是必须的。 现在的语法非常简单，每个非终结符只有一条产生式。在后续试验中，一些非终结符将有多个产生式。例如，如果我们增加了对变量声明的支持，我们就可以有以下的产生式。 ::= \"return\" \";\" | \"int\" \"=\" \";\" 下一步是将我们的标记列表转化为抽象的语法树（Abstract Syntax Tree，简称AST）。AST是表示程序结构的一种方式。在大多数编程语言中，像条件和函数声明这样的语言结构是由更简单的结构组成的，比如变量和常量。AST捕捉到了这种关系；AST的根将是整个程序，而每个节点将有子节点代表它的组成部分。 现在，我们需要支持的AST节点只有程序（programs）、函数声明（function declarations）、语句（statements）和表达式（expressions）。对于一个可以返回正整的main函数，下面我们给出AST节点的定义： program = Program(function_declaration) function_declaration = Function(string, statement) //string is the function name statement = Return(exp) exp = Constant(int) 现在，一个程序由一个函数main组成。在后面的步骤中，我们将把一个程序定义为一个函数列表。一个函数有一个名称（name）和一个函数体（body）。以后，一个函数还会有一个参数列表（list of arguments）。在实际的编译器中，我们还需要存储函数的返回类型（return type），但现在我们只有整数类型。函数体中只包含一条单一的语句（后续会扩展为语句列表）。语句的类型只有一种：返回语句（return statement）。以后我们会增加其他类型的语句，比如条件（conditionals）和变量声明（variable declarations）。一个返回语句有一个子语句，即表达式--这就是被返回的值。现在一个表达式只能是一个整数常量。以后我们会让表达式包含算术运算，这将使我们能够解析像return 2+2;这样的语句。 当我们添加新的语言结构时，我们会更新AST节点的定义。例如，我们最终会添加一种新的语句类型：变量赋值。当我们这样做的时候，我们会在我们的statement定义中添加一个新的形式。 statement = Return(exp) | Assign(variable, exp) 以一个最简单的程序为例： int main() { return 2; } AST如下所示： Program Function (name: main) body return statement constant (value: 2) 最后， 递归下降解析 为了将一个标记列表转化为AST，我们将使用一种叫做递归下降解析的技术。我们将定义一个函数来解析语法中的每个非终结符，并返回一个相应的AST节点。解析符号S的函数应该从列表的开头删除标记，直到它到达S的有效派生。如果在它完成解析之前，碰到了一个不在S的产生式中的标记，它应该失败。如果 S 的产生式规则包含其他非终结符，它应该调用其他函数来解析它们。 下面是解析语句的伪代码。 def parse_statement(tokens): tok = tokens.next() if tok.type != \"RETURN_KEYWORD\": fail() tok = tokens.next() if tok.type != \"INT\" fail() exp = parse_exp(tokens) //parse_exp will pop off more tokens statement = Return(exp) tok = tokens.next() if tok.type != \"SEMICOLON\": fail() return statement 后面可以发现，产生式是递归的（例如一个算术表达式可以包含其他表达式），这意味着解析函数也将是递归的。因此这种技术被称为递归下降解析。 "},"docs/lab1/part4-codegen.html":{"url":"docs/lab1/part4-codegen.html","title":"代码生成","keywords":"","body":"汇编代码生成 我们选择的目标平台是RISC-V 32，我们可以先看看常见的编译器生成的汇编代码是什么样的： $ riscv32-linux-gnu-gcc return2.c -S -O3 $ cat return2.s .file \"return2.c\" .option nopic .text .section .text.startup,\"ax\",@progbits .align 1 .globl main .type main, @function main: li a0,2 ret .size main, .-main .ident \"GCC: (Ubuntu 7.5.0-3ubuntu1~18.04) 7.5.0\" 其实这里有很多多余的信息，你可以自己尝试一下，只留下最关键的一些表示main函数的信息就可以经由汇编器和链接器生成正确的程序： .globl main main: li a0,2 ret 这里做的事情倒是很直接，就是直接return一个常数了，不过跟我们上面描述的两条指令做到事情还是不太一样。为了能够模拟我们描述的PUSH和RET的操作，还是有必要了解一下RISC-V指令集和相关的调用约定的知识，不过为了减小大家的工作量，这个阶段我们不要求你们去自行查阅，而是把必要的知识都列出来： 我们假定整数都是32位的，因此运算栈中的一个元素占据4字节 我们可以用sp寄存器来表示栈，sp的值就是栈顶，但是这个栈是向地址低的地方生长的，所以如果sp的值减少4，就意味着栈增长了一个元素 我们可以用t开头的寄存器来进行一些临时的数据存储和运算 最终函数的返回值需要保存到a0寄存器中 基础指令 li指令用来加载一个常数到寄存器中 li t0, 3 #t0 = 3 sw指令用来把一个寄存器中的值保存到一个内存地址 sw t0, 4(sp) #地址 sp+4 对应的内存 = t0, 长度为 4 字节 lw指令用来把一个内存地址中的值读入到一个寄存器 lw t0, 4(sp) #t0 = 地址 sp+4 对应的内存, 长度为 4 字节 ret用来执行函数返回 ret #pc 代码生成 代码生成部分的工作是：输入一个 AST，输出汇编代码。我们主要通过遍历 AST 来完成汇编生成，在此过程中，我们可以定义一些 IR 来是的代码生成更加清晰，方便理解。当然你也可以直接生成汇编。因此接下来我们要做的是：AST (--> IR) --> asmmebly。 目前的 AST 中，需要处理的只有 return 语句和数字常量。函数结构的其他部分你可以使用 hard code 去生成，后续涉及到函数等更加复杂的结构我们回去修改。 硬编码模板： .globl : 代码框架 我们通过遍历 AST 来进行 IR 生成或者直接生成汇编代码，接下来的伪代码中 visit(Node node) 代表递归进行该 AST 节点的代码生成，可以使用类似如下的框架进行 AST 遍历。 visit(Node node) { switch(node.node_type) { case RETURN: visitRet(node); break; .... } } 或者如果你使用的语言有继承系统： visit(RET_STMT ret) { visitRet(ret); } 遍历 AST 只需 visit(root) 解析 AST 对 AST 节点的解析往往需要先处理操作数（一定吗？）。以 return 语句为例，我们需要先生成计算汇编返回值的代码，然后再生成 ret。就像这样: visitRet(Node ret_stmt) { visit(ret_stmt.expr); //先计算返回值的值（也就是生成计算操作数的代码） emitReturn(); //生成返回语句汇编代码 } visitConst(Node const) { emitConst(const.val); //生成产生一个常量的汇编代码 } 在当前阶段，我们总是只涉及一个操作数，因此可以可以固定一个寄存器来储存每一步的计算结果。 emitConst(int val) 可以生成这样的代码 (固定将结果储存在 t0 寄存器中)： li t0, {val} #t0 = val 但是这样的设计可拓展性很差，在碰到多个操作数的时候会变得复杂（在lab3我们就会碰到这样的例子）。在栈式机上，每一个操作总是在栈上取出操作数，计算结束后将结果储存回栈中，这样我们所用的寄存器的数量会很少。 emitConst(int val) 在栈式机上，应该生成这样的代码： PUSHI(val); 这是一个IR，其中，PUSHI(val) 代表将一个常量压栈，对应汇编： li t0, {val} addi sp, sp, -4 sw t0, 0(sp) emitReturn() 的作用是：取出栈顶的值（必须保证此时栈顶的值就是想 return 的），返回它。对应 IR： RETURN 对应汇编： lw a0, 0(sp) # 从栈顶读出值到表示返回值的寄存器 add sp, sp, 4 # 栈减小一个元素，这一条和上面一条合起来就是弹出一个元素，并把值赋给a0 ret # 函数返回 最终你为return2.c生成的整个汇编程序可以是这个样子的： .globl main main: li t0, 2 sw t0, -4(sp) add sp, sp, -4 lw a0, 0(sp) add sp, sp, 4 ret 注意，该汇编代码显然是可以优化的，但是不在实验要求之内。 "},"docs/lab1/part4-1-task.html":{"url":"docs/lab1/part4-1-task.html","title":"任务","keywords":"","body":"☑任务： 写一个generate函数，接受一个AST并生成汇编。它可以以字符串的形式在屏幕上显示汇编代码，也可以直接把汇编代码写到文件中。它应该为所有step1测试用例生成正确的汇编码。 ☑ 任务：写一个pretty-print funcion，它接收一个AST并以可读的方式打印出来。 写一个pretty-print的函数，接受一个AST并以可读的方式打印出来。 (可选) 漂亮的打印 你可能需要一个实用函数来打印出你的AST，以帮助调试。你可以现在就写，或者等到你需要的时候再写。下面是对return_2.c的AST输出例子： FUN INT main: params: () body: RETURN Int 这个例子包含了一些AST不需要的信息，比如返回类型和函数参数列表。 ☑任务： 编写一个接受C源文件并输出可执行文件的程序（可以是一个包含调用你写的编译器和GCC的shell脚本）。该程序应该 读取minidecaf源文件 进行词法分析 进行语法解析 生成汇编码 把汇编码写入到一个文件 调用GCC命令，将生成的汇编码转换为可执行文件。在下面命令中，\"assembly.s \"是汇编文件的名称，\"out \"是你想生成的可执行文件的名称。 riscv64-unknown-elf-gcc assembly.s -o out (可选) 删除汇编文件。 "},"docs/lab1/summary.html":{"url":"docs/lab1/summary.html","title":"小结","keywords":"","body":"下一步 在下一步中，我们将增加三个单数运算符。-、~和！。 参考 An Incremental Approach to Compiler Construction Writing a C Compiler "},"docs/lab1alt/part1.html":{"url":"docs/lab1alt/part1.html","title":"第一部分：从零开始的 lexer、parser 以及汇编生成","keywords":"","body":"实验指导 step1：词法分析、语法分析、目标代码生成 第一个步骤中，MiniDecaf 语言的程序就只有 main 函数，其中只有一条语句，是一条 return 语句，并且只返回一个整数（非负常量），如 int main() { return 233; }。 第一个步骤，我们的任务是把这样的程序翻译到汇编代码。 不过，比起完成这个任务，更重要的是你能 知道编译器包含哪些阶段，并且搭建起后续开发的框架 了解基本概念、包括 词法分析、语法分析、语法树、栈式机模型、中间表示 学会开发中使用的工具和设计模式，包括 ANTLR 工具 和 Visitor 模式 词法分析 读内容 *词法分析* MiniDecaf 源文件 --------> 字节流 ----------> Tokens --> ...... --> RISC-V 汇编 词法分析（lexical analysis） 是我们编译器的第一个阶段，实现词法分析的代码称为 lexer ， 也有人叫 scanner 或者 tokenizer。 它的输入 是源程序的字节流 如 \"\\x69\\x6e\\x74\\x20\\x6d\\x61\\x69\\x6e\\x28\\x29\\x7b\\x72\\x65\\x74\\x75\\x72\\x6e\\x20\\x30\\x3b\\x7d\"。 上面的其实就是 \"int main(){return 0;}\"。 它的输出 是一系列 词（token） 组成的流（token stream）1 上面的输入，经过 lexer 以后输出如 [关键字(int)，空白、标识符(main)，左括号，右括号，左花括号，关键字(return)，空白、整数(0)，分号，右花括号]。 如果没有词法分析，编译器看到源代码中的一个字符 '0'，都不知道它是一个整数的一部分、还是一个标识符的一部分，那就没法继续编译了。 为了让 lexer 完成把字节流变成 token 流的工作，我们需要告诉它 有哪几种 token 如上，我们有：关键字，标识符，整数，空白，分号，左右括号花括号这几种 token token 种类 和 token 是不一样的，例如 Integer(0) 和 Integer(222) 不是一个 token，但都是一种 token：整数 token。 对于每种 token，它能由哪些字节串构成 例如，“整数 token” 的字节串一定是 “包含一个或多个 '0' 到 '9' 之间的字节串” 词法分析的正经算法会在理论课里讲解，但我们可以用暴力算法实现一个 lexer。 例如我们实现了一个 minilexer（代码）当中， 用一个包含所有 token 种类的列表告诉 lexer 有哪几种 token（上面第 1. 点）， 对每种 token 用正则表达式描述它能被那些字节串构成（上面第 2. 点）。 细化到代码，Lexer 的构造函数的参数就包含了所有 token 种类。 例如其中的 TokenType(\"Integer\", f\"{digitChar}+\", ...) 就定义了 Integer 这种 token， 并且要求每个 Integer token 的字符串要能匹配正则表达式 [0-9]+，和上面第 2. 点一样。 你可尝试运行 minilexer，运行结果如下（我们忽略了空白） $ python3 minilexer.py Int int Ident main Lparen ( Rparen ) Lbrace { Return return Integer 123 Semicolon ; Rbrace } 本质上，token 是上下文无关语法的终结符，词法分析就是把一个字节串转换成上下文无关语法的 终结符串 的过程。 不过 token 比单纯的终结符多一个属性，就是它的字符串（如 Ident(main) 的 main），你可以说 token 是有标注的终结符。 语法分析 词法分析 *语法分析* 字节流 ----------> Tokens ----------> 语法树 --> ...... --> RISC-V 汇编 语法分析（syntax analysis） 是紧接着词法分析的第二个阶段，实现语法分析的代码称为 parser 。 它的输入 是 token 流 就是 lexer 的输出，例子上面有 如果输入没有语法错误，那么 它的输出 是一颗 语法树（syntax tree） 比如上面的程序的语法树类似 编译原理的语法树就类似自动机的 语法分析树，不同的是语法树不必表示出实际语法中的全部细节。 例如上图中，几个表示括号的结点在语法树中是可以省略的。 语法分析在词法分析的基础上，又把程序的语法结构展现出来。 有了语法分析，我们才知道了一个 Integer(0) token 到底是 return 的参数、if 的条件还是参与二元运算。 为了完成语法分析，肯定要描述程序语言的语法，我们使用 上下文无关语法 描述 MiniDecaf。 就这一步来说，MiniDecaf 的语法很简单，产生式大致如下，起始符号是 prog。 prog : func func : ty Ident Lparen Rparen Lbrace stmt Rbrace ty : Int stmt : Return expr Semicolon expr : Integer 一些记号的区别： 形式语言与自动机课上，我们用大写字母表示非终结符，小写字母表示终结符。 这里正好相反，大写字母开头的是终结符，小写字母开头的是非终结符。 并且我们用 : 而不是 -> 隔开产生式左右两边。 同样的，语法分析的正经算法会在课上讲到。 但我们实现了一个暴力算法 miniparser（代码）。 这个暴力算法不是通用的算法，但它足以解析上述语法。 你可尝试运行，运行结果如下（下面输出就是语法树的先序遍历） $ python3 miniparser.py prog(func(ty(Int), Ident(main), Lparen, Rparen, Lbrace, stmt(Return, expr(Integer(123)), Semicolon), Rbrace)) 前面提到，语法树可以不像语法分析树那样严格。 如果语法树里面抽象掉了程序的部分语法结构，仅保留底下的逻辑结构，那样的语法树可以称为 抽象语法树（AST, abstract syntax tree）；而和语法完全对应的树称为 具体语法树。 当然，AST 和语法树的概念没有清楚的界限，它们也常常混用，不必扣概念字眼。 上面 miniparser 的输出就是一颗具体语法树，而它的抽象语法树可能长成下面这样（取决于设计） $ python3 miniparser-ast.py # 假设有个好心人写了 miniparser-ast.py Prog(funcs=[ Func(name=\"main\", type=(\"int\", []), body=[ ReturnStmt(value=Integer(123)) ]) ]) 目标代码生成 词法分析 语法分析 *目标代码生成* 字节流 ----------> Tokens ----------> 语法树 -----------> RISC-V 汇编 生成 AST 以后，我们就能够生成汇编了，所以 目标代码生成（target code emission） 是第三也是最后一个步骤，这里目标代码就指 RISC-V 汇编。 它的输入 是一颗 AST 它的输出 是汇编代码 这一步中，为了生成代码，我们只需要 遍历 AST，找到 return 语句对应的 stmt 结点，然后取得 return 的值, 设为 X 2 打印一个返回 X 的汇编程序 针对第 1. 点，我们使用一个 Visitor 模式来完成 AST 的遍历。 同样，我们有一个 minivisitor（代码）作为这个阶段的例子。 Visitor 模式比简单的递归函数更强大，用它可以让以后的步骤更方便。 Visitor 模式速成请看 这里 针对第 2. 点，我们用 (RISC-V) gcc 编译一个 int main(){return 233;} 就能知道这个汇编程序什么样。 gcc 的输出可以简化，去掉一些不必要的汇编指令以后，这个汇编程序长成下面这样。 编译方法请看 工具链使用。 汇编代码中，li 加载常数 X 到 a0 寄存器。RISC-V 约定 a0 保存返回值，之后 ret 就完成了 return X 的工作。 .text .globl main main: li a0,X ret 运行 minivisitor，输出就是模板中的 X 被替换为了一个具体整数 $ python minivisitor.py .text .globl main main: li a0,123 ret 至此，我们的编译器就完成了，它由三个阶段构成：词法分析、语法分析、目标代码生成。 每个阶段都有自己的任务，并且阶段和阶段之间的接口很明确：字节流、token 流、AST、汇编代码。 任务 在不同输入上，运行 minilexer, miniparser 和 minivisitor。 浏览它们的代码（不用完全看懂） 思考题 以下思考题六选四，在实验报告中回答。 minilexer 是如何使得 int 被分析成一个关键字而非一个标识符的？ 修改 minilexer 的输入（lexer.setInput 的参数），使得 lex 报错，给出一个简短的例子。 miniparser 的算法，只有当语法满足什么条件时才能使用？ 修改 minilexer 的输入，使得 lex 不报错但 parser 报错，给出一个简短的例子。 一种暴力算法是，只做 lex，然后在 token 流里面寻找连续的 Return，Integer 和 Semicolon，找到以后取得 Integer 的常量 a，然后类似上面目标代码生成。这个暴力算法有什么问题？ 除了我们的暴力 miniparser，形式语言与自动机课中也描述了一种算法，可以用来计算语法分析树。请问它是什么算法，时间复杂度是多少？ 总结 本节引入了概念 Lexer Token Parser 抽象语法树 目标代码生成 Visitor 备注 1. 之所以说“流”而不是“列表”，是因为不一定 lexer 一下就把所有的 token 都拿出来，还可以按照后续阶段的需要按需返回 token。 ↩ 2. 当然，就第一个步骤来说，你直接找到 Integer 节点也可以 ↩ "},"docs/lab1alt/part2.html":{"url":"docs/lab1alt/part2.html","title":"第二部分：词法语法分析工具","keywords":"","body":"实验指导 step1：词法语法分析工具 第一部分中，我们已经自己从零开始暴力实现了一个编译器，接下来我们就来改进它。 第一个方向是： 使用工具完成词法语法分析，而不是自己手写 。 本节内容非必做。 如果你不做，那么你要自己实现 lexer/parser，请直接看任务。 概述 从 minilexer/miniparser 的代码可以看出，lexer 和 parser 包含两部分： 被分析的词法/语法的描述。例如 minilexer 的那个 TokenType 列表，以及 miniparser 的 rules 字符串； lexer 和 parser 的驱动代码。例如 lex 和 parse 函数。 使用工具，我们只需要完成第一步，描述被分析的词法或者语法。 然后工具从我们的描述，自动生成 lexer 或者 parser。 所以这类工具被称为 lexer/parser generator，例子有：C 的 lex/yacc、往届使用的 JFlex / Jacc、mashplant 助教自己写的 lalr1。 对有兴趣的同学：除了这类工具以外，还有一类工具称为 parser combinator，多在函数式语言中使用。 最有名的如 Haskell 的 parsec、scala 的 fastparse，rust 的 nom。课程不涉及其中内容。 ANTLR ANTLR 是一个比较易用的 parser generator，速成文档在这里。 任务 如果你选择使用工具：按照你选择的工具，描述 step1 的 MiniDecaf 词法语法，并从 AST 生成汇编。 如果你不选择使用工具：实现你自己的 lexer 和 parser，并生成汇编。 "},"docs/lab1alt/part3.html":{"url":"docs/lab1alt/part3.html","title":"第三部分：使用中间码","keywords":"","body":"实验指导 step1：使用中间码 我们继续改进上一步我们得到的编译器，这次要做的是： 使用中间码让编译器更模块化。 栈机器和中间表示 词法分析 语法分析 *IR生成* *目标代码生成* 字节流 ----------> Tokens ----------> 语法树 ---------> IR ---------------> RISC-V 汇编 参见 lab0/ir（等待完善）。 容易看出，IR 的好处有如下几点 缩小调试范围，通过把 AST 到汇编的步骤一分为二。 通过观察 IR 是否正确生成就能知道：到底是 IR 生成这一小步有问题，还是 IR 到汇编这一小步有问题。 比起 AST 到汇编当成一整个大步骤，分成两个小步，每步代码更少，更容易调试。 更容易适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, Decaf, C, Java...）。 不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块： 如果有了 IR，只需要写 N 个 IR 生成和 M 个汇编生成，一共 N + M 个模块： 更容易添加不同源语言。 假设同样的 IR 我们使用的 IR 是栈式机 IR，它生成很简单、翻译到汇编也很简单。 当然，就课程实验来说，你不一定非要显式地生成 IR，可以直接从 AST 生成汇编。 但只要按照实验指导书的思路，你一定会使用栈机器的思路思考， 哪怕直接从 AST 生成汇编，也本质上是在用汇编实现 IR。 所以指导书中，会把 IR 单独拿出来，不会直接讨论 AST 如何翻译到汇编。 从 AST 到 IR 词法分析 语法分析 *IR生成* 目标代码生成 字节流 ----------> Tokens ----------> 语法树 ---------> IR ---------------> RISC-V 汇编 显然，这一步的 输入 是 AST， 输出 是一系列 IR 1 例如前面的 int main(){return 0;} 例子，输出如 [const 0, ret] 每步我们只介绍必须的 IR，而不是一股脑全整完。 对于第一步，我们只需要两个 IR 指令：const、ret，如下表。 指令 参数 含义 IR 栈大小变化2 const 一个整数常数 把一个常数压入栈中 增加 1 ret 返回栈顶元素 弹出栈顶元素，将其作为返回值返回当前函数 减少 1 并且我们有如下的假设： 考虑源代码中某个表达式被翻译成了一系列 IR 指令，那么从任何初始状态出发执行这些 IR 指令， 完成后 IR 栈大小增加 1，栈顶就是表达式的值。 执行任何语句对应的 IR 指令序列，执行完成后 IR 栈大小不便。 执行任何 n 元操作之前，栈顶的 n 个元素就是操作数。 由此，step1 中 AST 翻译到 IR 就很简单了。只需要 Visitor 遍历 AST，然后 遇到 Integer(X)：生成一条 const X，栈大小加 1。 遇到 Return expr ;：先生成 expr 对应的 IR，栈大小加 1；然后生成一条 ret，栈大小和原来相同。 IR 翻译到汇编 词法分析 语法分析 IR生成 *目标代码生成* 字节流 ----------> Tokens ----------> 语法树 ---------> IR ---------------> RISC-V 汇编 栈机器 IR 翻译到汇编非常简单，如下表，多条汇编指令用分号隔开： IR 汇编 push X addi sp, sp, -4 ; li t1, t1, X ; sw t1, 0(sp) ret lw t1, 0(sp) ; addi sp, sp, 4 ; jr ra 简要解释：li t1 X 表示加载立即数 X 到寄存器 t1；RISC-V 和 x86 一样栈顶比栈底的地址低，所以压栈 4 字节是栈指针 sp 减 4。 ra 存了调用者地址，jr ra 就是子函数返回。 IR 栈的每个元素都是 32 位整数，所以 push 使得 IR 栈大小加 1 在我们这里就体现为 sp 减 4。 完成后，你对于 int main(){return 0;} 应该生成如下汇编 .text .globl main main: addi sp, sp, -4 li t1, 233 sw t1, 0(sp) lw a0, 0(sp) addi sp, sp, 4 jr ra 任务 （可选，推荐）改进你上一步的代码，先生成 IR，再从 IR 生成汇编。 （和 1. 二选一）改进你上一步的代码，用栈机器的思路生成汇编。 思考题 ANTLR 栈机器 总结 备注 1. 实际上 const 和 ret 是 IR 的 指令。我们为了简便，通常直接用 IR 代指 IR 指令。 ↩ 2. 注意区分 IR 栈和汇编中的栈。IR 的栈中包含的元素是整数，IR 栈的大小指栈中有多少个整数。对于 IR 的栈不存在“字节”这一概念。 ↩ "},"docs/lab1alt/antlr.html":{"url":"docs/lab1alt/antlr.html","title":"ANTLR 使用","keywords":"","body":"ANTLR 使用——以表达式语法为例 使用 ANTLR 工具，我们只需要写出词法和语法分析的 规范（specification）， 然后它会帮我们生成 lexer 和 parser 乃至 visitor，非常方便。 我们用一个简单的表达式语法 1 来介绍 ANTLR，表达式由一系列整数通过加减乘除以及括号构成，例如 (1+3)*4-3-3。 对于 ANTLR，词法和语法分析的规范都写在 .g4 2 文件中，例如我们的表达式的规范是文法: ExprLex.g4和语法: Expr.g4。 无论是词法规范还是语法规范，它们的规范文件结构是一样的，如下。 规范文件中，// 表示注释，规范是大小写敏感的，字符串常量用单引号括起。 开头声明 规范名，需要和文件名一致： ```antlr4 // [ExprLex.g4] 词法规范，用 lexer grammar 标识，行尾有分号。 lexer grammar ExprLex; // [Expr.g4] 语法规范，用 grammar 标识，行尾有分号。 grammar Expr; 2. 然后可能有一些 **规范自身的设置**，见后面 “语法规范” 3. 然后是 **一系列规则**，规则类似上下文无关语法的产生式。 每条规则包含左右两边，用冒号隔开， *左边* 是一个符号，表示 *右边* 可以规约到 *左边* 的符号。 符号分为 **终结符** 和 **非终结符** ，终结符用大写字母打头，非终结符用小写字母。 类似产生式，如果多条规则的左边相同，它们可以合并写在一起，它们的右手边用竖线隔开。 ```antlr4 // [ExprLex.g4] 词法规则，规则末尾有分号。 Integer: [0-9]+; // [Expr.g4] 语法规则，规则末尾有分号 atom : '(' expr ')' // 一个括号括起来的表达式，它可以规约到 atom | Integer // 整数 token 可以规约到 atom ; 词法规范 词法规范描述了 lexer 应该怎么生成，显然词法规范中规则的左边只能是终结符。 除了上面所说的，词法规范还有一点是：规则的右手边是一个正则表达式。 详细用法在这里，一些常见用法如下： // 1. 为了匹配字符串常量，用单引号把它括起来 Lparen: '('; // 2. [0-9] 匹配 (char)'0' 到 (char)'9' 之间任何一个字符，类似其他 regex 的 \\d 或者 [[:digit:]] // 3. 加号 + 表示它前面的片段可以匹配一次或多次，类似有 * 的零次或多次，? 的零次或一次。 // 它们都是贪婪的，会匹配尽量多的次数。和其他 regex 一样，片段可以用 ( ) 分组。 Integer: [0-9]+; // 4. fragment 表示 WhitespaceChar 本身不是一个符号，它只是一个 regex 的片段，lexer 不会产生它的 token。 // 它和 minilexer 中的 whitespaceChar 是一样的。 // 5. [ \\t\\n\\r] 匹配一个空格 (ascii 码 0x20)，或者一个制表符 (0x9)，或者一个换行符 (0xa) 或者一个回车 (0xd) fragment WhitespaceChar: [ \\t\\n\\r]; // 6. Whitespace 匹配输入中的空白。类似 minilexer，\"-> skip\" 表示忽略此终结符，也就是匹配以后不产生对应的 token。 Whitespace: WhitespaceChar+ -> skip; 语法规范 语法规范描述了 parser 应该怎么生成。除了上面说的，还需注意： parser 依赖于 lexer，所以语法规范中需要 导入词法规范// 导入词法规范 import ExprLex; 其实 ANTLR 不要求你分开 lexer 和 parser，你可以直接把 import 语句换成 ExprLex 里面的所有规则， 效果是一样的。 但分开 lexer 和 parser 更干净，并且也方便 lexer 复用。 各种语言虽然语法差别很大，词法（空白、整数、标识符、标点符号等）却没太大差别。 parser 规则的右手边除了符号以外，还可以有 字符串常量。 如果它能被规约到词法规范里某个符号，那它就等价于那个符号； 否则 ANTLR 内部会生成一个临时终结符 T__xxx，它的规则的右边是那个字符串常量。 mulOp : '*' | '/' ; // 等价于 mulOp : Mul | Div ; 你可以手动给 规则命名。 在生成的 AST 里，atom 对应的结点会被分为两类：atomParen 和 atomInteger， 它们拥有的字段不同，也对应不同的 visit 函数。 atom : '(' expr ')' # atomParen | Integer # atomInteger ; 规则其实是用 EBNF (extended Barkus-Naur form) 记号书写的，EBNF 也是描述上下文无关语法的一种方式。 相对普通的上下文无关语法记号，EBNF 允许你在规则内部使用 | 描述选择、* 或 ? 或 + 描述重复，(和) 分组 3。 例如下面的用法： ```antlr4 add // 1. 使用括号分组，分组内部使用 | 描述选择 // 2. 和 EBNF 无关，但 op 是给这个符号的命名，然后 add 的 AST 结点会有一个 op 字段。 : add op=(Add|Sub) mul | mul ; mul // 3. 使用 描述零次或多次的重复。+ 和 ? 类似。 : atom (mul atom) ; 关于 EBNF，再举一个例子：描述零个或多个用逗号隔开的 `expr` 列表，下面两种写法是等价的，但 EBNF 记号更简短。 ```antlr4 // 传统写法 exprList : # emptyExprList | exprList2 # nonemptyExprList ; exprList2 : expr | expr ',' exprList2 ; // EBNF 写法 exprList : (expr (',' expr)*)? ; 运行 ANTLR 安装 ANTLR，设置 CLASSPATH 环境变量，配置 antlr4 和 grun 的 alias 后，运行以下命令 4： $ antlr4 Expr.g4 # 会自动拉取 import 的 ExprLex.g4 $ ls ExprLexer.java ExprParser.java # 默认生成 Java 的 lexer 和 parser，其他文件不用管 ExprLexer.java ExprParser.java $ javac *.java $ echo \"(1+3)*4-3-3\" > input # 输入文件内容是 (1+3)*4-3-3 $ grun Expr expr -gui input # 输出如下图 你可以尝试把最后一步的 -gui 换成 -tokens、-tree 看看。 接下来，我们给出示例代码，叙述如何使用生成的 lexer 和 parser。 Main.java 是 Java 的示例代码。做完上面步骤后，运行 Main： $ java Main main.py 是 Python 的示例代码。为了运行它，除了安装 ANTLR 你还需要安装 Python 的 ANTLR API，见这里。运行方法如下 $ antlr4 Expr.g4 -Dlanguage=Python3 $ ls ExprParser.py ExprLexer.py # 生成了 Python 的 lexer 和 parser ExprLexer.py ExprParser.py $ python3 main.py (expr (add (add (add (mul (atom ( (expr (add (add (mul (atom 1))) + (mul (atom 3)))) )) (mulOp *) (atom 4))) - (mul (atom 3))) - (mul (atom 3)))) Visitor 的使用 ANTLR 默认生成 listener，它允许你在遍历 AST 过程进入结点和离开结点的时候运行一些代码，但我们不用 listener，我们使用 visitor。 首先用参数 -visitor 告诉 ANTLR 生成 visitor 代码。 $ antlr4 Expr.g4 -visitor visitor 代码在 ExprVisitor.java 和 ExprBaseVisitor.java 中。 前者定义接口，后者是默认实现：只遍历、不做其他事。 public class ExprBaseVisitor extends AbstractParseTreeVisitor implements ExprVisitor { @Override public T visitExpr(ExprParser.ExprContext ctx) { return visitChildren(ctx); } // ... } 从上可以看出，ANTLR 的 visitor 和我们的基本一致： visit 函数返回值的类型是 T 他所谓 context 就是 AST 的结点，每个 context 也有一个 accept 函数接受 visitor 但他的 visitor 还自带一个方法 visitChildren：遍历所有子结点。返回最后一个子结点的返回值。 ANTLR 生成的 python visitor 也差不多 $ antlr4 Expr.g4 -visitor -Dlanguage=Python3 visitor 在 ExprVisitor.py 里。 # ExprVisitor.py class ExprVisitor(ParseTreeVisitor): def visitExpr(self, ctx:ExprParser.ExprContext): return self.visitChildren(ctx) # ... MainEval.java 和 maineval.py 通过表达式求值展现了 visitor 的用法，如上编译后如下运行即可。 输出的 10 就等于 (1+3)*4-3-3。 $ python3 mainvisitor.py 常见问题 javac 报错一堆 cannot find symbol 没有设置 CLASSPATH grun 报错 Can't load Expr as lexer or parser 你 antlr4 以后没有编译 java 文件 我的输入是 1+2 ((( 它竟然不报错 ANTLR 不强制消耗整个输入，所以 parser 做完 1+2 就停了。 可以把 expr: add; 改成 expr: add EOF; antlr4 报错 error(31): ANTLR cannot generate python3 code as of version 4.8 -Dlanguage=Python3 的 P 要大写 备注 1. step1 的 MiniDecaf 语法太简单，不能体现很多 ANTLR 的特性。 ↩ 2. g 是 grammar，4 是 ANTLR 的版本号 4。 ↩ 3. EBNF 本身又有很多记号，有的使用 { ... } 表示重复。我们描述的是 ANTLR 的 EBNF 记号。 ↩ 4. 命令从 https://www.antlr.org/ 中 Samples 的内容修改而来 ↩ "},"docs/lab1alt/visitor.html":{"url":"docs/lab1alt/visitor.html","title":"Visitor 模式","keywords":"","body":"Visitor 模式速成 编译器的构造中会使用到很多设计模式，Visitor 模式就是常见的一种。 基础的设计模式都在 OOP 课程中覆盖，这里重提一下 Visitor 模式，顺带介绍一些参考代码用到的 python 技巧。 我们知道，编译器里有很多的树状结构。 最典型的就是，源程序通过上下文无关文法解析后，得到的语法分析树。 Visitor 模式的目的，就是遍历这些树状结构，本质就是一个 DFS 遍历。 下面通过一个例子说明 Visitor 模式。 表达式语法、语法树定义 我们有一个很简单的表达式文法，终结符包括整数和加减乘除模操作符，起始符号是 expr，大致如下 expr -> int | binary int -> Integer binary -> expr '+' expr | expr '-' expr | expr '*' expr | expr '/' expr | expr '%' expr 这个文法有二义性，同样的字符串可能有多个语法分析树。 不过解析字符串、生成语法分析树不是 Visitor 模式的工作。 Visitor 模式只考虑某个确定的语法分析树。 如下面是 20-13*3 的一颗语法分析树 我们在代码里这样定义这个语法分析树（python 3.6）： class Node: pass class IntNode(Node): def __init__(self, v:int): # 类型标注是给人看的，python 不检查 self.v = v def __str__(self): return f\"({self.v})\" # f-string 特性 class BinopNode(Node): _legalOps = { *\"+-*/%\" } # 使用 unpacking operator，等价于 set('+', '-', '*', '/', '%') def __init__(self, op:str, lc:Node, rc:Node): assert op in BinopNode._legalOps self.op, self.lc, self.rc = op, lc, rc def __str__(self): return f\"({self.lc} {self.op} {self.rc})\" # 我们通过某种手段，得到了这么一个语法分析树 expr1 = BinopNode('*', BinopNode('-', IntNode(20), IntNode(13)), IntNode(3)) print(expr1) # (((20) - (13)) * (3)) 我们忽略了 Expr，不过显然这无伤大雅。 表达式求值 显然，每个语法分析树都对应一个（加好括号）的表达式，比如上面的树就对应 (20-13)*3。 那么我们考虑一个问题：如何对这个表达式求值？ 当然，我们可以让 python 帮我们做 print(eval(str(expr1), {}, {}))， 不过我们下面会用 Visitor 模式实现表达式求值。 写 Visitor 之前，我们看自己实现表达式求值的最简单的方法，一个递归遍历： def dfs(node:Node): if isinstance(node, IntNode): return node.v if isinstance(node, BinopNode): lhs = dfs(node.lc) rhs = dfs(node.rc) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs print(dfs(expr1)) # 21 dfs 函数接受一个结点，然后对这个结点代表的子树进行求值，返回求值结果。 容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的求值逻辑。 那么我们把这些求值逻辑封装到一个类里面，就得到了一个最简单的 Visitor。 class EvaluationVisitor: def visit(self, node:Node): if isinstance(node, IntNode): return self.visitIntNode(node) if isinstance(node, BinopNode): return self.visitBinopNode(node) def visitIntNode(self, node:IntNode): return node.v def visitBinopNode(self, node:BinopNode): # 不确定子结点的类型，所以只能调用 visit 而非 visitIntNode 或者 visitBinopNode lhs = self.visit(node.lc) rhs = self.visit(node.rc) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs print(EvaluationVisitor().visit(expr1)) # 21 上面就是 Visitor 的核心思想，实际使用中我们一般会有两点改进 不使用 isinstance 来判断结点类型，而是调用结点自身的一个 accept 函数 把几个 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口 改进后的 Visitor 如下。 class Node: def accept(self, visitor): pass class IntNode(Node): # ... 同上 def accept(self, visitor): return visitor.visitIntNode(self) class BinopNode(Node): # ... 同上 def accept(self, visitor): return visitor.visitBinopNode(self) class Visitor: # 默认行为是遍历一遍，啥也不做，这样比较方便 def visitIntNode(self, node:IntNode): pass def visitBinopNode(self, node:BinopNode): node.lc.accept(self) node.rc.accept(self) class EvaluationVisitor(Visitor): def visitIntNode(self, node:IntNode): # ... 同上 def visitBinopNode(self, node:BinopNode): lhs = node.lc.accept(self) rhs = node.rc.accept(self) # ... 同上 总结 从上面可以看到，Visitor 模式的要素有 被访问的对象。例如上面的 Node。 Visitor 封装的 visitXXX，表示对上述对象实施的操作。例如 EvaluationVisitor。 每种被访问的对象在自己的定义中都有一个 accept 函数，并且在 Visitor 里面也对应一个 visitXXX 函数。 有状态的 Visitor subexpr = BinopNode('-', IntNode(20), IntNode(13)) expr1 = BinopNode('*', subexpr, IntNode(3)) 显然，表达式求值的过程中，所有子表达式也都会被求值。 如上，求值 expr1 的过程中，subexpr 也也会被求值。 我们想把子表达式的值记录下来，以后直接使用，就不需要对子表达式重新求值了。 为了实现这点，还是使用上面的 EvaluationVisitor，但我们用一个字典 Node -> int 记录求值结果，并且把字典作为 Visitor 的状态。 class EvaluationVisitor2(Visitor): def __init__(self): self.value = {} # Node -> int 每次 EvaluationVisitor2.visitXXX(self, node) 返回的时候，我们都记录一下 self.value[node] = value，其中 value 是返回值。 我们用一个函数修饰器来完成记录的动作，如下 class EvaluationVisitor2(Visitor): def __init__(self): self.value = {} # Node -> int def SaveValue(visit): # decorator def decoratedVisit(self, node): value = visit(self, node) self.value[node] = value return value return decoratedVisit @SaveValue def visitIntNode(self, node:IntNode): return node.v @SaveValue def visitBinopNode(self, node:BinopNode): lhs = node.lc.accept(self) rhs = node.rc.accept(self) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs subexpr = BinopNode('-', IntNode(20), IntNode(13)) expr1 = BinopNode('*', subexpr, IntNode(3)) visitor = EvaluationVisitor2() expr1.accept(visitor) print(visitor.value[subexpr]) # 7 print(visitor.value[expr1]) # 21 "},"docs/lab2/part0-intro.html":{"url":"docs/lab2/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab2/part1-parse.html":{"url":"docs/lab2/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 词法解析 在本实验中，我们将增加三个一元运算符（unary operators，即只对一个值操作的运算符）：取负(-)：按位取反(~)、逻辑否（！）。我们只需要将这些操作符分别添加到我们的标记列表中。添加后的标记列表如下所示： Open brace { Close brace } Open parenthesis \\( Close parenthesis \\) Semicolon ; Int keyword int Return keyword return Identifier [a-zA-Z]\\w* Integer literal [0-9]+ Negation - Bitwise complement ~ Logical negation ! 我们可以像处理其他单字符标记一样，以完全相同的方式处理这些新的标记，比如大括号和圆括号。 语法解析 现在，一个表达式可以有两种形式之一。它可以是一个常量，或者是一个一元运算。一元运算由运算符（如~）和操作数组成，操作数本身就是一个表达式。例如，以下是我们如何构造表达式~3。 c = Const(3) exp = UnOp(COMPLEMENT, c) 我们对表达式的定义是递归的，表达式可以包含其他的表达式。因此，我们的语法需要更新。 ::= ::= \"int\" \"(\" \")\" \"{\" \"}\" ::= \"return\" \";\" ::= | // ::= \"!\" | \"~\" | \"-\" // 在AST中，我们将增加另一种类型的表达式，一元运算（unary operations）。下面是对AST节点的定义，只有exp的定义有变化。 program = Program(function_declaration) function_declaration = Function(string, statement) //string is the function name statement = Return(exp) exp = UnOp(operator, exp) | Constant(int) // 因为表达式的定义是递归的，所以解析表达式的函数也应该是递归的。下面是解析一个表达式的伪代码： def parse_expression(tokens): tok = tokens.next() if tok.type == \"INT\": //parse this the same way as before, return a Const node else: op = get_operator(tok) //convert token to unary_op AST element - fail if token isn't \"!\", \"~\" or \"-\" inner_exp = parse_expression(tokens) //HOORAY, RECURSION - this will pop more tokens off the stack return UnOp(op, inner_exp) "},"docs/lab2/part4-codegen.html":{"url":"docs/lab2/part4-codegen.html","title":"代码生成","keywords":"","body":"汇编代码生成 基础 首先介绍本阶段需要用到的汇编指令。 取负（-）和按位非（~）是超级简单的，都可以用一条汇编指令来完成。 neg将操作数取负的值。下面是一个例子。 neg rd, rs #rd = -rs not将操作数按位取反。我们可以用和neg完全一样的方式来使用它。 not rd, rs #rd = ~rs 逻辑非（!）是比较复杂的。记住，return !exp相当于： if (exp == 0) { return 1; } else { return 0; } 但在 riscv 下有一个非常方便的指令，我们可以使用seqz(set equal to zero)来实现它。 seqz rd, rs #rd = (rs == 0) ? 1 : 0; 生成 对于类似 !!~-3 这样一连串的操作，我们总是要先得到操作数，然后才能进行操作，这个式子的计算次序为：取负，按位取反,逻辑取反，逻辑取反。在代码实现上，这是一个递归的过程。 实现取反操作伪代码如下： void visitNeg(Node neg) { visit(neg.operator); #先计算操作数的值，计算完成后，结果应该在栈顶 emitNeg(); #取出栈顶操作数，执行计算，将结果储存回栈 } emitNeg() 可以生成这样的代码： lw t0, 0(sp) add sp, sp, 4 #前两条语句将操作数取出，并置于 t0 寄存器中，类似与 pop neg t0, t0 #执行取反计算，结果储存在 t0 中 sw t0, -4(sp) add sp, sp, -4 #这两条语句完成计算结果的压栈储存，类似于 push 不难发现对 sp 的移动是多余的，可以简化如下： lw t0, 0(sp) neg t0, t0 sw t0, 0(sp) 其他两个操作与 neg 几乎完全一致，最后我们可以得到如下代码： void visitUnary(Node unary) { visit(unary.operator); switch(unary.op) { case NEG: // '-' emitNeg(); return; case BITNOT: emitBitNot(); return; case NOT: // '!' emitLogNot(); return; } } "},"docs/lab2/part4-1-task.html":{"url":"docs/lab2/part4-1-task.html","title":"任务","keywords":"","body":"☑ 任务 更新你的代码生成（code-generation）阶段，为！、~和-操作生成正确的汇编代码。它应该为所有step1和step2示例生成正确的汇编。 "},"docs/lab2/summary.html":{"url":"docs/lab2/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab3/part0-intro.html":{"url":"docs/lab3/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab3/part1-parse.html":{"url":"docs/lab3/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 词法解析 在本实验中，我们需要添加二元运算来支持基本的算术运算。我们将弄清楚如何正确处理运算符的优先性和关联性。需要支持的二元运算包括： 加：Addition + 减：Subtraction - 乘：Multiplication * 除：Division / 取模：Mod % 除了减二元运算符，上面的每一个运算符都需要一个新的标记（我们已经有一个-标记）。不管是减运算符还是否定运算符，它的标记化方式都是一样的；我们将在语法解析阶段弄清楚如何解释它。算术表达式也可以包含圆括号，但我们已经有了圆括号的标记，所以我们不需要改变我们的词法分析器来处理它们。我们修改标记列表以支持新的运算符，新的标记列表如下所示： Open brace { Close brace } Open parenthesis ( Close parenthesis ) Semicolon ; Int keyword int Return keyword return Identifier [a-zA-Z]\\w* Integer literal [0-9]+ Minus - Bitwise complement ~ Logical negation ! Addition + Multiplication * Division / Mod % 语法解析 在本次实验中，我们需要给我们的AST添加另一个表达式类型：二元操作（binary operations）。 直接定义的问题 首先是对语法的定义，以使解析器可以进行解析。最明显的定义是这样的： ::= | | \"(\" \")\" | 但这种语法有几个相关问题。 它没有处理运算符的优先性。考虑表达式2 + 3 * 4。使用上面的语法，你可以构建两种可能的解析树。(2 + 3) * 4 = 24或2 + (3 * 4) = 14。根据C语言标准和数学惯例，*比+具有更高的先验性，所以第二棵解析树是正确的。我们的语法必须以某种方式对这种优先级（precedence）进行编码。这也是我们的一元运算的一个问题--根据这个语法，~2 + 3可以被解析为~(2 + 3)，这当然是错误的。 它不处理结合性（associativity）。同一优先级的操作应从左到右进行评估（evaluate）。例如1 - 2 - 3应该解析为(1 - 2) - 3。但是，根据上面的语法，解析为1 - (2 - 3)也是有效的。 它是左递归（left-recursive）。在上面的语法中，的一个产生式是： ::= 在这个生产式中，最左边（即第一个）的符号也是，这就是左递归的意思。左递归语法并非不正确，但递归下降（Recursive Descent，简称RD）语法解析器无法处理它们。我们将在后面的文章中讨论为什么这是一个问题。 处理优先级 让我们从问题1开始考虑解决方案。我们先处理一元运算符，因为它们的优先级总是比二元运算符高。只有在以下情况下，才应该将一元运算符应用于整个表达式。 表达式是单个整数 (例如 ~4) 表达式被括号包围住(例如~(1+1)) 表达式本身就是一个一元运算（例如~！8，-~(2+2)） 为了表达这一点，我们需要在我们的语法中使用另一个符号来指代 \"一个用一元运算符的表达式\"。我们称它为因子（factor）。我们将这样重写我们的语法： ::= | ::= \"(\" \")\" | | 我们现在已经创建了两个优先级：一个用于二元操作，一个用于一元操作。我们还通过将表达式放在括号内强制执行更高的优先级，来正确地处理括号。 我们可以做类似的改变，使得*和/比+和-具有更高的优先级。我们之前添加了一个符号，代表一元运算的操作数。现在我们将添加一个符号，代表乘法和除法的操作数： ::= (\"+\" | \"-\") | ::= (\"*\" | \"/\") | ::= \"(\" \")\" | | 这个语法正确地编码了运算符的优先级。现在2 + 3 * 4只有一个可能的解析树。 处理结合性 问题2是这个语法没有处理结合性。如果你没有使用递归下降语法解析器，一般来说，你对左结合操作使用左递归生产式，对右结合操作使用右递归产生式。在这种情况下，我们可以这样重写的产生式： ::= (\"+\" | \"-\") | 这将使得加法和减法成为左递归；你不能把1 - 2 - 3解析为1 - (2 - 3)，因为2 - 3不是一个项（term）。 但是我们使用的是递归下降语法解析器，所以我们不能处理这个左递归规则。为了理解为什么这行不通，我们试着写一个函数来根据这个规则解析表达式。 def parse_expression(tokens): //determine which of two production rules applies: // * (\"+\" | \"-\") // * if is_term(tokens): //how do we figure this out??? return parse_term(tokens) else: //recursively call parse_expression to handle it e1 = parse_expression(tokens) //recurse forever ☠️ 要想知道使用哪条产生规则，我们不能只看第一个标记，而需要知道这个表达式中是否有+或-操作。如果我们确定这个表达式是一个求和（sum）或求差（difference），我们就会永远递归地调用parse_expression函数。为了不这样做，我们需要找到表达式末尾的最后一个，解析并删除它，然后再回过头来解析剩下的内容。这两个问题（找出使用哪条生产式，以及解析最后一个term）都需要我们向前看一个任意数量的标记，直到找到表达式的结尾。你也许能让这种方法发挥作用--如果有类似的现有解析算法--它应该也会很复杂低效，而且不会是一个递归下降解析器。所以我们不打算这么做。 另一方面，如果我们只是把和调换一下以避免左递归，我们就会有这样的规则。 ::= (\"+\" | \"-\") | 这很容易解析，但却是错误的--它是右结合。使用这个语法，你会将1 - 2 - 3解析为1 - (2 - 3)。 所以我们的选择似乎是一个不可解析的左递归语法，或者是一个不正确的右递归语法。幸运的是，还有另一种解决方案。我们将在我们的语法中引入重复（repetition），所以我们可以将一个表达式定义为一个term，可能加或减一个term，可能加或减另一个term......永远如此。在EBNF符号中，用大括号({})包住某个东西意味着它可以重复零次或多次。这是我们本此实验将用于表达式的最终语法。 ::= { (\"+\" | \"-\") } ::= { (\"*\" | \"/\") } ::= \"(\" \")\" | | 这个语法正确地处理了优先级，它不是左递归，也不是右结合。然而，它也不是真正的左结合。以前，一个是一个有两个项的二元操作--现在它有任意数量的项。如果你有一堆操作在同一优先级（比如1 - 2 - 3），这个语法并没有提供任何方法将它们归为子表达式。不过这也没关系，我们的语法不需要与我们的AST完全对应。我们仍然可以用左结合的方式来构建我们的AST。 递归下降解析 我们将解析第一个term，然后，如果有更多的term，我们将以循环的方式处理它们，在每次迭代时构建一个新的BinOp节点。下面是这个处理过程的伪代码： def parse_expression(toks): term = parse_term(toks) //pops off some tokens next = toks.peek() //check the next token, but don't pop it off the list yet while next == PLUS or next == MINUS: //there's another term! op = convert_to_op(toks.next()) next_term = parse_term(toks) //pops off some more tokens term = BinOp(op, term, next_term) next = toks.peek() return t1 我们可以在parse_term中使用完全相同的方法。 parse_factor的实现很直接，因为它不需要处理结合性。我们将查看第一个标记，以确定要使用哪个生产式；弹出（pop off ）常量，并确保它们具有我们期望的值；并调用其他函数来处理非终结符： def parse_factor(toks) next = toks.next() if next == OPEN_PAREN: // ::= \"(\" \")\" exp = parse_exp(toks) //parse expression inside parens if toks.next() != CLOSE_PAREN: //make sure parens are balanced fail() return exp else if is_unop(next) // ::= op = convert_to_op(next) factor = parse_factor(toks) return UnOp(op, factor) else if next.type == \"INT\": // ::= return Const(convert_to_int(next)) else: fail() 语法定义 这里是本次lab的完整语法，包括上面的新东西（表达式--expressions、项--terms、因子--factors）和从上次lab开始没变的东西（函数--functions、语句--statements等）： ::= ::= \"int\" \"(\" \")\" \"{\" \"}\" ::= \"return\" \";\" ::= { (\"+\" | \"-\") } ::= { (\"*\" | \"/\") } ::= \"(\" \")\" | | AST节点定义 下面是我们AST节点的最新定义集合；只有exp的定义发生了变化。 program = Program(function_declaration) function_declaration = Function(string, statement) //string is the function name statement = Return(exp) exp = BinOp(binary_operator, exp, exp) // 请注意，我们现在在AST定义中区分了二元和一元运算符。例如，取负一元运算符的-和减二元运算符的-在我们的AST中是不同的类型（type）。 "},"docs/lab3/part4-codegen.html":{"url":"docs/lab3/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 基础 这一节涉及到了双目运算，分别对应如下几个汇编指令： add t0, t1, t2 #t0 = t1 + t2 sub t0, t1, t2 #t0 = t1 - t2 mul t0, t1, t2 #t0 = t1 * t2 div t0, t1, t2 #t0 = t1 / t2 rem t0, t1, t2 #t0 = t1 % t2 这些指令都有统一的格式，以第二、第三个寄存器为左右操作数，将计算结果置于第一个寄存器中。 生成 本周在代码生成阶段有一个新的挑战。要处理一个二元表达式，比如e1+e2，我们生成的汇编需要： 计算e1并将其保存在某处 计算e2 将e1加到e2， 所以，我们需要一个地方来保存第一个操作数。把它保存在寄存器中会很复杂。考虑这样一个式子（我们还没有涉及括号，仅从计算顺序的角度考虑）: 3+(3+3) e1 = 3，e2 = 3+3，第二个操作数本身包含子表达式，还需要把中间结果保存在寄存器中，这导致有可能覆盖e1。这里栈式机为我们提供了一种足够简单的解决方式。 我们依旧需要递归的生成汇编代码： visitAdd(Node add) { visit(add.lhs); visit(add.rhs); emitAdd(); } 想一想栈式机的运行方式，在执行完左操作数的计算（visit(add.lhs)）后，在栈上应当有了左操作数的结果，但右操作数的计算与左操作数无关，不会消耗掉这一结果。因此，在右操作数计算完毕后，栈上内容应该如图： ... left operator right operator emitAdd() 应当消耗这两个结果并将最终结果压栈。 lw t1, 0(sp) #取右操作数 lw t0, -4(sp) #取左操作数 add sp, sp, w #移动sp到合适位置 add t0, t0, t1, #执行add运算 sw t0, 0(sp) #储存结果 对于加法和乘法操作，操作数的顺序不重要，但对于其他三种运算，必须注意操作数计算和装载的顺序。 "},"docs/lab3/part4-1-task.html":{"url":"docs/lab3/part4-1-task.html","title":"任务","keywords":"","body":"☑任务：生成正确汇编代码 更新你的代码生成器，生成正确的加、减、除、乘、取模代码。它应该在step[123]中的所有例子上成功生成正确汇编代码。 "},"docs/lab3/summary.html":{"url":"docs/lab3/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab4/part0-intro.html":{"url":"docs/lab4/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab4/part1-parse.html":{"url":"docs/lab4/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 词法解析 在本实验中，将添加一些布尔运算符（&&，||）和一大堆关系运算符（，==，等）。由于我们已经知道如何处理二元运算符，所以本次试验将非常简单。我们将增加8个新的操作符： 逻辑与：Logical AND && 逻辑或：Logical OR || 等于：Equal to == 不等于：Not equal to != 小于：Less than 小于或等于：Less than or equal to 大于：Greater than > 大于或等于：Greater than or equal to >= 我们修改标记列表以支持新的运算符，新的标记列表如下所示: Open brace { Close brace } Open parenthesis ( Close parenthesis ) Semicolon ; Int keyword int Return keyword return Identifier [a-zA-Z]\\w* Integer literal [0-9]+ Minus - Bitwise complement ~ Logical negation ! Addition + Multiplication * Division / AND && OR || Equal == Not Equal != Less than Less than or equal Greater than > Greater than or equal >= 语法解析 在上个实验的语法中，每一个操作符的优先级都需要一个产生式。 下面是我们所有的二进制运算符，从最高到最低的优先级： Multiplication & division (*, /) Addition & subtraction (+,-) Relational less than/greater than/less than or equal/greater than or equal (, >,,>=) Relational equal/not equal (==, !=) Logical AND (&&) Logical OR (||) 我们在上个实验中处理了前两个优先级，最后四个优先级是新的。我们将为最后四个优先级各增加一条产生规则。新的语法如下，修改/增加的规则包括所有名字中包含exp的产生规则。 ::= ::= \"int\" \"(\" \")\" \"{\" \"}\" ::= \"return\" \";\" ::= { \"||\" } ::= { \"&&\" } ::= { (\"!=\" | \"==\") } ::= { (\"\" | \"=\") } ::= { (\"+\" | \"-\") } ::= { (\"*\" | \"/\") } ::= \"(\" \")\" | | ::= \"!\" | \"~\" | \"-\" 与上周的相同。我们必须重新命名，因为现在指的是逻辑或表达式，现在它的优先级最低。 上次试验写了parse_exp和parse_term函数；本次实验需要实现parse_relational_exp、parse_equality_exp等函数。除了处理不同的运算符外，这些函数的处理过程都大致相同。 这里给出语法解析的AST定义，相对于上次实验的AST，并没有什么变化： program = Program(function_declaration) function_declaration = Function(string, statement) //string is the function name statement = Return(exp) exp = BinOp(binary_operator, exp, exp) | UnOp(unary_operator, exp) | Constant(int) 这与上次lab的AST定义相同，只是我们增加了更多可能的binary_operator值。 "},"docs/lab4/part4-codegen.html":{"url":"docs/lab4/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 基础 对于>,，可以用如下指令实现： slt t0, t1, t2 #set less than; t0 = (t1 t2) ? 1 : 0; >=,，可以通过 ，> 与 - 组合得到。 ==，！=，可以先进行减法操作，将结果与0比较。 t0 = (t1 == t2) : sub t0, t1, t2 seqz t0, t0 t0 = (t1 != t2) : sub t0, t1, t2 snez t0, t0 #set not equal to zero &&,|| 是逻辑运算，比较复杂，没有直接指令，生成方式合理即可 t0 = (t1 || t2) : or t0, t1, t2 snez t0, t0 t0 = (t1 && t2) : snez t1, t1 snez t2, t2 and t0, t1, t2 生成 与 lab3 无区别（对于逻辑运算，可以有不同的生成方式，见思考题）。 "},"docs/lab4/part4-1-task.html":{"url":"docs/lab4/part4-1-task.html","title":"任务","keywords":"","body":"☑任务 更新你的代码生成程序，为&&, ||, ==, !=, , , >, 和>=发出正确的代码。它应该在所有有效的例子上成功(除了skip_on_failure_的例子)，在第1-4阶段的所有无效例子上失败。 "},"docs/lab4/summary.html":{"url":"docs/lab4/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab5/part0-intro.html":{"url":"docs/lab5/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab5/part1-parse.html":{"url":"docs/lab5/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 支持多条语句 从本步骤开始，函数中可能具有多条语句，而不再只有一个返回语句。相关符号的定义变更为： ::= \"int\" \"main\" \"(\" \")\" \"{\" { } \"}\" ::= \"return\" \";\" | \";\" 文法中的 { } 记号表示 可重复 0 至任意多次。在语法解析器的实际实现中，也可将上述文法写作： ::= \"int\" \"main\" \"(\" \")\" \"{\" \"}\" ::= /* empty */ | 如果你选择自己亲自实现一个语法解析器，建议使用后一种文法以简化实现。如果你使用了 antlr 等解析器生成工具，可以尝试直接编写前一种文法，但并不一定比后一种文法更方便。请根据实际情况做出选择。 标识符 在之前的步骤中，唯一的标识符——主函数名 main 是固定的。为了简洁起见，我们将 main 视为一个关键字，硬编码在词法和语法解析器中。但从本步骤开始，局部变量的名称将是不定的，故需要引入一个专门表示标识符的标记 Identifier，定义如下： Identifier [a-zA-Z_][a-zA-Z0-9_]* 而函数符号的定义则进一步变更为： ::= \"int\" Identifier \"(\" \")\" \"{\" { } \"}\" 局部变量的定义 语句符号的定义做如下进一步修改，将支持局部变量的定义和初始化视作一种语句： ::= \"return\" \";\" | \";\" | \"int\" Identifier [ \"=\" ] \";\" // 其中 [ = ] 表示初始化表达式是可选的。根据你实现解析器的方式，也可以将上述文法改写成： ::= \"return\" \";\" | \";\" | \"int\" Identifier \";\" | \"int\" Identifier \"=\" \";\" 解析器应生成相应的 AST 结点： statement = Return(exp) | Declare(string, exp option) // 其中 string 表示变量名，而 exp 是一个可选参数，表示变量的初始化表达式。 局部变量的访问和赋值 表达式符号做如下修改： ::= Identifier \"=\" | // ::= { \"||\" } ::= { \"&&\" } ::= { (\"!=\" | \"==\") } ::= { (\"\" | \"=\") } ::= { (\"+\" | \"-\") } ::= { (\"*\" | \"/\") } ::= \"(\" \")\" | | Integer | Identifier // ::= \"!\" | \"~\" | \"-\" 当 是一个 Identifier 时，表示访问一个变量。当 是 Identifier \"=\" 时，表示对变量赋值。 最后，解析器应生成相应的 AST 结点： exp = Assign(string, exp) // 其中 string 表示变量名。 "},"docs/lab5/part1-1-task.html":{"url":"docs/lab5/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新你的parse函数，使其可以为所有有效的step5测试用例建立正确的AST。 "},"docs/lab5/part4-codegen.html":{"url":"docs/lab5/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 为了能够随时对就变量进行修改和引用，我们需要把局部变量保存在某个能够随时访问的地方，并记住他们的确切位置。简单起见，我们会把它们保存在栈上。 如何在编译时知道一个变量的位置呢？绝对的内存地址要到运行时才能确定，结合栈帧的知识，编译时我们可以通过fp以及固定的偏移来获取特定变量。 建立栈帧 当一个函数(我们称它为f)返回时，它的调用者需要能够接上它离开的地方。这意味着它的栈帧，以及sp和fp中的值，都需要和f被调用之前完全一样。被调用时，f需要做的第一件事就是为自己建立一个新的栈帧，使用下面的指令(不妨自己用 gcc 编译一个稍复杂的程序，看看结果)。 addi sp, sp, -framesize #建立栈帧 sw ra, framesize-4(sp) #储存返回地址（已经储存在 ra 中，为什么再次储存？） sw fp, framesize-8(sp) #储存 fp addi fp, sp, framesize #更新 fp 这些指令称为函数前序（function prologue）。目前, framesize = 变量数量 * 4 + 8（为什么？），注意，我们所有的变量长度都为4。 在f返回之前，它立即执行函数前序来删除这个栈帧，让一切都和函数前序执行之前一样。 lw fp, framesize-8(sp) #恢复 fp lw ra, framesize-4(sp) #恢复 ra addi sp, sp, framesize #恢复 sp ret 这被称为函数收尾（function epilogue）。到目前为止，我们可以不需要函数前序（function prologue）或函数收尾（function epilogue），但添加它们将减少后续面对跳转和函数时的困难。 有了这些准备： 我们可以安全地将局部变量推送到栈上，而不改变调用者的栈帧。 可以将变量位置保存为fp的偏移量。我们知道fp到sp上面没有任何东西（因为我们在函数前序中设置了一个空的堆栈框架），而且我们知道fp在函数收尾之前不会改变。 我们应该在函数定义的开始处生成函数前序，就在函数的标签之后，并在函数末尾生成函数收尾。 需要注意的是，我们需要改写之前我们的 RET 指令，它应当跳到函数收尾而不是直接 ret，考虑到目前我们没有分支指令而且只有一个函数，不改写暂时不会产生问题。 这样，我们对于变量的映射可以通过变量相对于 fp 的偏移来建立。现在让我们看看如何处理变量的声明、赋值和引用。 变量声明 碰到变量声明时，需将变量保存到栈中并设定它的偏移量。事实上，我们在函数前序中留下了变量的位置（注意栈帧的大小），也就隐式的“保存”了变量。首先我们需要一个数据结构来维护变量的信息，如：名称、类型（lab11）、声明位置、初始化语句等。至于偏移，你可以把偏移直接作为变量的属性，也可以建立一个变量到其偏移的映射，关键的问题是偏移量的确定。 目前阶段，你可以简单的使用一个简单的链表或者数组来保存已声明变量的信息。 偏移量确定 变量的偏移量有一种比较暴力的设定方式：每一个声明的变量偏移依次递增。目前我们没有作用域，这样做是没问题的，但在第7章引入作用域后，这种暴力的实现会出现一些问题。 变量重复声明的检查：每次碰到生命则检查有无同名变量已经声明。 变量赋值 代码生成 目前只有变量才能作为左值，所以记得检查 assign 操作的类型（或许你已经在 parser 中进行了检查）。因为我们的变量相当于一个地址，可以通过 sd 指令完成变量赋值。 visitAssign(Node assign) { visit(assign.rhs); //计算变量值，结果压入栈中 emitStore(assign.lhs.offset); //进行赋值 } void emitStore(int offset) 生成如下代码： lw t0, 0(sp) addi sp, sp, 4 #pop 变量值 sw t0, 4*{offset}(fp) #变量赋值 addi sp, sp, -4 sw t0, 0(sp) #push 变量值，因为 assign 语句是有返回值的 显然，这段代码可以优化，不做赘述。 注意，assign 语句存在返回值，也就会最终在栈中留下一个值。 因此， a = 0; 语句会给 a 赋值并在栈中留下一个 0，必须将这个多余的值弹出。 \\ ::= \\ \";\" 类型的 statement 都存在这个问题。 变量引用 要引用表达式中的变量，只需将其从堆栈中复制到栈顶即可： visitVar(Node var) { emitLoad(var.offset); } emitLoad(var.offset)： lw t0, 4*{offset}(fp) #取变量的值 addi sp, sp, 4 sw t0, 0(sp) #push到栈顶 "},"docs/lab5/part4-1-task.html":{"url":"docs/lab5/part4-1-task.html","title":"任务","keywords":"","body":"☑任务 更新你的代码生成阶段： 生成函数前序和函数收尾 为变量声明、变量赋值和变量引用生成正确的代码 新的编译器应该在测试集的step[1-5]中的所有例子中成功。 "},"docs/lab5/summary.html":{"url":"docs/lab5/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab6/part0-intro.html":{"url":"docs/lab6/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab6/part1-parse.html":{"url":"docs/lab6/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 分支语句 本步骤对语句的定义做如下修改： ::= \"int\" Identifier \"(\" \")\" \"{\" { } \"}\" ::= | ::= \"int\" Identifier [ \"=\" ] \";\" ::= \"return\" \";\" | \";\" | \"if\" \"(\" \")\" [ \"else\" ] 最主要的变更是引入了分支语句作为一种 ，其中的 \"if\" 和 \"else\" 是新的关键字，应在词法分析器中实现。 值得注意的是：上一步骤中的 被拆分成了 和 两个符号，局部变量的定义不再是一种 了。而 和 都是 。考虑如下例子，你就能明白这一变动的原因。 if (1) x = x + 1; 这是合法的，x = x + 1 是一个 。 if (1) int x; 这是不合法的，int x 是一个 。 语法解析器应生成相应的 AST 结点： statement = ... // 已有的其他结点 | Conditional(exp, statement, statement option) 其中 Conditional 结点表示分支语句，其三个参数分别为分支条件、then 语句和 else 语句，其中 else 语句是可选的。 根据你的喜好，你也可以选择不在 Conditional 结点里实现可选的 else 参数，而是构造一个表示空语句的结点（或者使用下一步要引入的空语句块）来表示缺少 else 分支的情况。 你可以让 Declaration 结点不再属于一种 statement，以和文法保持一致，也可以不做此项修改。 分支表达式 本步骤对表达式的定义做如下修改： ::= Identifier \"=\" | ::= [ \"?\" \":\" ] // ::= { \"||\" } ::= { \"&&\" } ::= { (\"!=\" | \"==\") } ::= { (\"\" | \"=\") } ::= { (\"+\" | \"-\") } ::= { (\"*\" | \"/\") } ::= \"(\" \")\" | | Integer | Identifier ::= \"!\" | \"~\" | \"-\" 此处 表示 ?: 表达式。语法解析器应生成相应的 AST 结点： exp = Assign(string, exp) | Var(string) | BinOp(binary_operator, exp, exp) | UnOp(unary_operator, exp) | Constant(int) | CondExp(exp, exp, exp) // 其中 CondExp 表示 ?: 表达式，其三个参数分别为条件、条件成立时的值，和条件不成立时的值。 "},"docs/lab6/part1-1-task.html":{"url":"docs/lab6/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新你的parse函数，使其可以为所有有效的step6测试用例建立正确的AST。 "},"docs/lab6/part4-codegen.html":{"url":"docs/lab6/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 基础 不妨先看看跳转语句的 c 汇编代码： int main() { int a = 0; if(a) { a = 2; } else { a = 3; } return a; } .globl main main: addi sp,sp,-32 sd s0,24(sp) #这里的 s0 是 fp 的别称 addi s0,sp,32 #函数前序，由于只有一个函数，未保存 ra sw zero,-20(s0) #变量初始化 lw a5,-20(s0) sext.w a5,a5 #这两句计算了 if 条件 beqz a5,.L2 li a5,2 #then 分支 sw a5,-20(s0) j .L3 .L2: #els分支 li a5,3 sw a5,-20(s0) .L3: lw a5,-20(s0) mv a0,a5 #返回变量 a 的值 ld s0,24(sp) addi sp,sp,32 jr ra #函数收尾 跳转语句 跳转语句是分支的基础，跳转分无条件跳转和条件跳转 j label #jump;无条件跳转到label, pc 标识 标识(label)可以方便我们进行跳转，为了保证跳转的正确我们需要合适的方式生成 label。最简单的，我们可以用一个累加的数字来区分 label(比如上面的汇编例子)，但好的 label 可以是的代码更加可读，有些时候也能方便我们编程。目前，我们可以用一个累增数字和一个后缀(.then、.else、.exit)来生成标识。 生成 为了生成 IF 语句和条件表达式的汇编代码，我们将需要有条件和无条件的跳转，以条件表达式为例。遵循递归的思路，我们可以这样 IF 语句: 生成IF语句： 计算条件; 生成跳转语句; 生成标识(then); 生成then分支代码; 生成标识(els); 生成els分支代码; 条件表达式与之类似，以下给出条件表达式伪代码。 visitTern(Node tern) { visit(tern.cond); #Label then = new Label(\"then\"); #在这里，then分支是用不到的，可以删掉，但在后续的循环中会用到 Label els = new Label(\"els\"); #得到一个新的 else label Label exit = new Label(\"exit\"); #得到一个新的 exit label emitBeqz(els); #消耗 tern.cond 的结果，如为 false 则跳转到 els 分支 then.emit(); #emit then label, 接下来的代码会 push then 分支的结果并跳转到 exit emitJ(exit); #then分支结束后，直接跳转到 exit label els.emit(); #emit els label, 接下来的代码会 push els 分支的结果并跳转到 exit visit(tern.els); exit.emit(); } IF 语句与条件表达式很类似，请同学们自行完成。 "},"docs/lab6/part4-1-task.html":{"url":"docs/lab6/part4-1-task.html","title":"任务","keywords":"","body":"☑任务 更新代码生成过程，以正确处理三元条件表达式和if语句。它应该在所有step[1-6]的例子上成功。 （可选）改写 RET 尝试改写你的 return 语句生成，是其不会直接返回而是跳转到函数收尾，这为处理函数打下来基础。 （思考）条件表达式短路 在part4的实现中，条件表达式存在短路现象。即： int main() { int a = 0; int b = 0 ? 1 : (a = 2); return a; } 会返回 0 而不是 2。为什么会这样，如果要求不存在短路现象，该如何修改？简述你的思路。 "},"docs/lab6/summary.html":{"url":"docs/lab6/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab7/part0-intro.html":{"url":"docs/lab7/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab7/part1-parse.html":{"url":"docs/lab7/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 本步骤对词法/语法解析的变更较为简单。语句块可以视为语句的一种，就像括号表达式可以视为表达式的一种一样。 据此，文法做如下修改： ::= | ::= \"int\" Identifier [ \"=\" ] \";\" ::= ... // 已有的其他产生式 | \"{\" { } \"} // 你可能需要加入其他标记与产生式以识别 { }。 要生成的 AST 做如下修改： statement = ... // 已有的其他结点 | Compound(block_item list) "},"docs/lab7/part1-1-task.html":{"url":"docs/lab7/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新你的parse函数，使其可以为所有有效的step7测试用例建立正确的AST。 "},"docs/lab7/part4-codegen.html":{"url":"docs/lab7/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 块语句本身的汇编生成是很简单的，只需要依次生成块中的语句即可，块语句真正影响的是变量。 正如测试例子中的某些程序，有可能有两个不同的变量，在两个不同的作用域中，存储在栈的两个不同的位置，但名称相同。下面是这样一个例子： int foo = 3; { int foo = 4; } 因此，每当程序引用变量foo时，我们生成的代码就需要在栈上访问正确的foo，如果foo已经“死亡”，则会引发一个错误。本次试验的代码生成步骤就是管理和访问变量集合对应的数据结构，使我们总是能查找到正确的foo。为此，我们需要调整我们在变量定义、赋值、引用时的行为。 变量偏移的确定 回顾我们在 lab5 中的做法，变量偏移完全等于变量出现的次序。这在当前仍然是正确的，但比较浪费栈空间，因为变量都存在生命周期，有些变量不可能同时存在，也就可以共用同一块地址空间（这个问题在后续编译课程中有深入的讨论）。我们在这里不做过多的优化，但在 minidecaf 中，一旦离开一个作用域，该作用域中声明的变量会全部失效，这就可以引出一个简单而有效的优化：利用栈的形式存储变量，记录作用域（只纪作用域深度即可），碰到变量声明则压栈变量，一旦离开一个作用域则弹出该作用域中所有的变量，此时，变量的偏移可以设置为它在栈中的位置编号（想想为什么？）。 找到正确变量 在 lab5 中，因为只有一个作用域，不论赋值还是引用，我们直接遍历所有变量就可以找到目标变量，但是引入作用域后，找到正确变量就没那么简单了。 所谓正确的变量，指的是位于同一或者各级父作用域中，最接近变量引用的声明，也就是“最近”的变量声明。 在单遍的代码生成中，可以维护上一小节所描述的变量栈，直接在栈中从栈顶向栈底搜索即可。这样，总是会找到最近的变量声明，且已经“死亡”的变量会被弹出，不会找错。 在多遍的代码生成中，我们可以维护一个树状的结构来维护变量的声明以及作用域信息。提示：可以通过存储声明位置（行号、列号，这要求生成的 AST 中存储了这些信息）判断同一个作用域中的某一个声明位于引用前还是引用后（step7/declare_late.c）。 "},"docs/lab7/part4-1-task.html":{"url":"docs/lab7/part4-1-task.html","title":"任务","keywords":"","body":"☑任务 更新代码生成阶段的代码，以正确处理复合语句。并在step[1-7]中的例子上成功。 "},"docs/lab7/summary.html":{"url":"docs/lab7/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab8/part0-intro.html":{"url":"docs/lab8/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab8/part1-parse.html":{"url":"docs/lab8/part1-parse.html","title":"词法语法分析","keywords":"","body":"词法语法解析 while 语句 为 新增如下产生式： ::= ... // 已有的其他产生式 | \"while\" \"(\" \")\" 其中 \"while\" 是新的标记，应在词法分析器中实现。 新增如下 AST 结点： statement = ... // 已有的其他结点 | While(expression, statement) 其中 expression 和 statement 分别为循环条件和循环体。 do while 语句 为 新增如下产生式： ::= ... // 已有的其他产生式 | \"do\" \"while\" \"(\" \")\" \";\" 其中 \"do\" 是新的标记，应在词法分析器中实现。 新增如下 AST 结点： statement = ... // 已有的其他结点 | Do(statement, expression) 其中 expression 和 statement 分别为循环条件和循环体。 for 语句 相对于 while 语句和 do while 语句，for 语句较为复杂。for 语句可能有如下变种： for 的第一个分号前，可能是语句，也可能是循环变量的定义； for 的初始化语句、循环条件和自增语句均可以为空。 为此，我们按如下方式设计文法： ::= ... // 已有的其他产生式 | \"for\" \"(\" | \"for\" \"(\" ::= \";\" | \";\" ::= \")\" | \")\" 其中 \"for\" 是新的标记，应在词法分析器中实现。 当然，这只是能解析 for 语句的其中一种文法。你也可以设计一个标记表示“表达式或空”，以替换 和 ，或是按你喜欢的其他方式设计。 解析器应生成如下 AST 结点： statement = ... // 已有的其他结点 | For(exp option, exp option, exp option, statement) | ForDecl(declaration, exp option, exp option, statement) 其中 For 和 ForDecl 分别表示在 for 语句中使用初始化语句和定义循环变量的两种情况。AST 结点的各个参数分别表示初始化语句/循环变量定义、循环条件、自增语句和循环体。如果你在第6步选择将 Declaration 作为一种 statment，那么只需添加 For 结点即可，而不必添加 ForDecl 结点。按这种方式，你可能需要在后续步骤中区分这两种 for 语句。 带 option 标记的表示该项是可选的。你也可以选择不在 AST 结点中设计可选参数，而是构造一个常量 1 结点代替空的循环条件、构造一个空语句块结点代替空的初始化或自增语句。 空语句 在本步骤中，我们还要引入空语句。你可以利用上述 for 语句产生式中的 ，例如： ::= ... // 已有的其他产生式 | // null statement 也可以设计单独的空语句产生式。 对于 AST，你既可以使用空的语句块结点表示空语句，也可以加入专门表示空语句的结点，还可以干脆不用任何结点表示空语句。 break 和 continue 语句 为 新增如下产生式： ::= ... // 已有的其他产生式 | \"break\" \";\" | \"continue\" \";\" 其中 \"break\" 和 \"continue\" 均是新的标记，应在词法分析器中实现。 新增如下 AST 结点： statement = ... // 已有的其他结点 | Break | Continue 值得注意的是，如果程序中存在位于循环体外部的 break 或 continue，上述文法并不会报错。你需要在后续步骤中进行验证，也可以改进文法，在语法解析阶段就识别此类错误。 "},"docs/lab8/part1-1-task.html":{"url":"docs/lab8/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新你的parse函数，使其可以为所有有效的step8测试用例建立正确的AST。 "},"docs/lab8/part4-codegen.html":{"url":"docs/lab8/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 空语句 对于空语句的代码生成过程很简单，即不要为空语句生成任何汇编。 while 循环 给定一个 while 循环： while () 我们可以这样描述它的代码生成流程： 生成计算 的代码 如果结果是假的，跳到步骤 5 生成 的代码 跳到步骤 1 完成 在这里就不展示需要生成的具体汇编了，参考 RISC-V 指令集选取合适的指令（条件跳转和无条件跳转）。最主要的是给步骤 1 和步骤 5 打上标签（label），这样当我们需要跳转指令时，就有地方可以跳转了。 do 循环 对于一个 do 循环： do while (); 和 while 循环不同，do 循环会先执行循环体 ，再计算 的值，如果结果为真，才跳转到循环体头部，否则不跳转而结束循环。请参考 while 循环实现 do 循环的代码生成。 for 循环 给出这样一个 for 循环： for (; ; ) 可以转换成如下的 while 循环： while () { } 类似地，for 循环也可转换为一个 do 循环，不过需要增加 后直接跳转到计算 这一步。因此，你可以直接复用 while 循环或 do 循环的代码生成过程，为 for 循环生成代码。 需要注意的是， 和 都有可能是空的，在这种情况下，我们只是不生成任何汇编。对于 为空的情况，还需修改相应的条件跳转语句。 break 和 continue 语句 我们可以用一条直接跳转指令实现这两条语句，关键是找出跳转到哪里： break：跳转到“循环结束”标签； continue： 对于 while 循环：跳转到计算 前面； 对于 do 循环：跳转到生成 前面； 对于 for 循环：跳转到生成 前面； "},"docs/lab8/part4-1-task.html":{"url":"docs/lab8/part4-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新汇编代码生成过程，以正确处理三种循环语句以及 break、continue 语句。并通过 step[1-8] 的测试用例。 "},"docs/lab8/summary.html":{"url":"docs/lab8/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab9/part0-intro.html":{"url":"docs/lab9/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab9/part1-parser.html":{"url":"docs/lab9/part1-parser.html","title":"词法语法分析","keywords":"","body":"词法语法分析 本步骤引入了函数调用的概念。和之前只允许主函数定义不同，在本步骤中你将修改之前的文法规定，允许在一个源程序中声明和定义多个函数，并支持对它们的调用。 注：因词法分析部分需要解释的东西较少，我们将词法和语法分析合为一个文件，但需要注意的是，它们是相互独立的操作流程。 词法分析 你需要添加逗号,来支持函数参数的分隔，目前的 Token 列表为： { } ( ) ; int return Identifier [a-zA-Z_][a-zA-Z0-9_]* Integer literal [0-9]+ - ~ ! + * / && || == != >= = if else : ? for while do break continue , // 语法分析 和之前的步骤不同，本步骤添加了对函数调用的支持，因此我们需要处理函数定义以及函数调用。 函数定义 在此前的步骤中，我们将一个源文件限制为只可定义一个函数并且函数的声明和定义不可分离，文法如下： ::= ::= \"int\" Identifier \"(\" \")\" \"{\" { } \"}\" 为了实现正常的函数定义，你首先需要添加函数参数列表，支持带参数的函数： ::= \"int\" Identifier \"(\" [ \"int\" Identifier { \",\" \"int\" Identifier } ] \")\" 其次，你需要支持函数的声明和定义分离这一特性。函数声明指在使用该函数前说明其函数名、参数列表以及返回类型，而函数定义指包含函数体的一个完整函数单元，如下例所示，我们首先声明了foo函数，并在之后给出了foo函数的定义。 int three(); int three() { return 3; } 综上，为了支持函数参数、函数的声明与定义，可以将文法修改为如下所示： ::= \"int\" Identifier \"(\" [ \"int\" Identifier { \",\" \"int\" Identifier } ] \")\" ( \"{\" { } \"}\" | \";\" ) 注：原则上同一个函数可以声明无数次，但只能定义一次。本实验中对于同名函数的重复声明不做要求，即属于未定义行为，测例中不会出现同名函数重复声明的情况。 函数调用 函数调用是一个类似这样的表达式： foo(arg1, arg2, ...) 它包含了函数名和一个参数列表，和函数声明不同，参数可以为任意形式的表达式，因此我们在处理时将函数名作为Identifier元素，参数作为exp元素进行处理，语法解析器生成相应的AST节点： exp = ... | FunCall(string, exp list) // string is the function name ... 和前面的步骤一样，作为表达式，函数调用也应该有其优先级，一般函数调用具有尽可能高的优先级，因此在文法中，我们将其添加到规则中： ::= Identifier \"=\" | ::= [ \"?\" \":\" ] ::= { \"||\" } ::= { \"&&\" } ::= { (\"!=\" | \"==\") } ::= { (\"\" | \"=\") } ::= { (\"+\" | \"-\") } ::= { (\"*\" | \"/\") } ::= | \"(\" \")\" | | Integer | Identifier ::= id \"(\" [ { \",\" } ] \")\" // ::= \"!\" | \"~\" | \"-\" "},"docs/lab9/part1-1-task.html":{"url":"docs/lab9/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 词法分析 我们需要添加逗号来分隔函数参数，因此你需要在你的 Token 识别中增加对逗号,的支持。 语法分析 更新你的parse函数，使其可以为所有有效的step9测试用例建立正确的AST，并保证之前的测试用例不被影响。 "},"docs/lab9/part4-1-cconv.html":{"url":"docs/lab9/part4-1-cconv.html","title":"调用约定","keywords":"","body":"调用约定 增加了函数之后，需要修改的部分主要有两处：函数定义与函数调用。在生成汇编代码之前，我们需要先了解一下调用约定。 调用约定（calling conventions）可认为是函数调用与函数定义之间规定的一套协议，只要双方都遵循同样的协议，调用就不会出错。如果两个编译器使用的调用约定相同，它们就可以互相调用各自编译出的函数，例如要让我们的 minidecaf 程序正确调用已编译的 C 标准库的函数，就需要让我们的编译器遵循 GCC 的调用约定。 总的来说，调用约定统一了以下有关函数调用的接口： 参数是如何传递给被调用者（callee ）的？是在栈上还是寄存器上传递？ 返回值是如何传回给调用者（caller ）的？ 调用者与被调用者之间如何协调管理栈空间？ 哪些寄存器由调用者保存？哪些由被调用者保存？ 调用约定没有一套统一的标准，例如对于 x86 架构就有 cdecl、stdcall、fastcall 等多种。为了便于实现，在这里我们介绍了一套 RISC-V 的简化版调用约定，你也可以参考 GCC 的，或自己定义一套。 我们的调用约定可以概况为： 参数都通过栈传递，压栈顺序为从右向左。 返回值保存在 a0。 调用者分配和回收参数所需的栈空间，被调用者分配和回收自己的栈帧。 除了有特殊用途的寄存器外，t0-t6 是由调用者保存的，s0-s11 是由被调用者保存的。 以下是一些细节。 RISC-V 寄存器 图片来源：https://riscv.org/wp-content/uploads/2015/01/riscv-calling.pdf 上表列出了 RISC-V 架构的所有整数寄存器和浮点寄存器。由于寄存器个数是有限的，因此它们常常需要被保存到内存中。寄存器的保存通常发生在函数调用前后，根据保存者的不同，寄存器可分为调用者保存（caller saved）寄存器和被调用者保存（callee saved）寄存器（见上表最后一列）： 调用者保存寄存器（或临时寄存器）：在函数调用前，由调用者将它们保存到栈上，并在函数调用结束后从栈上恢复，在调用前后可能被修改； 被调用者保存寄存器（或保存寄存器）：在函数调用开始后，由被调用者将它们保存到栈上，并在函数返回前从栈上恢复，在调用前后保持不变。 例如，以 t 开头的寄存器都是临时寄存器，在函数调用时不保留，如果调用后还要用到则需要调用者进行保存；用于存放返回值或参数的以 a 开头的寄存器也会在函数调用时被更改，也属于临时寄存器。而以 s 开头的寄存器都是保存寄存器，在函数调用时会保留原来的值，调用者无需进行保存；另外如 sp 之类的寄存器因在函数调用前后保持不变，也属于保存寄存器。 由于本实验不包含寄存器分配和浮点运算，我们只会用到其中很小的一部分： 函数返回地址 ra 栈指针 sp 栈帧指针 fp（或 s0） 临时寄存器：t0-t1（两个足够） 函数返回值 a0 参数寄存器 a0-a7（如果实现了寄存器传参） 参数传递 一般来说，为了提高性能，参数应尽可能通过寄存器传递。不过为了简单起见，我们规定参数全部使用栈来传递。你完全可以遵循其他调用约定使用 a0-a7 寄存器来传参，或是当参数个数过多时同时使用寄存器和栈来传参。 当函数调用开始前，调用者按从右到左的顺序将每个参数压入栈中。例如，对于函数调用 foo(1, 2, 3); 压栈的顺序是： PUSH 3 PUSH 2 PUSH 1 当函数调用结束后，再由调用者释放栈上的这段参数空间。 "},"docs/lab9/part4-2-codegen.html":{"url":"docs/lab9/part4-2-codegen.html","title":"代码生成","keywords":"","body":"代码生成 首先确定你要遵循的调用约定，你可以使用上一节中我们给出的简化版调用约定，也可以参考 GCC 的，也可以自己再定义一套。不过，你的编译器应该始终遵循同一套调用约定。本小节之后的描述都基于上一节的简化版调用约定。 函数序言 在 lab4 我们简单提及了函数的序言（prologue）与收尾（epilogue），这里我们将对这两部分代码的生成进行完善。 当一个函数开始执行前，需要做一些额外工作，即函数序言，这一部分的工作包括： 创建栈帧：根据局部变量和需要保存的寄存器的个数，栈帧的大小是可以事先确定的，直接令 sp 减去栈帧大小。在某些系统下，需要让栈指针 16 字节对齐，不过本实验中我们将其省略。 保存寄存器：在这一部分需要保存的寄存器即被调用者保存寄存器，在 RISC-V 中即以 s 开头的那些寄存器，不过在本实验中我们只用到了 s0（即 fp），所以不需要保存其他的。特别地，如果在该函数中调用了另一个函数，返回地址寄存器 ra 也会被修改，我们也将它保存在这里，但它其实是属于调用者保存寄存器。 设置栈帧指针：函数中用到的所有局部变量都是保存的栈帧中的，我们可以通过“栈帧基址寄存器”加“偏移”的形式来引用它们。不过我们不能直接使用 sp 作为栈帧基址寄存器，因为在后续栈式机的执行过程中栈可能会增长。这里我们用一个特殊寄存器 fp（等价于 s0）来保存栈帧基址，即栈帧指针（frame pointer），并将其设为原来的 sp。 生成的代码如下： .globl func: # 设置标签 func 为全局可见 func: # 函数入口标签 addi sp, sp, -framesize # 创建栈帧 sw ra, framesize-4(sp) # 保存函数返回地址 sw fp, framesize-8(sp) # 保存上一函数栈帧指针 addi fp, sp, framesize # 设置新的栈帧指针 函数收尾 当一个函数运行结束，执行 return 语句后，还不能直接返回，还需要一些收尾工作，即函数收尾。这一部分的工作包括： 恢复寄存器：恢复那些在序言部分保存的寄存器，即返回地址 ra 和栈帧指针 fp。 销毁栈帧：令 sp 加上栈帧大小，保证 sp 在函数调用前后不变。 设置返回值并返回：将 return 语句中的返回值保存到 a0 寄存器，然后执行 ret 指令。 生成的代码如下： func_epilogue: # 函数收尾部分标签 lw ra, framesize-4(sp) # 恢复函数返回地址到 ra lw fp, framesize-8(sp) # 恢复上一函数栈帧指针到 fp addi sp, sp, framesize # 销毁栈帧 mv a0, retval # 将返回值保存到 a0 寄存器 ret # 等价于 jr ra 此外，在之前的 lab4 也提到过，对于所有的 return 语句，应该生成一条直接调转到函数收尾的语句，而不是直接一条 ret 指令。 函数调用 这里需要用到一条新指令 call label，其原型为 jal ra, label，表示“跳转到 label，并把返回地址保存到 ra”，而 call 只是一条伪指令。 当要调用一个函数时，不光是一条 call 指令就可以解决的，还需要考虑以下方面： 参数传递：根据我们的调用约定，使用栈从右往左进行传参。 寄存器的保存与恢复：我们需要在函数调用前保存调用者保存寄存器，并在调用结束后恢复。不过本实验使用栈式机模型，没有寄存器的分配，在栈式机执行过程中已经进行了寄存器的保存，因此无需专门保存调用者寄存器。 于是对于函数调用，我们可以生成以下汇编代码： addi sp, sp, -arg_num*4 # 在栈上分配一块区域用于存放参数 sw arg_n-1, n*4-4(sp) # 从右向左依次向栈中压入参数 ... sw arg_1, 4(sp) sw arg_0, 0(sp) call func # 调用函数 func，硬件会自动设置 ra 为下一条指令的地址 addi sp, sp, arg_num*4 # 回收栈空间 addi sp, sp, -4 sw a0, 0(sp) # 将返回值压入栈，继续栈式机的执行 需要注意，在函数 func 中引用参数时，要能确定参数的位置，即算出正确的相对于 fp 的偏移。 栈空间布局 为了方便理解，这里给出了函数调用时的栈空间布局，以供参考： "},"docs/lab9/part4-3-task.html":{"url":"docs/lab9/part4-3-task.html","title":"任务","keywords":"","body":"☑任务： 更新汇编代码生成过程，以正确处理函数定义与调用。并通过 step[1-9] 的测试用例。 ☑任务（可选）： 利用 riscv64-unknown-elf-gcc，通过对一些小例子生成汇编代码，了解 GCC 的调用约定，包括函数序言、函数尾声、函数调用部分，并改进你的 minidecaf 编译器，使其符合 GCC 的调用约定，并让 minidecaf 程序能够正确调用由 GCC 编译的函数。 下面是一个测试程序，使用你的编译器编译并运行后，应该能正确输出 Hello, World!。 int putchar(int c); int main() { putchar(72); putchar(101); putchar(108); putchar(108); putchar(111); putchar(44); putchar(32); putchar(87); putchar(111); putchar(114); putchar(108); putchar(100); putchar(33); putchar(10); } 提示：使用 a0-a7 寄存器传递前 8 个参数，超过 8 个的部分再使用栈传递，并注意传参寄存器的保存。 "},"docs/lab9/summary.html":{"url":"docs/lab9/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab10/part0-intro.html":{"url":"docs/lab10/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab10/part1-parser.html":{"url":"docs/lab10/part1-parser.html","title":"词法语法分析","keywords":"","body":"词法语法分析 本步骤引入了全局变量的概念。这意味着你可以将变量声明和初始化放在函数外进行，在本步骤中你将修改之前的文法规定，支持全局变量的声明和初始化。 注：因词法分析部分需要解释的东西较少，我们将词法和语法分析合为一个文件，但需要注意的是，它们是相互独立的操作流程。 词法分析 本步骤无新增 Token 定义，目前的 Token 列表为： { } ( ) ; int return Identifier [a-zA-Z_][a-zA-Z0-9_]* Integer literal [0-9]+ - ~ ! + * / && || == != >= = if else : ? for while do break continue , 语法分析 本步骤新增了对于全局变量的支持，因此现在位于最顶层的声明有函数声明和变量声明两种，之前的顶层声明需要加入对变量声明的支持，我们修改文法如下： ::= { } // ::= { | } // 在修改了文法定义之后，我们的顶层 AST 会发生一些变化： // 修改前 AST program = Program(function_declaration list) // 修改后 AST toplevel_item = Function(function_declaration) | Variable(declaration) toplevel = Program(toplevel_item list) program = Program(function_declaration list) "},"docs/lab10/part1-1-task.html":{"url":"docs/lab10/part1-1-task.html","title":"任务","keywords":"","body":"☑任务： 词法分析 本次实验涉及到了全局变量的定义，没有新的 Token 出现，因此无需修改词法分析部分。 语法分析 更新你的parse函数，使其可以为所有有效的step10测试用例建立正确的AST，并保证之前的测试用例不被影响。 "},"docs/lab10/part4-codegen.html":{"url":"docs/lab10/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 全局变量需要保存在内存中的某个地方。它们不能被保存在栈上，因为栈可认为是一个函数的私有数据，其他函数不能进行访问。因此它们需要被保存在一块公共的内存中，即数据段（data section）。我们知道一个程序在运行时有一个自己的地址空间，并被划分为了多段内存区域，不同的段有着不同的读、写、可执行权限，下图给出了不同内存段的布局： 我们之前一直在处理的 RISC-V 指令都在代码段（text section），具有可执行权限，并且是只读的；而全局变量则在数据段（data section），一般具有可读写权限，而无可执行权限。我们可将其进一步细分为初始化、未初始化、以及只读的数据段，其中未初始化的数据段通常称为 BSS，会在程序加载时被初始化为 0；只读数据段（rodata）用于保存程序中定义的常量，在本实验中不会用到。 在编写自己的汇编码生成器之前，我们先来看看 GCC 是如何生成全局变量的代码的。 int N = 2333; int main() { return N; } 使用以下命令编译出汇编代码： $ riscv64-unknown-elf-gcc test.c -O3 -S -o test.S $ cat test.S .file \"test.c\" .option nopic .text .section .text.startup,\"ax\",@progbits .align 1 .globl main .type main, @function main: lui a5,%hi(N) lw a0,%lo(N)(a5) ret .size main, .-main .globl N .section .sdata,\"aw\" .align 2 .type N, @object .size N, 4 N: .word 2333 .ident \"GCC: (SiFive GCC 8.2.0-2019.05.3) 8.2.0\" 全局变量定义 从上述结果中，很容易找到全局变量 N 的定义部分，去掉一些无关内容并简化后如下： .data # 即 .section .sdata,\"aw\"，表示接下来是数据段，内容可写 .globl N # 让符号 N 对链接器可见 .align 2 # 接下来的数据需要 4 字节对齐 N: .word 2333 # 在数据段分配一个字（4 字节）大小的整数，值为 2333 这里有几件事要注意： .data 指示符告诉汇编器我们在数据段。我们还需要一个 .text 指示符来告诉我们何时切换回代码段。 像 N 这样的标签可以标注一个内存地址。汇编器和链接器并不关心这个地址是指代码段的指令还是数据段的变量，它们会以同样的方式处理它。 .align n 的意思是“下一个东西的起始地址应为 2n2^n2​n​​ 字节的倍数”。 有关 RISC-V 汇编指示符（directives）的更多内容 ，详见 https://github.com/decaf-lang/minidecaf/blob/master/doc/riscv-assembly-directives.md 在具体实现时，我们每遇到一个全局变量，就生成类似以上的代码。对于未初始化的全局变量，简单起见我们无需考虑 BSS 段，直接将其初始化为 0 即可。 对于全局变量的初值，需要在编译时就进行确定，因此其初始化器需要是一个常量表达式。为了方便，我们的测试集只包含该常量表达式是一个整数的情况，你可以无需计算表达式。 全局变量引用 从 GCC 的结果中我们也可以得到引用一个全局变量的方法： lui a5,%hi(N) # 将 N 地址的高 20 位作为立即数加载到 a5，低 12 位设为 0 lw a0,%lo(N)(a5) # 从内存中读出数据保存到 a0，内存地址为 a5 加上 N 地址的低 12 位 注意到这里用了两条指令，而不是类似 lw a0, 0(N) 的一条，这是因为 N 在这里是个标签，其实际值是一个 32 位的地址，这超过了一条长度为 4 字节的指令的表示能力。 对于给全局变量赋值的情况也类似，只不过是把 lw 换成了 sw。 "},"docs/lab10/part4-1-task.html":{"url":"docs/lab10/part4-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新汇编代码生成过程，以正确处理全局变量的定义与引用。并通过 step[1-10] 的测试用例。 ☑任务（可选）： 将未初始化的全局变量放到 BSS 段。 ☑任务（可选）： 大多数编译器允许用常量表达式来初始化全局变量，比如： int foo = 2 + 3 * 5; 这需要你在编译时就算出 2 + 3 * 5 的值。改进你的编译器以支持这一点。 "},"docs/lab10/summary.html":{"url":"docs/lab10/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab11/part0-intro.html":{"url":"docs/lab11/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab11/typeck.html":{"url":"docs/lab11/typeck.html","title":"类型检查","keywords":"","body":"类型检查 …… 类型检查是语义检查 …… 不能 int + int …… …… 类型上下文：变量 -> 类型的映射 …… …… 类型规则：参数类型有哪些 -> 返回值类型 …… "},"docs/lab11/part4-codegen.html":{"url":"docs/lab11/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 本阶段代码生成的重点是处理 * 和 & 这两个运算符，而对于类型系统和强制类型转换属于语义检查，无需生成代码。 首先，对于 * 运算，只需一条 Load 指令即可完成解引用这一操作。但对于取地址符 & 就不是很直观了，因为 & 号后面可能不会立即跟一个变量如 &a，而是会有形如 &*p 这样的，虽然两个操作可以相互抵消，但如果将其解释为“先解引用，再取地址”，就难以生成对应的汇编代码，因为变量的地址信息会在解引用后丢失。此外，对于像 * 号出现在赋值语句左边的情况，也不是很好处理。因此，在讨论如何生成代码之前，我们先来讨论一下“左值”的概念。 左值 我们都知道，赋值语句可以写成 a = 123 的形式，而不能是 123 = a，这是因为赋值号左边的是一个左值（lvalue），要求与一个地址相关联；而右边的 123 是一个右值（rvalue），并不需要关联一个地址。通俗地讲，左值是一个有地址的值，例如： int a; int* p; a = 1; // a 是左值 *&a = 2; // *&a 是左值 p = &a; // p, a 是左值 *p = 3 + a; // *p 是左值 从上述代码可以看出，赋值号左边的以及 & 后面的都要求是左值，需要知道它们的地址才能进行计算；而像几个常量和最后一行的 a 这样的是右值，只需知道其值就行了。 有了左值的概念，就比较容易处理本节一开始提到的哪些问题了。例如对于 &a 和 &*p，可看做求左值 a 和 *p 的地址（不考虑空指针，*p 的地址就是 p 的值），对于赋值 *p = 1，可以看做先求左值 *p 的地址，再向该地址写入 1。 因此，在生成代码的过程中，对于左值，我们不能生成其具体的值，而要先生成它们的地址。对于一个表达式，我们需要先确定那些部分是左值，并求得它们的地址作为中间结果，然后才能生成正确的代码。通过观察，我们可以归纳出左值的判定方法： 出现在赋值号 = 的左边，或是取地址符 & 的右边； 是一个标识符，或是 * 开头的表达式（(*p) 等有括号的形式也算）。 在建立了 AST 后，我们可以很容易求出哪些节点是左值，可将其作为节点的属性，以供之后使用。 此外，我们还需要进行左值检查，以拒绝编译形如 123 = a 的错误输入。根据上述左值的判定方法，如果表达式的某一部分满足第 1 条，但不满足第 2 条，就是不合法的。 基于左值的代码生成框架 现在，我们假设已经求出了 AST 的哪些节点是左值。在之后的遍历 AST 生成汇编码时，只需对左值生成地址，对右值生成值。在我们的文法中，左值一定出现在 非终结符，其文法为： ::= Identifier | '*' | '&' | ... 下面给出了用于生成汇编码的伪代码： function visitFactor(ctx) { if (ctx ::= Ident) { // ::= Identifier emitAddress(Ident); // 计算变量 Ident 的地址 if (ctx.isLValue) { // do nothing // 如果是左值，直接返回其地址 } else { emitLoad(); // 否则，再生成一条 Load 指令来取得变量的值 } } else if (ctx ::= '*' factor) { // ::= '*' visitFactor(factor); // 访问子 factor 计算其值 if (ctx.isLValue) { // do nothing // 如果是左值，直接返回该值 } else { emitLoad(); // 否则，再生成一条 Load 指令来解引用 } } else if (ctx ::= '&' factor) { // ::= '&' visitFactor(factor); // 子 factor 一定是左值，直接访问以得到其地址 } else { // ... } } 生成左值的地址 如上一节所述，左值只可能出现在两种地方： 标识符：地址即该变量的地址； 解引用符 * 之后：地址即之后那部分的值； 第二种情况可直接忽略，我们只需考虑如何计算一个变量的地址。在上一个 lab 我们引入了全局变量，所以变量可分为两种： 局部变量：保存在栈上，使用 lw t0, offset(fp) 指令获取其值。由于我们使用栈来传参，所以参数也可认为是局部变量。 全局变量：保存在数据段，使用 lui t1, %hi(N); lw t0, %lo(N)(t1) 指令获取其值。 要从取值变成取地址，只需将 lw 改成 addi： addi t0, fp, offset # 获取局部变量的地址，保存到 t0 lui t1, %hi(N) addi t0, t1, %lo(N) # 获取全局变量 N 的地址，保存到 t0 之后，可再用一条 Load 或 Store 指令来实现获取变量的值或给变量赋值： lw t1, 0(t0) # 读取内存地址 t0 中的内容到 t1 sw t1, 0(t0) # 将 t1 写入内存地址 t0 赋值语句 最后，我们还需要修改赋值语句的生成过程。在之前的语法分析阶段，赋值语句的文法已经改为了 - ::= Identifier \"=\" | + ::= \"=\" | 其中要求 是一个左值。 我们在之前生成赋值语句时是这么做的： 生成 expr 的代码 # 结果存在 t0 sw t0, offset(fp) # offset 为变量在栈帧中的位置 现在，已经没有变量了，而是变成了左值。我们就先生成计算左值地址的代码，然后再生成一条 Store 指令即可： 生成 factor 的代码 # 结果（左值的地址）存在 t0 生成 expr 的代码 # 结果存在 t1 sw t1, 0(t0) # 将 t1 写入内存地址 t0 "},"docs/lab11/part4-1-task.html":{"url":"docs/lab11/part4-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新汇编代码生成过程，以正确处理指针运算符。并通过 step[1-11] 的测试用例。 "},"docs/lab11/summary.html":{"url":"docs/lab11/summary.html","title":"小结","keywords":"","body":"小结 "},"docs/lab12/part0-intro.html":{"url":"docs/lab12/part0-intro.html","title":"摘要","keywords":"","body":"labX 介绍 "},"docs/lab12/part4-codegen.html":{"url":"docs/lab12/part4-codegen.html","title":"代码生成","keywords":"","body":"代码生成 数组定义 数据的内存空间是连续的，因此无论数组的原型是几维的，都可以看做是一个一维的大数组。例如，对于一个数组 int a[d1][d2]⋯[dn]\\mathtt{int}~a[d_1][d_2]\\cdots[d_n]int a[d​1​​][d​2​​]⋯[d​n​​]，可看做是 int a′[d1d2⋯dn]\\mathtt{int}~a'[d_1d_2\\cdots d_n]int a​′​​[d​1​​d​2​​⋯d​n​​]。访问 a[i1][i2]⋯[in]a[i_1][i_2]\\cdots[i_n]a[i​1​​][i​2​​]⋯[i​n​​]，就是访问 a′[i1d2d3⋯dn+i2d3d4⋯dn+⋯+in]a'[i_1d_2d_3\\cdots d_n + i_2d_3d_4\\cdots d_n + \\cdots + i_n]a​′​​[i​1​​d​2​​d​3​​⋯d​n​​+i​2​​d​3​​d​4​​⋯d​n​​+⋯+i​n​​]。 我们需要考虑定义数组时，是作为局部变量还是全局变量： 当某个局部变量定义为数组时，数组空间分配在栈上。这与普通变量的定义基本没区别，同样需要算出在栈帧上的偏移量，只不过大小不再是固定的 4 字节，而是数组的元素个数再乘 4 (字节/元素)，因此计算其他变量的偏移量时也要做相应修改。由于不支持数组的初始化，分配完栈帧后不用管它就行，即使这段栈空间保留了之前变量的信息，因此数组还有其他未初始化的局部变量的初值都是不确定的。 当某个全局变量定义为数组时，数组空间分配在程序的数据段。同样我们不考虑 BSS 段，直接将其放到 .data 中。作为全部变量时，数组中每个元素默认初始化为 0，可用如下汇编码来将连续一段内存初始化为 0： .align 2 a: .zero 400 其中 .zero 后面的数字即这段内存的大小（单位字节）。上述汇编码可由定义在全局的 int a[100]; 或 int a[10][10]; 生成。 在 RISC-V 指令集中，addi、lw、sw 等 I 型和 S 型指令的立即数大小只有 12 位，因此我们不能定义一个很大的数组作为局部变量，否则那些分配栈帧、Load/Store 局部变量的指令的偏移量就会超出 12 位。你可以实现对这种情况的特殊处理，使用其他指令进行代替，不过我们的测试集保证了不会出现这种情况。 下标运算 指针下标 我们允许对指针和数组类型进行下标运算。首先来看指针的下标运算。指针的下标运算非常类似于解引用运算 *，只是需要加上一个偏移，大小为下标乘上指针基类型的大小，即 p[i] 等价于 *(p + i * size)。另外需要注意，我们在 lab11 中提到了左值的概念，* 运算后的结果可以是左值，类似地，指针的下标运算也可以是左值： int *p; p[0] = 1; // p[0] 是左值 int a = p[1]; // p[1] 是右值 int *q = &p[2]; // p[2] 是左值 于是，我们按照实现解引用运算的方法，即可实现指针的下标运算。 数组下标 然后再来看数组的下标运算。数组的下标运算可以分为两类： 当下标运算的次数等于数组的维度时，结果是数组中的元素。这种情况与指针的下标运算类似，可以作为右值，结果是数组中元素的值；也可以作为左值，结果是数组中元素的地址。 当下标运算的次数小于数组的维度时，结果是一个数组。由于任何数组可看做一个一维大数组，此时的结果也可以看做是原数组中的一个子数组。当之后对该结果进行转指针、取下标等运算时，都是相对于这个子数组来说的。之后要取子数组中的哪个元素现在还是未知的，因此无论之后是否有可能成为左值，这一步都应该返回子数组的地址。 对于第 1 种情况，与指针的下标运算类似处理；对于第 2 种情况，关键是要求出子数组的地址。由于下标运算在文法中是递归定义的，我们可以自然地得出地址的计算方法： 对于数组类型的变量 Ident，地址即 Ident 在栈或数据段的地址； 对于子数组 array[i]，地址是 array 的地址加上 i * sizeof(array[i])。 例如，对于数组 int a[3][4][5]，有： a[i] 的地址是 a + (i * 4 * 5) * sizeof(int)； a[i][j] 的地址是 a + [(i * 4 * 5) + (j * 5)] * sizeof(int)； a[i][j][k] 的地址是 a + [(i * 4 * 5) + (j * 5) + k] * sizeof(int)。 总结一下，无论是指针还是数组，无论是左值还是右值，我们都可以用同一套代码框架来生成汇编码： function visitSubscript(ctx) { // ::= '[' expr ']' visitPostfix(postfix); // 计算要取下标的表达式的值，设结果保存在 t0 visitExpr(expr); // 计算下标的值，设结果保存在 t1 emitMul(\"t1\", \"t1\", ctx.type.size); // t1 = t1 * sizeof(结果的类型) emitAdd(\"t0\", \"t0\", \"t1\"); // t0 = t0 + t1，此时的结果即下标运算后子数组或元素的地址 if (ctx.type == Array || ctx.isLValue) { // do nothing // 如果结果是数组类型，或是左值，直接返回其地址 } else { emitLoad(); // 否则，再生成一条 Load 指令来取出该地址中保存的值 } } function visitPrimary(ctx) { if (ctx ::= Ident) { // ::= Identifier emitAddress(Ident); // 计算变量 Ident 的地址 if (ctx.type == Array || ctx.isLValue) { // do nothing // 如果变量是数组类型，或是左值，直接返回其地址 } else { emitLoad(); // 否则，再生成一条 Load 指令来取得变量的值 } } else { // ... } } 指针算术运算 这一步非常简单，我们要支持的所有指针算术运算就这么多： 指针加整数，或整数加指针：只需增加一步，将整数操作数乘上指针基类型的大小。 指针减整数：与指针加法一样，只需增加一步，将整数操作数乘上指针基类型的大小。 指针减指针：先直接做减法，然后除以指针基类型的大小（要求两指针基类型相同）。 由于指针的基类型只能是 int 或指针，其大小都是 4 字节，你可以用 slli、srai 指令进行左移、右移来代替乘除运算。 "},"docs/lab12/part4-1-task.html":{"url":"docs/lab12/part4-1-task.html","title":"任务","keywords":"","body":"☑任务： 更新汇编代码生成过程，以正确处理数组类型、下标运算以及指针算术运算。并通过 step[1-12] 的测试用例。 恭喜你通过自己的努力，完成了 minidecaf lab1-lab12，从零开始实现了一个自己的编译器！ "},"docs/lab12/summary.html":{"url":"docs/lab12/summary.html","title":"小结","keywords":"","body":"小结 "},"REFERENCE.html":{"url":"REFERENCE.html","title":"参考资料","keywords":"","body":"参考资料 Writing a C Compiler: by Nora Sandler An Incremental Approach to Compiler Construction : by Abdulaziz Ghuloum "}}
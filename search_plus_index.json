{"./":{"url":"./","title":"实验简介","keywords":"","body":"MiniDecaf 编译实验 实验概述 MiniDecaf 1 是一个 C 的子集，去掉了include/define等预处理指令，多文件编译支持，以及struct/指针等语言特性。 本学期的编译实验要求同学们通过多次“思考-实现-重新设计”的过程，一步步实现从简单到复杂的 MiniDecaf 语言的完整编译器，能够把 MiniDecaf 代码编译到 RISC-V 汇编代码。进而深入理解编译原理和相关概念，同时具备基本的编译技术开发能力，能够解决编译技术问题。MiniDecaf 编译实验分为多个 stage，每个 stage 包含多个 step，共包含 11 个 step。每个 step 大家都会完成一个可以运行的编译器，把不同的 MiniDecaf 程序代码编译成 RISC-V 汇编代码，可以在 QEMU/SPIKE 硬件模拟器上执行。随着实验内容一步步推进，MiniDecaf 语言将从简单变得复杂。每个步骤都会增加部分语言特性，以及支持相关语言特性的编译器结构或程序（如符号表、数据流分析方法、寄存器分配方法等）。下面是采用 MiniDecaf 语言实现的快速排序程序，与 C 语言相同。为了简化实现，MiniDecaf 不支持以数组作为函数参数，因此快速排序的数组以全局数组的形式给出： int a[1000]; int qsort(int l, int r) { int i = l; int j = r; int p = a[(l+r)/2]; while (i p) j = j - 1; if (i > j) break; int u = a[i]; a[i] = a[j]; a[j] = u; i = i + 1; j = j - 1; } if (i l) qsort(l, j); return 0; } 2021 年秋季学期基本沿用了 2020 年秋季学期《编译原理》课程的语法规范，为降低实验难度，进一步去掉了指针等语言特性。和 2020 年秋季学期课程实验所不同的是，为了贴合课程教学内容，提升训练效果，课程组设计了比较完善的编译器框架，包括词法分析、语法分析、语义分析、中间代码生成、数据流分析、寄存器分配、目标平台汇编代码生成等步骤，并采用 C++ 与 Python 两种语言实现。每个 step 同学们都会面对一个完整的编译器流程，但不必担心，实验开始的几个 step 涉及的编译器框架知识都比较初级，随着课程实验的深入，将会循序渐进地引入各个编译器功能模块，并通过文档对相关技术进行分析介绍，便于同学们实现相关编译功能模块。 实验起点和基本要求 本次实验一共设置 12 个步骤（其中 step0 为环境配置，主要是 RISC-V 工具链和硬件模拟器的的安装与使用，以及学会使用助教提供的自动测试脚本）。后续的 step1-11 我们将由易到难完成 MiniDecaf 语言的所有特性，由于编译器的边界情况很多，因此你只需通过我们提供的正例与负例即可。 我们以 stage 组织和发布实验，各个 stage 组织如下： 第一个编译器（step0-step1）。我们给的实验框架可以通过所有测试用例，你需要做的事情为跟着文档阅读学习实验框架代码。请各位同学注意，stage0 尤为重要，掌握好实验框架是高质量和高效率完成后续实验的保证。 常量表达式（step2-step4）。在这个 stage 中你将实现常量操作（加减乘除模等）。 变量和语句（step5-step6）。在这个 stage 中你将第一次支持变量声明与赋值，以及条件跳转语句。 块语句和循环（step7-step8）。在这个 stage 中你将支持块语句，所谓块语句，就是多个语句组成一个块，每个块都是一个作用域。作为一种特殊的块语句，你也将实现循环操作。 全局变量和函数（step9-step10）。在这个 stage 中你将支持声明全局变量，并且支持函数的声明和调用。 数组（step11）。在这个 stage 中，你将支持数组，包括全局数组和局部数组。 同时，为了帮助大家通过实验学习语法分析，我们单独设置了一个手工自顶向下语法分析的小实验，需要大家手动实现一个支持 step1 - step6 语法规范的手工 parser。 设置这个实验的目的是为了帮助大家通过实验学习了解语法分析，语法分析工具（如 Bison）掩盖了很多语法分析的实现细节。 其中，stage0 为环境配置和框架学习，无需进行编程，不计入成绩。stage1 - stage3 和手工语法分析器为 4 个基础关卡，你需要通过它们以拿到一定的分数（40%，每个关卡 10%）。stage4 - stage5 为升级关卡，如果你学有余力，完成它们可以减少期末考试在总评中所占的比重（完成一个关卡，替代 10% 的期末考试成绩）。 需要注意的是，由于我们的测试用例中，之后的 step 测试用例会包含之前的语法特性，所以只完成 stage5 而不完成 stage4 以获得 10% 的期末成绩替代是不支持的。 关于文档，我们以 step 组织文档，每个 step 的文档都将以如下形式组织：首先我们会介绍当前 step 需要用到的知识点，其次我们会以一个当前 step 具有代表性的例子介绍它的整个编译流程。在之前 step 中已经介绍的知识点，我们会略过，新的知识点和技术会被详细介绍。 实验提交 TODO: 下面的是 2020 年的实验安排，需更新到 2021 年的版本。 你需要使用 git 对你的实验做版本维护，然后提交到 git.tsinghua.edu.cn。 大家在网络学堂提交帐号名后，助教给每个人会建立一个私有的仓库，作业提交到那个仓库即可。 关于 git 使用，大家也可以在网上查找资料。 每次除了实验代码，你还需要提交 实验报告，其中包括 你的学号姓名 简要叙述，为了完成这个 step 你做了哪些工作（即你的实验内容） 指导书上的思考题 如果你复用借鉴了参考代码或其他资源，请明确写出你借鉴了哪些内容。并且，即使你声明了代码借鉴，你也需要自己独立认真完成实验。 晚交扣分规则 是： 晚交 n 天，则扣除 n/15 的分数，扣完为止。例如，晚交三天，那你得分就要折算 80%。 备注 1. 关于名字由来，由于往年的实验叫 Decaf，我们在新的且更简单的语言规范下复用了 Decaf 的编译器框架，所以今年的实验就叫 MiniDecaf 了。 ↩ "},"docs/step0/todo.html":{"url":"docs/step0/todo.html","title":"待完善","keywords":"","body":"还需要完善的地方 [ ] 更新 2021 年实验提交安排，为同学们创建清华 git 仓库（README.md，step0/testing.md）@杨耀良 [ ] 将实验框架放到 github 上（step0/testing.md）@陈之杨@曾军 [ ] 加入 python 框架后端相关代码位置（step1/arch.md）@杨耀良 [ ] step1 词法分析语法分析需完善，需要排考虑如何排版和呈现（step1/example.md）@刘润达@周智 [ ] 快速上手 flex 和 bison 的教程（step1/...）@刘润达 "},"docs/step0/riscv_env.html":{"url":"docs/step0/riscv_env.html","title":"RISC-V环境配置","keywords":"","body":"RISC-V 环境配置 必做：RISC-V 的 gcc 和 qemu 我们的编译器只生成 RISC-V 汇编，然后再使用 gcc 把 RISC-V 汇编变成 RISC-V 可执行文件，最后用 qemu/spike 等模拟器来运行 RISC-V 可执行文件。 这里的 gcc 和常说的 gcc 不一样。 常说的 gcc 运行在我们的 x86 机器上、把 C 编译到 x86 可执行文件； 而这里的 gcc 虽然也运行在我们的 x86 机器上，却要编译到 RISC-V 可执行文件。 这种“gcc 跑在 x86 却编译出 RISC-V 代码”的操作被称为交叉编译（cross compilation）。 因此我们不能直接使用有些系统自带的 gcc，这种 gcc 生成的可执行程序只能在你本机（x86）上运行。 我们需要下载安装 riscv64-unknown-elf-gcc，用来生成 RISC-V 可执行程序。 我们提供了预编译的 riscv64-unknown-elf-gcc 和 qemu 模拟器，不过只能在 Linux/Mac 下运行，Windows 的同学可以使用 WSL，或者运行一个虚拟机。 命令行基础操作我们就不赘述了，大家可以自己在网上查找资料。 下面是环境配置指南，请阅读自己的系统的那一小节。 你的编译器 gcc qemu/spike C-- 源文件 ------------> RISC-V 汇编 -----> 可执行文件 --------> 输出 Windows 用户环境配置指南 下面描述了 WSL 的一种参考方法。 你还可以开一个 Linux 虚拟机，使用 Virtualbox 或 VMWare 等，然后参考下面 Linux 配置。 Win10 设置 参考 https://blog.csdn.net/daybreak222/article/details/87968078 ，设置“开发者模式”以及“启用子系统功能”。 打开Microsoft Store，搜索Ubuntu，选择ubuntu20.04. 按照下面的 Linux 用户环境配置指南安装 riscv 工具链。 Linux 用户环境配置指南 从网络学堂下载 riscv-prebuilt.tar.gz 压缩包并解压（命令是 tar xzf riscv-prebuilt.tar.gz） 安装工具链 cp riscv-prebuilt/* /usr/ -r 在第 2. 步，你可以选择不安装到系统目录下。相应的，你需要设置环境变量： export PATH=$PATH:/path/to/riscv-prebuilt/bin，把 /path/to 替换为你的解压目录。 把上面这条命令加到你的 ~/.bashrc 文件中，这样不用每次打开终端都要重新设置。 每次改完 ~/.bashrc 你都需要重启终端，以便改动生效。 （如果你不用系统自带的 bash 而是用 zsh 之类的 shell，那加到 ~/.zshrc 等 shell 配置文件里） macOS 用户环境配置指南 从这里下载预编译好的 RISC-V 工具链并解压到你喜欢的目录。 由于 macOS 不支持 QEMU 的用户态模式，我们使用 Spike 模拟器和一个简易内核 riscv-pk 提供用户态程序的运行环境。你可以选择下面两种安装方法中的任意一种： 从网络学堂上下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，不过还需要通过 Homebrew 安装依赖 device tree compiler： $ brew install dtc 通过 Homebrew 安装 Spike（会自动安装 dtc）： $ brew tap riscv/riscv $ brew install riscv-isa-sim 然后从网络学堂上下载我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz，只用里面的 pk。 Homebrew 也提供了 riscv-pk，不过那是 64 位的，而我们需要 32 位的，请使用我们预编译的 riscv-pk 或自行编译。 （可选）设置环境变量，方法与 Linux 一样，见上一节。如果不设置每次使用 gcc 和 spike 时都要输入完整路径。不过对于 pk 设置环境变量不管用，要么把它放到系统目录 /usr/local/bin/pk，要么每次都用完整路径。 测试你 GCC 和 Spike 是否成功安装，详见RISC-V 的工具链使用。 必做：测试你是否正确配置好了环境 创建 test.c 文件，其中写入如下内容 #include int main() { printf(\"Hello world!\\n\"); } 编译 test.c 文件，gcc 应该输出一个可执行文件 a.out。但 a.out 是 RISC-V 可执行文件，所以我们的 X86 计算机无法运行。 $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 test.c $ ls a.out a.out $ ./a.out bash: ./a.out: cannot execute binary file: Exec format error 后面RISC-V 的工具链使用总结了 gcc 和 qemu 在编译实验中可能需要的用法。 使用 qemu 执行 a.out$ qemu-riscv32 a.out Hello world! 备注 1. 开头的 $ 表示接下来是一条命令，记得运行的时候去掉 $。例如，让你运行 $ echo x，那你最终敲到终端里的是 echo x（然后回车）。如果开头没有 $，那么这一行是上一条命令的输出（除非我们特别说明，这一行是你要输入的内容）。 ↩ "},"docs/step0/riscv.html":{"url":"docs/step0/riscv.html","title":"RISC-V 的工具链使用","keywords":"","body":"RISC-V 相关信息 RISC-V 是一个很像 MIPS 的 RISC 指令集架构，编译实验要求你的编译器把 MiniDecaf 程序编译到 RISC-V 汇编。 指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"。 另外这里也有（非官方的）指令用法说明。 不过事实上，很多时候看 gcc 输出的汇编比看什么文档都有用。 RISC-V 工具使用 我们提供预先编译好的 RISC-V 工具，在环境配置中已经叙述了安装和使用方法。 下面汇总一下。 注意，我们虽然是用的工具前缀是 riscv64， 但我们加上参数 -march=rv32im -mabi=ilp32 以后就能编译到 32 位汇编 1。 使用时记得加这个参数，否则默认编译到 64 位汇编。 我们假设你已经正确设置好了环境变量，否则运行 riscv64-unknown-elf-gcc 或 qemu-riscv32 或 spike 时请用完整路径。 gcc 编译 input.c 到汇编 input.s，最高优化等级（否则输出的汇编会很冗长） # input.c 的内容 $ cat input.c int main(){return 233;} # 编译到 input.s $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c # gcc 的编译结果 $ cat input.s .file \"input.c\" .option nopic .attribute arch, \"rv32i2p0_m2p0\" .attribute unaligned_access, 0 .attribute stack_align, 16 .text .section .text.startup,\"ax\",@progbits .align 2 .globl main .type main, @function main: li a0,233 ret .size main, .-main .ident \"GCC: (SiFive GCC 8.3.0-2020.04.0) 8.3.0\" gcc 编译 input.s 到可执行文件 a.out # input.s 的内容，就是上面汇编输出的简化版本 $ cat input.s .text .globl main main: li a0,233 ret # 编译到 a.out $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 input.s # 输出结果，能看到是 32 位的 RISC-V 可执行文件 $ file a.out a.out: ELF 32-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped 【Linux 用户】qemu 运行 a.out，获取返回码 # 运行 a.out $ qemu-riscv32 a.out # $? 是 qemu 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 【macOS 用户】Spike 模拟器运行 a.out，获取返回码 # 运行 a.out # /usr/local/bin/pk 替换为你自己的 pk 路径 $ spike --isa=RV32G /usr/local/bin/pk a.out bbl loader # $? 是 spike 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 1. 这里的 rv32im 表示使用 RV32I 基本指令集，并包含 M 扩展（乘除法）。本实验中我们不需要其他扩展。 ↩ "},"docs/step0/env.html":{"url":"docs/step0/env.html","title":"实验框架环境配置","keywords":"","body":"实验框架环境配置 C++ 实验框架环境配置 关于操作系统，助教推荐使用 Linux 环境（如 Ubuntu，Debain 或 Windows 下的 WSL 等），当然你也可以在类 Unix 系统环境（Mac OS）中进行开发。助教不推荐直接在 Window 中搭建开发环境。对于 C++ 实验框架，你需要安装或保证如下软件满足我们的要求： Flex Flex 是一个自动生成词法分析器的工具，它生成的词法分析器可以和 Bison 生成的语法分析器配合使用。我们推荐从 Github 下载安装最新版本(在 2021.9.1, 最新版本是 2.6.4,不推荐使用低于 2.6 的版本)。 在 Ubuntu 下，apt-get install flex 安装的 Flex 版本为 2.6，是可用的。 在 Mac OS 下，推荐使用 homebrew 进行安装，brew install flex 安装的 Flex 版本为 2.6，是可用的。 Bison Bison是一个自动生成语法分析器的工具,它生成的语法分析器可以和Flex生成的词法分析器配合使用。 在 Ubuntu 下，我们推荐从官网下载安装最新版本（在2021.9.1, 最新版本是3.7.6，不推荐使用低于3.7的版本,如 Ubuntu apt-get install 安装的3.0.4版本是不可用的）。下载解压 tar.gz 文件后， 在路径下执行./configure && make && make install, 就应该能正确安装。如果发生失败，就尝试sudo ./configure sudo make, sudo make install, 然后bison --version检查一下版本是否为3.7.6就可以了。 在 Mac OS 下，推荐使用 homebrew 进行安装，brew install bison 安装的 Bison 版本为 3.7.6，是可用的。 如果你是 Mac OS 用户，需要注意的是，系统可能已经安装了低版本的 flex 与 bison，安装的新版本工具会被覆盖，需要通过以下命令确认一下二者的版本： $ flex --version $ bison --version 如果版本较低，需要将新安装的工具路径加入环境变量，关于路径，在助教的电脑上是： Flex: /usr/local/Cellar/flex/2.6.4_2/bin Bison: /usr/local/Cellar/bison/3.7.6/bin Boehmgc C++ 语言的实验框架中，为了简化内存分配的处理，使用了一个第三方垃圾回收库，简单来说，使用这个垃圾回收库提供垃圾回收功能后，我们在框架里可以new了之后不用delete也不会出问题。 在 Ubuntu 下，通过 apt-get install libgc-dev 安装的 boehmgc 库是可用的。 在 Mac OS 下，通过 brew install libgc 安装的 boehmgc 库是可用的。 gcc 助教推荐的 gcc 版本为 8.5.0。 需要注意的是，如果你使用 Mac OS 进行开发，Mac 自带的 g++ 命令极有可能软链接到了 clang，我们的实验框架在某些版本的 clang 下无法编译通过，因此推荐你使用如下方法安装特定版本的 gcc。安装完成之后，你需要使用 gcc-8，g++-8 来调用特定版本的 gcc，g++，同时你需要修改我们提供的 Makefile 中的 CC 与 CXX 选项。 另外，由于你使用了自己安装的 g++-8 编译程序，你需要将 boehmgc 的路径加入 g++ 的环境变量： # 你需要将以下内容加入你终端的配置文件（zsh->.zshrc; bash->.bash_profile) export CPLUS_INCLUDE_PATH=\"$CPLUS_INCLUDE_PATH:/usr/local/include\" export LIBRARY_PATH=\"$LIBRARY_PATH:/usr/local/lib\" export LD_LIBRARY_PATH=\"$LD_LIBRARY_PATH:/usr/local/lib # Mac OS $ brew install gcc@8 # Ubuntu $ sudo apt-get install gcc-8 需要说明的是，C++ 的环境配置较为复杂，教程可能无法覆盖到所有问题，欢迎随时联系助教。 python 实验框架环境配置 关于操作系统，类似 C++，但由于 python 的跨平台性，理论上也可以在 Windows 下进行开发。但不保证Windows和在线测试环境下程序行为的一致性。由于 python 自带的包管理系统 pip，安装推荐的依赖只需执行如下命令。 $ pip install -r ./requirements.txt python 3.9 框架本身在 python 3.9 下进行开发，使用了 python 3.9 的新特性并仅在这一版本下经过测试。请保证你所使用的 python 版本高于此版本。 argparse 框架使用了 argparse 以处理命令行参数。官方文档中提供了它的教程。 ply ply是一个自动生成词法分析器和语法分析器的工具，其中ply.lex为词法分析相关的模块而ply.yacc为语法分析相关。我们提供了 ply 的文档。 助教推荐使用类似 Miniconda 的系统以最小化出现奇怪依赖问题的风险。助教推荐在项目中使用 type hints，如果你习惯在 vscode 中进行开发的话同时推荐使用 pylance 这一插件。 必做：测试你是否正确配置好了环境 C++ 实验框架 确定各工具的版本 # g++ $ g++-8 -v # Flex $ flex --version # Bison $ bison --version "},"docs/step0/testing.html":{"url":"docs/step0/testing.html","title":"运行实验框架","keywords":"","body":"推荐：运行实验框架 配好环境以后，我们强烈推荐你构建运行我们提供的实验框架初始代码。 接下来我们会用到 git。 git 的安装和使用会在软件工程课上讲述，同学们也自行查阅相关资料，也可以参考这里 。 通过 git clone 把测例和实验框架实现克隆到同一个目录下面。 TODO：框架上传之后更新链接。 C++ 和 Python 框架在同一个仓库的不同分支里面。 按照参考实现的 README 配置好它的环境。 按照测例的 README 运行测试 step1，实验框架给出的初始代码可以通过 step1 的所有测例。 测试运行的 输出结果 大致如下。 $ STEP_UNTIL=1 ./check.sh gcc found qemu found parallel found OK testcases/step1/multi_digit.c OK testcases/step1/newlines.c ...... 其他测试点，太长省略 "},"docs/step0/faq.html":{"url":"docs/step0/faq.html","title":"常见问题","keywords":"","body":"常见问题 Invalid ELF image for this architecture $ qemu-riscv32 a.out a.out: Invalid ELF image for this architecture 解决方法： 注意编译时 gcc 要用 riscv64-unknown-elf-gcc，并且加上 -march=rv32im -mabi=ilp32。 command not found $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c riscv64-unknown-elf-gcc: command not found 或者运行 qemu-riscv32 时提示上面的错误。 解决方法： 你是否按照环境配置中指南配好环境？如果你没有安装到系统目录，是否设置 PATH，并且把 export PATH... 命令放到 ~/.bashrc？ Spike pk 卡死 执行 spike pk 直接卡死，需要按多次 Ctrl-C 后才能退出。 解决方法： 可能是忘加了 --isa=RV32G 选项，在用 64 位的 Spike 跑 32 位 pk。 如果你加了该选项也有这个问题，可能是你安装了 64 位的 pk 然后在用 32 位的 Spike 跑，请使用我们预编译的 32 位 pk。 Spike 运行报错：could not open pk $ spike --isa=RV32G pk libc++abi.dylib: terminating with uncaught exception of type std::runtime_error: could not open pk (did you misspell it? If VCS, did you forget +permissive/+permissive-off?) 解决方法： Spike 找不到 pk，请输入 pk 的完整路径。 Spike 运行报错：assertion failed: IS_ELF32(eh) $ spike --isa=RV32G pk a.out bbl loader ../pk/elf.c:42: assertion failed: IS_ELF32(eh) Power off 解决方法： 你可能编译出了 64 位的 a.out，注意编译时 gcc 要用 riscv64-unknown-elf-gcc，并且加上 -march=rv32im -mabi=ilp32。 Spike 运行报错：Child dtb process failed $ spike --isa=RV32G /usr/local/bin/pk a.out Failed to run dtc: No such file or directory Child dtb process failed 解决方法： 使用 Homebrew 安装 device tree compiler： $ brew install dtc macOS 下找不到 realpath 命令 macOS 下运行 minidecaf-tests 里的 check.sh 报错： ./check.sh: line 25: realpath: command not found ./check.sh: line 26: realpath: command not found ./check.sh: line 30: $asmfile: ambiguous redirect ...... 解决方法： 使用 Homebrew 安装 coreutils： $ brew install coreutils "},"docs/step1/arch.html":{"url":"docs/step1/arch.html","title":"MiniDecaf 编译器结构","keywords":"","body":"MiniDecaf 编译器结构 MiniDecaf 编译器大致划分为三个部分：前端、中端、后端。通过编译器前端，可以读入 MiniDecaf 源程序，然后通过词法分析和语法分析将源程序转化为一个抽象语法树（Abstract Syntax Tree, AST)，接下来通过扫描 AST 进行语义分析，检查是否存在语义错误；在编译器中端，通过扫描 AST 生成中间代码 —— 三地址码；在编译器后端中，将三地址码转换为 RISC-V 汇编代码。下面依次介绍上述编译步骤，以及对应框架代码的位置。 我们在这里针对每个步骤只是简要介绍，目的是给同学们一个大致的印象：编译器到底是由哪些部分组成的，这些部分又有什么作用。具体的技术点，我们将在用到的 step 作详细介绍。 词法分析和语法分析 此部分对应框架源码位置： C++ 框架：词法分析程序位于 src/frontend/scanner.l；语法分析程序位于 src/frontend/parser.y；语法树位于 src/ast/。 Python 框架：词法分析程序位于 frontend/lexer；语法分析程序位于 frontend/parser；语法树位于 frontend/ast。 编译器前端分为两个子任务，一是词法分析，二是语法分析。词法分析的功能是从左到右扫描 MiniDecaf 源程序，识别出程序源代码中的标识符、保留字、整数常量、算符、分界符等单词符号（即终结符），并把识别结果返回给语法分析器，以供语法分析器使用。语法分析是在词法分析的基础上针对所输入的终结符串建立语法树，并对不符合语法规则的 MiniDecaf 程序进行报错处理。一般而言，这一步所生成的语法树并非表示了所有语法细节的语法分析树，而是只表示其树形结构的抽象语法树（Abstract Syntax Tree, AST）。比如，对于下面这一段简单的MiniDecaf 代码： if (i) i = 1; 它对应的完整语法分析树可能长这样： if_stmt |- \"if\" |- \"(\" |- Identifier(\"i\") |- \")\" |- assign_stmt |- Identifier(\"i\") |- \"=\" |- Int(1) |- \";\" 其中双引号下的和大写字母开头的都为词法分析器产出的终结符。而对应的抽象语法树可能长这样： if_stmt |- (condition) Identifier(\"i\") |- (body) assign_stmt |- (lh) Identifier(\"i\") |- (rh) Int(1) AST省略掉了完整的语法分析树中不必要的细节，有利于简化树的结构与后续对树的处理。 词法分析和语法分析的最终结果是一棵跟所输入的 MiniDecaf 源程序相对应的语法树。本阶段的实验重点是掌握 LEX 和 YACC 的用法，了解编译器自动构造工具的特点，并且结合实验内容理解正规表达式、自动机、LALR(1) 分析等理论知识在实践中的应用。 语义分析 此部分对应框架源码位置： C++ 框架：符号表构建位于 src/translation/build_sym.cpp；类型检查位于 src/translation/type_check.cpp；符号表相关的数据结构位于src/symb；作用域相关数据结构位于 src/scope。 Python 框架：符号表构建位于 frontend/typecheck/namer.py；类型检查位于 frontend/typecheck/typer.py；符号表相关的数据结构位于frontend/symbol；作用域相关数据结构位于 frontend/scope。 语法分析树的建立可以说明所输入的 MiniDecaf 源程序在语法规范上是合法的，但是要进行有效的翻译，编译器还需要理解每个程序语句的含义。了解程序含义的过程称为语义分析。 可以把语义分析过程分为两个部分：分析符号含义和检查语义正确性。分析符号含义是指对于表达式中所出现的符号，找出该符号所代表的内容，这个工作主要通过检索符号表来实现。检查语义正确性指的是要检查每个表达式的操作数是否符合要求，也就是说检查每个表达式是否为语言规范中所规定的合法的表达式。由于不合法的语句具体含义在语言规范中没有规定，从而使得编译器没法明确这些语句的确切含义，所以检查语义的正确性是很有必要的。如果一个程序成功通过语义分析，则说明这个程序的含义对于编译器来说是明确的，从而翻译工作才能得以进行。 具体来说，在这一阶段中，我们需要对 AST 两遍扫描，分别完成以下的检查： 符号表构建：声明了哪些标识符，每一处使用的标识符对应于哪一处的声明。 类型检查：各语句和表达式是否类型正确。 如果在语义分析阶段发现问题，那么整个编译过程在这一阶段结束后就终止，并报告编译错误。所有的语义错误都应该且只应该在这一阶段进行报告。下面分别介绍符号表构建和类型检查的内容。 符号表构建 针对 MiniDecaf 程序中所有定义的标识符，包括函数名和变量名，我们统一用一种具有层次结构的符号表来维护。使用符号表的好处主要有两个：第一，在分析各语句和表达式时，若它们引用了某些标识符，我们可以在符号表中查询这些符号是否有定义以及相关信息（如类型）；第二，符号表的层次结构与作用域是一一对应的，因此容易检查出符号定义是否有冲突。 由于 Step1-4 中只需要考虑常量的计算，直到 Step5 开始才需要考虑构建符号表。 类型检查 完成符号表构建后，我们就可以自顶向下地遍历 AST，逐一对每个语句和表达式进行类型检查。 对于静态类型 (statically-typed) 语言，在语言设计之初，设计者都会考虑该语言支持表达哪些类型，并给出定型规则 (typing rules)。 在已知定型规则的情况下编码实现类型检查算法并不困难——往往只要逐条将其翻译为代码即可。 事实上，由于 MiniDecaf 代码的基本类型只有整数类型（int），因此我们在类型检查时只需要考虑 int 和 int 数组两种类型。在 Step11 之前，都基本不需要考虑类型检查。 中间代码生成 C++ 框架：三地址码定义位于 src/tac；中间代码生成位于 src/translation/translation.cpp。 Python 框架：三地址码定义位于 utils/tac；中间代码生成位于 frontend/tacgen/tacgen.py。 在对 AST 进行语义分析后，我们将在这一阶段把带有类型标注的 AST 进行翻译成适合后端处理的一种中间表示。中间表示（也称中间代码，intermediate representation / IR）是位于语法树和汇编之间的一种程序表示。 它不像语法树一样保留了那么多源程序的结构，也不至于像汇编一样底层。 由于源语言（MiniDecaf）和目标语言（RISC-V 汇编）一般有比较大的差别，因此直接把语法树翻译为目标语言中的合法程序通常是比较困难的。大多数编译器实现中所采取的做法是首先把源语言的程序翻译成一种相对接近目标语言的中间表示形式，然后再从这种中间表示翻译成目标代码。 容易看出，IR 的好处有如下几点： 缩小调试范围，通过把 AST 到汇编的步骤一分为二。通过观察 IR 是否正确生成就能知道：到底是 IR 生成这一小步有问题，还是 IR 到汇编这一小步有问题。 比起 AST 到汇编当成一整个大步骤，分成两个小步，每步代码更少，更容易调试。 实际中，有了 IR 更容易适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, C, Java...）。由于不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块。如果有了 IR，只需要写 N 个 IR 生成和 M 个汇编生成，一共 N + M 个模块。 下面，我们将对我们所使用的中间代码——三地址码（TAC）做简单介绍，后续的实验步骤中需要你添加恰当的三地址码指令来完成特定的功能。当然，我们会对比较复杂的情况给出参考实现，各位同学可以依据参考实现完成设计，也可以根据自己的想法进行三地址码的设计。 三地址码 三地址码（Three Address Code, TAC）看起来很像汇编，但是和汇编最大的差异在于——汇编里面使用的是目标平台（如 risc-v, x86, mips）规定的物理寄存器，其数目有限；而 TAC 使用的是“伪寄存器”，我们称临时变量，理论上其数目可以无限，我们想要多少就有多少（这意味着直接将临时变量转化为寄存器可能会出现寄存器不够用的情况）。在后端生成汇编代码时，我们再考虑如何为临时变量分配物理寄存器。 main: # main 函数入口标签 _T0 = 1 # 加载立即数 _T1 = _T0 # 临时变量赋值操作 _T2 = ADD _T0, _T1 # 加法操作 _T2 = _T0 + _T1 _T3 = NEG _T0 # 取负操作 _T3 = -_T0 return _T2 # 函数返回 以上给出了一份 TAC 程序的示例。请注意本文档中的 TAC 代码示例都只是为了方便阅读而采取了这种表示方法，但 TAC 代码只是一种中间表示，并不需要像汇编语言那样有严格的文法。因此，同学们可以自由选择输出 TAC 代码的格式，只要方便自己调试即可。例如，你也可以将 _T2 = ADD _T0, _T1 输出成 _T2 = _T0 + _T1。 TAC 程序由标签和指令构成： 标签用来标记一段指令序列的开始。从底层的角度来看，每个标签本质上就是一个地址，且往往是某一段连续内存的起始地址。在本框架中，标签有两个作用：作为函数入口地址（如上例中的 main 函数入口）、作为分支语句的跳转目标（TAC 指令不支持 MiniDecaf 语言中的 if, for 等条件/循环控制流语句，而是将它们都翻译成更加底层的跳转语句）。 指令与汇编指令类似，每条 TAC 指令由操作码和（最多3个）操作数构成。 操作数可能会有：临时变量、常量、标签（可理解为常量地址）和全局变量（全局变量的处理比较特殊，由于 Step10 才需要考虑它，我们届时再介绍处理它的方法）。如上例所示，TAC 中的临时变量均用 \"_Tk\" 表示。 TAC 程序是无类型的，或者说它仅支持一种类型：32位（4字节）整数。出于方便考虑，MiniDecaf 只支持 int 类型和 int 数组类型，其值和地址都能用一个32位整数装下，故 MiniDecaf 程序中的变/常量和 TAC 中的变/常量可以直接对应。 数组类型无法用临时变量直接表示，因此用一段连续内存的起始地址表示。其实现细节我们在 Step11 再详细讨论。 数据流分析和寄存器分配 C++ 框架：数据流图定义及优化在 src/tac/flow_graph.cpp 及 src/tac/dataflow.cpp 中；寄存器分配在 src/asm/riscv_md.cpp中 TODO：加入 Python 框架相关代码位置 数据流分析 一般来说，在三地址码的基础上是可以直接翻译为目标代码的，但是这样的直接翻译会导致所产生的代码的效率比较差，所以多数编译器都会进行一定的优化工作。为了进行更深入的优化，编译器需要了解程序语义的更多内容，例如一个变量的某个赋值在当前指令中是否有效、一个变量在当前指令以后是否还会被使用、当前运算指令的两个操作数是否都能够在编译的时候计算出来、循环体中某些代码是否能够提出到循环外面、循环次数是不是编译的时候已知的常数等等，这些语义分析一般分为数据流分析和控制流分析两种。 所谓数据流分析，是指分析各种数据对象在程序的执行路径中的状态关系，例如一个变量在某个语句以后是否还被用到等。依据数据流分析的结果，我们可以进行后续的中间代码优化以及寄存器分配等相关步骤。 而所谓的控制流分析，是指分析程序的执行路径满足什么性质，例如是否包含多重循环、控制流图中是否包含强连通块等。关于数据流分析的细节，我们将在 step8 做详细介绍。 寄存器分配 所谓寄存器分配，是指为中间代码中的虚拟寄存器分配实际的物理寄存器。对中间代码来说，通常假设虚拟寄存器的数量是无限的，这导致我们在分配物理寄存器时无法简单的对虚拟寄存器做一一映射，需要有一个调度与分配算法来合理使用有限的物理寄存器。本实验框架中使用了一种暴力寄存器分配算法，具体细节将在 Step5 中详细说明，当然如果你感兴趣，你也可以基于我们的框架实现更高级的干涉图分配算法，具体不作要求。 目标平台汇编代码生成 C++ 框架：目标平台汇编代码生成在 src/asm 中 TODO：加入 Python 框架相关代码位置 通常我们认为的目标代码生成步骤包含寄存器分配、指令选择。寄存器分配是指为中间代码中的虚拟寄存器分配实际的物理寄存器，设计物理寄存器的调度分配。指令选择是指选用合适的汇编指令来翻译中间代码指令，如中间代码生成章节提供的例子中，使用 addi 汇编指令来翻译 ADD 中间代码指令。需要特别提出的是，RISC-V 指令集的设计思路是尽可能简洁，因此有些指令并没有直接提供，需要用多条简单指令代替。如相等、大于等于、逻辑与、逻辑或等等，大家实现时需要特别注意。 本次实验我们的目标平台为 RISC-V，RISC-V 是一个很像 MIPS 的 RISC 指令集架构，编译实验要求你的编译器把 MiniDecaf 程序编译到 RISC-V 汇编。指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"，另外这里也有（非官方的）指令用法说明。下图给出了 RISC-V 的32个整数寄存器的相关说明，其中需要特别注意的寄存器有 ra（存放返回地址）、sp（存放当前栈顶地址）、fp（存放当前栈底地址）、a0&a1（存放返回值）。为了简单起见，我们简化了 RISC-V 的调用约定，由调用者负责保存寄存器，因此你无需关心某个寄存器是caller-saved 还是 called-saved。 "},"docs/step1/provided.html":{"url":"docs/step1/provided.html","title":"已提供的语法特性","keywords":"","body":"已经提供的语法特性 为了方便同学们完成实验，我们提供的实验框架中已经完成了部分语言特性的实现。对于某些步骤，同学们可以参照已实现的特性完成剩余的部分。例如，根据提供的 while 循环实现，同学们可以参考着完成 do-while 和 for 循环的实现。 下面我们列出了所有框架中已经完成的特性： Step1 中我们提供了所有实现。 Step2 中我们提供了取负运算的实现。 Step3 中我们提供了加法运算的实现。 Step5 中我们提供了基础数据结构——符号表的实现。 Step6 中我们提供了 if 语句的实现。 Step7 中我们提供了基础数据结构——作用域栈的实现。 Step8 中我们提供了 while 循环以及 break 语句的实现。 此外，我们提供了 Step1-6 需要的语法树节点和中间代码指令，以及后端中的寄存器分配算法。 "},"docs/step1/example.html":{"url":"docs/step1/example.html","title":"通过例子学习","keywords":"","body":"通过例子学习，一个仅有 return 的主函数编译全流程： 本步骤主要涉及的语法为主函数和 return 语句，完成本步骤之后，你的编译器将支持将一个仅有 return 的主函数编译为32位 RISC-V 汇编代码，并通过 RISC-V 工具链生成可以在硬件模拟器上正确运行的程序。因为这是大家首次接触 MiniDecaf 编译实验框架，我们给大家的代码框架中已经包含所有 Step1 的实现，大家可以直接运行通过 Step1 的测试用例。并且，我们在每个步骤的文档中会详细梳理介绍在当前步骤中需要用到的知识点以及对应的代码片段和注释，如果我们认为当前步骤并不需要了解某部分知识点（如数据流分析、寄存器分配），我们会在后续的步骤中进行知识点的讲解。 下面我们将通过一个简单的 step1 测试用例，一起走过它的编译全流程： int main() { return 2021; } 请注意，这里给出的生成结果（抽象语法树、三地址码、汇编）只是一种参考的实现，同学们可以按照自己的方式实现，只要能够通过测试用例即可。 词法分析 & 语法分析 TODO：合理排版呈现，现在比较乱 在词法分析 & 语法分析这一步中，我们需要将输入的程序字符流按照语法规范转化为后续步骤所需要的 AST，我们使用了lex/yacc库来实现这一点。yacc 是一个根据 EBNF 形式的语法规范生成相应 LALR parser 的工具，支持基于属性文法的语法制导的语义计算过程。你可以根据我们的框架中对lex/yacc的使用，结合我们的文档，来快速上手lex/yacc，完成作业；也可以选择阅读一些较为详细的文档，来系统地进行lex/yacc的入门，但这不是必须的。 为了方便同学们理解框架，我们将同时在这一段中说明为了加入取负运算所需要的操作。 C++ lex/yacc 快速入门 Python lex/yacc 快速入门 C++ Token流： Int Identifier(\"main\") LParen RParen LBrace Return IntConst(2021) Comma RBrace AST: Program -> Functions -> Type Identifier LParen RParen LBrace Statements RBrace Statements -> ReturnStmt ReturnStmt -> Return IntConst(2021) Comma (制图?) Makefile中调用了flex和bison来处理parser.y和scanner.l, 将对语法分析器和词法分析器的描述翻译为C++实现。 scanner.l和parser.y是配合使用的，简单来说，scanner.l定义了词法规则，parser.y定义了语法规则。parser.y自动生成的语法分析器，会调用scanner.l生成的yylex()函数, 相当于getNextToken() 将“return\"解析为一个token的规则，在scanner.l中是 \"return\" { return yy::parser::make_RETURN (loc); } loc是表示当前扫描位置的line\\column行列的全局变量，yy::parser::make_RETURN是parser.y自动生成的函数，构建一个parser能够使用的RETURN token。 在parser.y中， %token RETURN \"return\" ; 这一段就为parser声明了RETURN这个token。 %token IDENTIFIER \"identifier\" %token ICONST \"iconst\" 具体语义可参考 https://www.gnu.org/software/bison/manual/html_node/Complete-Symbols.html。 非终结符也需要声明。 %nterm Program FoDList 我们将非终结符都声明为语法树结点的指针类型。每条语法规则里对应的动作会构建一个新的语法树结点。如 FuncDefn : Type IDENTIFIER LPAREN FormalList RPAREN LBRACE StmtList RBRACE { $$ = new ast::FuncDefn($2,$1,$4,$7,POS(@1)); } | $1, $2按顺序索引规则右侧的非终结符。 Python 程序的入口点在 main.py，它通过调用 frontend.parser.parser（位于 frontend/parser/ply_parser.py）来完成语法分析的工作，而这一语法分析器会自动调用位于 frontend/lexer/ply_lexer.py 的词法分析器进行词法分析。语法的定义和语法分析器一样位于 frontend/parser/ply_parser.py，而词法的定义位于 frontend/lexer/lex.py。AST 节点的定义位于 frontend/ast/tree.py 中。以下表示中的符号都出自于这几个文件。 当程序读入上述程序的字符流之后，它首先会被 lexer 处理，并被转化为如下形式的一个 Token 流： Int Identifier(\"main\") LParen RParen LBrace Return Integer(2021) Comma RBrace 并被 yacc 生成的 LALR(1) parser 转化为如下形式的 AST： Program |- (children[0]) Function |- (ret_t) TInt |- (ident) Identifier(\"main\") |- (body) Block |- (children[0]) Return |- (expr) IntLiteral(2021) 得到的这个 AST 也就是 main.py 中 step_parse 这一函数里 parser.parse(...) 的输出。 如果我们想把返回值从 2021 变成 -2021，则在这一步中你可能需要进行以下操作（实际上这些东西我们已经给好了）： 在 frontend/ast/tree.py 里加入新的 AST 节点定义（以及相应的其它东西），可能长这样： class Unary(Expression): def __init__(self, op: Operator, operand: Expression): ... 并在 frontend/ast/visitor.py 中加入相应的分派函数。 它将在后续的 parser 语义计算中被用到。 在 frontend/lex/lex.py 里加入新的 lex token 定义: t_Minus = \"-\" 在 ply 的 lexer 中，定义的新 token 需要以 t_开头。更具体的解释见文件注释或文档。 在 frontend/parser/ply_parser.py 里加入新的 grammar rule，可能包含（不限于）以下的这些： def p_expression_precedence(p): #0 \"\"\" expression : unary unary : primary \"\"\" #1 p[0] = p[1] #2 def p_unary_expression(p): \"\"\" unary : Minus unary \"\"\" p[0] = tree.Unary(UnaryOp.Neg, p[2]) 其中： 0：定义的新语法规则名。可以随便起，但必须以 p_ 开头以被 ply 识别。 1：以 BNF 定义的新语法规则，以 docstring 的形式提供。 2：这条语法规则相应的语义计算步骤，下标对应着产生式中的相应符号。语法分析器直接产生的实际上是一棵语法分析树，而构建 AST 这一数据结构则通过相应语法制导的语义计算过程来完成。 更多的用法同样可参见文档。 这样就基本完成了词法 & 语法分析步骤里加入取负运算的所有步骤。后续步骤中可能需要在某些 visitor 中实现相应的检查、转化至 TAC 的逻辑。 另外需要留意的一点是，python 框架中解决运算符结合律、优先级和悬吊 else 问题的方法与 C++ 框架中略有不同：C++ 框架下使用了 yacc 的特性直接指定了相应语法规则的优先级和结合律，但在 python 框架中我们通过对相应语法规则进行变换来达到这一目的，这些变换方法（优先性级联、规定左结合/右结合、最近嵌套匹配）在学习 CFG 时应有涉及，此处不多赘述。 语义分析 在 Step1 语义分析步骤中，我们要遍历 AST，检验是否存在如下的语义错误： main 函数是否存在。 return 语句是否有返回值。 返回值是否在 int 合法的范围内。 在实际操作中，我们遍历 AST 所用的方法就是的 Visitor 模式，通过 Visitor 模式，我们可以从抽象语法树的根结点开始，遍历整颗树的所有语法结点，并针对特定的语法结点作出相应的操作，如名称检查和类型检查等。在编译器中，这种基于 Visitor 的对语法树进行一次遍历，完成某种检查或优化的过程，称为遍（pass）。不难想到，一个现代编译器是由很多pass 组成的，如 gcc 根据优化等级不同会有数百个不等的 pass。下面，我们将指出，step1 中我们是如何实现符号表构建 pass 和类型检查 pass 的，选择不同语言的同学，可以选择去看相应的代码注释与实现细节。 Python 框架 frontend/typecheck/namer.py 和 typer.py 分别对应了符号表构建和类型检查这两次遍历。在 Step1-10 中，同学们只需要考虑 namer.py（因为只有 int 类型，无需进行类型检查）。在框架中，namer 和 typer 都是继承 frontend/ast/visitor.py 中的 Visitor 类来通过 Visitor 模式遍历 AST 的。其实现细节参见代码。 C++ 框架 translation/build_sym.hpp 和 translation/type_check.hpp 及相应 .cpp 文件分别对应了符号表构建和类型检查这两次遍历。在 Step1-10 中，同学们只需要考虑 build_sym.hpp（因为只有 int 类型，无需进行类型检查）。在框架中，两者都是继承ast/visitor.hpp 中的 Visitor 类来通过 Visitor 模式遍历 AST 的。其实现细节参见代码。 中间代码生成 在通过语义检查之后，编译器已经掌握了翻译源程序所需的信息（符号表、类型等），下一步要做的则是将抽象语法树翻译为便于移植和优化的中间代码，在本实验框架中就是三地址码。如何翻译抽象语法树？当然还是无所不能的 Visitor 模式，我们在中间代码生成步骤中再遍历一次语法树，对每个结点做对应的翻译处理。具体来说，在 step1 当中，我们只需要提取 return 语句返回的常量，为之分配一个临时变量，再生成相应的 TAC 返回指令即可。不难看出，本例对应的三地址码为： main: # main 函数入口标签 _T0 = 2021 # 为立即数2021分配一个临时变量 return _T0 # 返回 下面，我们同样也指出了在代码中我们是怎样实现这个中间代码生成 pass 的，大家可以参考注释和代码了解实现细节。 Python 框架 frontend/tacgen/tacgen.py 中通过一遍 AST 扫描完成 TAC 生成。和语义分析一样，这部分也使用了 Visitor 模式。 frontend/utils/tac 目录下实现了生成 TAC 所需的底层类。其中 tacinstr.py 下实现了各种 TAC 指令，同学们可以在必要时修改或增加 TAC 指令。提供给生成 TAC 程序流程的主要接口在 funcvisitor.py 中，若你增加了 TAC 指令，则需要在 FuncVisitor 类中增加生成该指令的接口。在本框架中，TAC 程序的生成是以函数为单位，对每个函数（Step1-8 中只有 main 函数）分别使用一个 FuncVisitor 来生成对应的 TAC 程序。除此之外的 TAC 底层类，同学们可以不作修改，也可以按照自己的想法进行修改。 C++ 框架 translation/translation.hpp 及相应 .cpp 文件中通过一遍 AST 扫描完成 TAC 生成。和语义分析一样，这部分也使用了 Visitor 模式。 tac 目录下实现了生成 TAC 所需的底层类。其中 tac/tac.hpp 下实现了各种 TAC 指令，同学们可以在必要时修改或增加 TAC 指令。tac/trans_helper.hpp 及相应 .cpp 文件中的 TransHelper 类用于方便地生成 TAC 指令流，若你增加了 TAC 指令，则需要在 TransHelper 类中增加生成该指令的接口。除此之外的 TAC 底层类，同学们可以不作修改，也可以按照自己的想法进行修改。 目标代码生成 目标代码生成步骤是对中间代码的再一次翻译，在本例中，你需要了解并掌握的知识点有: 如何将一个立即数装载到指定寄存器中？ RISC-V 提供了 li 指令来支持加载一个 32 位立即数到指定寄存器中，其中 表示寄存器名， 表示立即数值，如：li t0, 2021，就是将立即数 2021 加载到寄存器 t0 中。 如何设置返回值？ 在 RISC-V 中，a0 和 a1 是 gcc 调用约定上的存储返回值的寄存器，返回值会按照其大小和顺序存储在 a0 和 a1 中。也就是说，如果你有一个 32 位的返回值，你可以放在 a0 中返回，如果你有两个 32 位的返回值，你就需要把它们分别放在 a0 和 a1 中返回。更多的返回值会全部放入内存返回，如约定好的栈的某个位置，这取决于函数调用约定。 在我们的实验要求中，返回值均是单个 32 位的值。因此在当前步骤中你只需要了解，将需要返回的值放入 a0 寄存器中，然后在后面加上一条 ret 指令即可完成函数返回的工作。 综上所述，我们上述中间代码翻译成如下 RISC-V 汇编代码： .text # 代码段 .global main # 声明全局符号 main main: # 主函数入口符号 li t0, 2021 # 加载立即数2021到t0寄存器中 mv a0, t0 # 将返回值放到a0寄存器中 ret # 返回 关于实现细节，对应的代码位置在下面给出，代码中提供注释供大家学习： Python 框架 python 框架中关于目标代码生成的文件主要集中 backend 文件夹下，step1 中你只需要关注 backend/riscv 文件夹中的 riscvasmemitter.py 以及 utils/riscv.py 即可。具体来说 backend/asm.py 中会先调用 riscvasmemitter.py 中的 selectInstr 方法对每个函数内的 TAC 指令选择相应的 riscv 指令，然后会进行数据流分析、寄存器分配等流程，在寄存器分配结束后生成相应的 NativeInstr 指令（即所有操作数都已经分配好寄存器的指令），最后通过 RiscvSubroutineEmitter 的 emitEnd 方法生成每个函数的 Riscv 汇编。 C++ 框架 C++ 框架中关于目标代码生成的文件主要集中在 src/asm 文件夹下，step1 中你只需要关注 src/asm/riscv_md.cpp 即可。具体来说，riscv_md.cpp 中的 emitPiece 函数是整个目标代码生成模块的入口。你只需要顺着函数调用的逻辑，以及我们提供的注释，就能够走通整个编译的流程。 "},"docs/step1/visitor.html":{"url":"docs/step1/visitor.html","title":"Visitor 模式速成","keywords":"","body":"Visitor 模式速成 编译器的构造中会使用到很多设计模式，Visitor 模式就是常见的一种。 基础的设计模式都在 OOP 课程中覆盖，这里重提一下 Visitor 模式，并以框架中的代码为示例进行介绍。 我们知道，编译器里有很多的树状结构。最典型的就是，源程序通过上下文无关文法解析后，得到的抽象语法树。在语义分析和中间表示生成两个步骤中，我们都需要遍历整个抽象语法树。Visitor 模式的目的，就是对遍历树状结构的过程进行封装，本质就是一个 DFS 遍历。 让我们考虑 step1 的文法： program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer 以这个文法对应的一段 MiniDecaf 代码为示例： int main() { return 2; } 它会对应如下的 AST 结构： program function type(int) identifier(main) param_list return int(2) 我们用缩进表示树结构，其中 program, function, type, identifier, param_list, block, return, int 等均为 AST 上的结点类型。 Python 框架 在框架中，我们有以下的 AST 结点类实现（进行了适当的简略）： ''' frontend/ast/node.py ''' class Node: # 所有 AST 结点的基类 # ... ''' frontend/ast/tree.py ''' class Program(ListNode[Union[\"Function\", \"Declaration\"]]): # 程序，AST 的根结点类型 # ... class Function(Node): # 函数 # ... class Statement(Node): # 语句基类 # ... class Return(Statement): # return 语句 # ... class TypeLiteral(Node): # 类型基类 # ... class TInt(TypeLiteral): # 整型 # ... 假设在经过了词法分析和语法分析后，我们已经成功将 MiniDecaf 代码转化为了 AST 结构。现在，我们想要编写代码对 AST 进行扫描。很容易写出递归的 DFS 遍历： def dfs(node: Node): if isinstance(node, Program): for func in node.functions: dfs(func) elif isinstance(node, Function): # do something for scanning a function node elif isinstance(node, Return): # ... dfs 函数接收一个结点，根据这个结点的类型进行深度优先遍历。容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的遍历逻辑。 那么我们把这些遍历逻辑封装到一个类里面，就得到了一个最简单的 Visitor。此外，为了便于实现，我们不使用 isinstance 来判断结点类型，而是调用结点自身的一个 accept 函数，并把不同的 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口。 ''' frontend/ast/node.py ''' class Node: # 所有 AST 结点的基类 def accept(self, v: Visitor[T, U], ctx: T) -> Optional[U]: raise NotImplementedError ''' frontend/ast/tree.py ''' class Program(ListNode[Union[\"Function\", \"Declaration\"]]): # ... def accept(self, v: Visitor[T, U], ctx: T): return v.visitProgram(self, ctx) class Function(Node): # ... def accept(self, v: Visitor[T, U], ctx: T): return v.visitFunction(self, ctx) # ... ''' frontend/ast/visitor.py ''' class Visitor(Protocol[T, U]): def visitOther(self, node: Node, ctx: T) -> None: return None def visitProgram(self, that: Program, ctx: T) -> Optional[U]: return self.visitOther(that, ctx) def visitFunction(self, that: Function, ctx: T) -> Optional[U]: return self.visitOther(that, ctx) # ... 之后，如果我们想要编写一种遍历 AST 的方法，可以直接继承 Visitor 类，并在对应结点的 visit 成员方法下实现对应的逻辑。例如，框架中用如下的方法进行符号表构建： class Namer(Visitor[ScopeStack, None]): def visitProgram(self, program: Program, ctx: ScopeStack) -> None: # ... for child in program: if isinstance(child, Function): child.accept(self, ctx) def visitFunction(self, func: Function, ctx: ScopeStack) -> None: # ... # ... 如果想要访问某个子结点 child，直接调用 child.accept(self, ctx) 即可。 C++ 框架 在框架中，我们有以下的 AST 结点类实现（进行了适当的简略）： // ast/ast.hpp class ASTNode { // 所有 AST 结点的基类 public: virtual NodeType getKind (); // 返回结点类型 // ... }; class FuncDefn : public ASTNode { // 所有函数 // ... }; class Statement : public ASTNode { // 语句基类 // ... }; class ReturnStmt : public Statement { // return 语句 // ... }; class Type : public ASTNode { // 类型基类 // ... }; class IntType : public Type { // 整型 // ... }; 假设在经过了词法分析和语法分析后，我们已经成功将 MiniDecaf 代码转化为了 AST 结构。现在，我们想要编写代码对 AST 进行扫描。很容易写出递归的 DFS 遍历： void dfs(ASTNode *node) { if (node->getKind() == NodeType::PROGRAM) { for (auto &&item : ((Program*)node)->func_and_globals) { dfs(item); } } else if (node->getKind() == NodeType::FUNC_DEFN) { // do something for scanning a function node } else if (node->getKind() == NodeType::RETURN) { // ... } } dfs 函数接收一个结点，根据这个结点的类型进行深度优先遍历。容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的遍历逻辑。 那么我们把这些遍历逻辑封装到一个类里面，就得到了一个最简单的 Visitor。此外，为了便于实现，我们不使用 getKind 来判断结点类型，而是调用结点自身的一个 accept 函数，并把不同的 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口。 // ast/ast.hpp class ASTNode { // 所有 AST 结点的基类 public: virtual void accept(Visitor *) = 0; }; class Program : public ASTNode { public: void accept(Visitor *v) override { // 仅作示意，实际实现在对应的 .cpp 文件里 v->visit(this); } }; class FuncDefn : public ASTNode { public: void accept(Visitor *v) override { // 仅作示意，实际实现在对应的 .cpp 文件里 v->visit(this); } }; // ast/visitor.hpp class Visitor { public: virtual void visit(Program *) {} virtual void visit(FuncDefn *) {} }; 之后，如果我们想要编写一种遍历 AST 的方法，可以直接继承 Visitor 类，并在对应结点的 visit 成员方法下实现对应的逻辑。例如，框架中用如下的方法进行符号表构建： class SemPass1 : public Visitor { void visit(ast::Program* prog) { // ... // visit global variables and each function for (auto it = prog->func_and_globals->begin(); it != prog->func_and_globals->end(); ++it) { (*it)->accept(this); // ... } // ... } } 如果想要访问某个子结点 child，直接调用 child.accept(self, ctx) 即可。 "},"docs/step1/manual-parser.html":{"url":"docs/step1/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 该文档简单展示使用 c 风格代码手写 parser 的过程。 0. 定义 我们的最终目标是这样一个函数，接受 token list 作为输入，输出一个代表整个程序结构的 AST。 parse(token_list) -> Prog 但是在 lab9 之前我们都只有一个 main 函数，所以这里的 Prog 可以暂时简化为 Function。 首先我们先定义 token 和 AST node enum TokenKind { TK_RESERVED, // 保留字，包含关键字和各种符号 TK_IDENT, // 标识符，如变量名、函数名 TK_NUM, // 数字字面量，如 1, 0 }; struct Token { TokenKind kind; char* str; //对应的字符串 // int raw, col; //如果你想得到报错位置，需要在这里记录行号与列号信息 }; struct Prog { Function* func; } struct Func { list stmts; } enum NodeKind{ ND_RETURN, // return 语句 ND_NUM, // 数值字面量 }; struct Node { NodeKind kind; int val; // 用于储存 ND_NUM 类型节点的数值 Node* expr; // 用来储存 ND_RETURN 类型节点返回的表达式节点 }; statement 和 expression 两类节点有较大的区别，推荐区分为不同的两类 Node，这里未作区分，也不会有什么问题。 推荐使用 unique pointer 和 shared pointer 来构建 AST 树。 1. 访问 Token 在 lex 阶段，我们的到了一个 token list，在 parse 阶段，我们需要访问这个 list 构建 AST ，我们需要一套访问接口来方便操作。 // 获得当前正在处理的 token，处理完毕返回 NULL Token* take_token(); // 进入下一个 token 的处理 void next_token(); 这一步实现简单，甚至不一定要抽象为一个函数，请大家自行实现。 2. 框架 解析的过程是对产生式的还原。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer 最上层函数为解析一个 Prog，目前相当与解析一个函数。 Program* parse() { Program* prog = new Program(); Function *fn = function(); prog->func = fn; return prog; } 　非终结符解析函数 parse()中，function()函数代表解析一个非终结符 function，即：从当前的 token 开始，消耗若干个 token，直到解析完成一个function（一个非终极符）。该函数没有输入，返回一个 AST 结点，过程中消耗了 token。接下来本文中类似函数（名称与产生式中非终结符一致）都是类似的含义。 按照生成式，解析一个 function 需要依次解析 type Identifier ( ） { statement }，如下： Function *function() { parse_reserved(\"int\"); // 应该为 type(), 这里做了简化 char *name; parse_ident(name); Function *fn = new Function(name); parse_reserved(\"(\"); parse_reserved(\")\"); parse_reserved(\"{\"); while (!parse_reserved(\"}\")) { fn->nodes.push_back(stmt()); } return fn; } 其中 parser_xxx()代表解析一个终结符。为直接访问 token 的函数，仅仅处理一个 token，与 token 类别一一对应。正如上方的说明，stmt() 表示，消耗一系列 token，解析出一条语句。 对非终极符的解析函数是由其他的非终结符函数、终结符函数和处理AST节点的语句构成，如果你同时完成了名称解析或者类型检查等，你还需要其他功能语句。 终结符解析函数：parser_xxx() // 解析成功返回 true, 否则为 false bool parse_int_literal(int &val); // 解析一个数字字面量，结果通过 val 返回 bool parse_reserved(const char* str); // 解析一个保留字 str bool parse_ident(char* &ident); // 解析一个标识符，结果通过 ident 返回 这些底层的解析函数会处理当前的 token（通过 take_token()）拿到，如果成功会跳过当前 token（也就是调用 next_token()）。 如 parse_reserved() 会检查当前 token 的类型是否为 TK_RESERVED，如果是，检查其字符串是否与给出的一致,如果是，返回 true。以上任意一步失败，返回 false。 如果你想要自己的编译器在发生错误时停止，可以这样。 Function *function() { assert(parse_reserved(\"int\")); // ... } 当然，也可以输出一些错误信息。如果你想得到报错位置，可以令 parse_xxx()返回 token 位置信息。 stmt() 类似 function()的思路，对语句的解析也可以按照生成式进行，目前仅需要解析 return 一种类型的语句。 Node* stmt() { Node* node = NULL; if (parse_reserved(\"return\")) { node = new Node(ND_RETURN); node->expr = expr(); assert(parse_reserved(\";\")); return node; } return node; } 其中, expr()为解析一个表达式的函数，因为目前的 expr()仅仅需要解析一个数字，可以通过调用 parse_int_lliteral()轻松实现。返回一个类型为 ND_NUM的Node就好了。 总结 第一个 lab 的工作看似很简单，但是我们需要搭建一个比较完整的框架来便于后续工作，其实工作量较大。接下来工作会比较轻松。 "},"docs/step1/spec.html":{"url":"docs/step1/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step1 语法规范 我们采用 EBNF (extended Barkus-Naur form) 记号书写语法规范，采用类似 ANTLR 的记号： 小写字母打头的是非终结符（如 program），大写字母打头的是终结符（如 Identifier），可以用字符串字面量表示终结符（如 'int'） 后面会用到：( 和 ) 表示分组，| 表示选择，* 零或多次，+ 一或多次，? 零或一次。 很容易通过增加新的非终结符，去掉这些符号。例如 x+ 就可以被替换成新的非终结符 y，并且 y : x | x y。 EBNF 也有很多写法，另一种是用尖括号表示非终结符 ::= 等。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer step1 语义规范 1.1 MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2^31, 2^31-1]，补码表示。 1.2 编译器应当只接受 [0, 2^31-1] 范围内的整数常量, 不支持负整数常量，如果整数不在此范围内，编译器应当报错。引入负号-后，可以用负号配合正整数常量来间接表示负整数常量。 1.3 如果输入程序没有 main 函数，编译器应当报错。 "},"docs/step2/intro.html":{"url":"docs/step2/intro.html","title":"任务概述","keywords":"","body":"实验指导 step2：一元运算符 step2 中，我们要给整数常量增加一元运算：取负 -、按位取反 ~ 以及逻辑非 !。 语法上，我们需要修改 expression 的定义，从 expression : Integer 变成： expression : unary unary : Integer | ('-'|'!'|'~') unary 三个操作的语义和 C 以及常识相同，例如 ~0 == -1，!!2 == 1。 稍微一提，关于按位取反，我们使用补码存储 int；关于逻辑非，只有 0 表示逻辑假，其他的 int 都是逻辑真。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step2/example.html":{"url":"docs/step2/example.html","title":"通过例子学习","keywords":"","body":"step2 实验指导 我们按照上一节划分的编译器阶段，分阶段给出 step2 实验指导。本实验指导使用的例子为： 需要注意的是，我们为了简化描述，提取出了测试用例中和本步骤最相关的部分，实际的测试用例还是一个完整的，带有主函数的 MiniDecaf 程序。 -1 词法语法分析 如果你使用工具完成词法语法分析，修改你的规范以满足要求，剩下的交给工具即可。 语法规范已经给出，词法规范的变化也很简单，新增三个 token：-、~ 和 !。 你的规范和我们的要求等价、能通过测试即可，不用完全一样。 需要注意的是，检查时只会根据输出是否正确来判断，在一开始，你可能会使用和规范不完全一样的语法规则，也得到标准的结果。但我们强烈建议你编写的语法规则尽量和规范保持一致，否则后面增加更多的语法规则时，和规范不一致的语法规则想编译出标准的结果会越来越难。 语义分析 没有特别需要修改的地方。但请注意，由于现在 return 语句的返回值不再是整型常量，而是表达式，因此语义分析时需要递归地访问运算操作结点的子结点，才能访问到作为叶子结点的整型常量，完成 step1 中实现的整型常量越界检查。 中间代码生成 在 step1 中，我们只需为 return 语句的返回的整型常量分配一个临时变量即可。而从 Step2 开始，语法树上出现了各种运算操作结点。在生成 TAC 的过程中，我们需要为运算结点分配一个临时变量，并生成一条指令，该指令根据子结点的临时变量进行计算，将结果赋予该结点的临时变量。 针对取负操作，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下 指令 参数 含义 NEG T0 对参数取负 按照上文说的，-1 在语法树上对应父-子两个结点，父结点为取负操作，子结点为常量 1。在生成过程中，首先使用 Visitor 模式递归地访问子结点，我们使用一个临时变量加载该立即数。之后，在父结点，我们根据子结点的临时变量，生成一条取负指令，将这条指令得到的目标临时变量设置为父结点的临时变量。 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = NEG _T0 目标代码生成 step2 目标代码生成步骤的关键点在于，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。以 NEG 中间表达指令为例，RISC-V 汇编中有 neg 指令与其对应，因此上述中间代码可以翻译为如下的 RISC-V 汇编： li t0, 1 neg t1, t0 关于目标代码生成有一个小技巧，如果你实在不知道某个运算符应该翻译成怎样的汇编代码，可以参考 gcc 的输出结果。例如，你可以通过 gcc 编译如下程序来了解如何翻译逻辑非运算符到 RISC-V 汇编（记得加 -O3 选项）： int foo(int x) { return !x; } 不出意外你会获得如下结果： foo: seqz a0,a0 ret 思考题 我们在语义规范中规定整数运算越界是未定义行为，运算越界可以简单理解成理论上的运算结果没有办法保存在32位整数的空间中，必须截断高于32位的内容。请设计一个 minidecaf 表达式，只使用-~!这三个单目运算符和从 0 到 2147483647 范围内的非负整数，使得运算过程中发生越界。 提示：发生越界的一步计算是-。 总结 本步骤中其他运算符的实现逻辑和方法与取负类似，大家可以借鉴取负的实现方法实现剩下的逻辑非和按位非。并且，我们在实验框架中已经给出了取负的参考实现，希望能够帮助大家快速上手编译实验。 "},"docs/step2/manual-parser.html":{"url":"docs/step2/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 节点定义变化 增加三种表达式节点，分别为：按位取反、取负、逻辑取反 struct NodeKind { + ND_NEG, + ND_NOT, + ND_BITNOT, } 这一变化很简单，以后省略。 parse 过程变化 按照产生式变化对应修改即可，很简单。 expression : unary unary : Integer | ('-'|'!'|'~') unary Node* expr() { return unary(); } Node* unary() { if(parse_reserved(\"-\")) { Node* neg = new Node(ND_NEG); neg->expr = unary(); return neg; } //...　`!``~`同理 return num(); } 注意，unary()的解析是递归的，这与产生式是一致的。 "},"docs/step2/spec.html":{"url":"docs/step2/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step2 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : unary unary : Integer | ('-'|'!'|'~') unary step2 语义规范 2.1 运算符 - 的结果是其操作数的相反数。 2.2 运算符 ~ 的结果是其操作数的二进制反码（也就是说，结果中的每一个二进制位是 1 当且仅当其对应的二进制位是 0）。 2.3 当操作数不等于 0 时，逻辑非运算符 ! 的结果为 0；当操作数等于 0 时，其结果为 1。 2.4 MiniDecaf 中，负数字面量不被整体作为一个 token。它被看成是一个取负符号、后面是它的绝对值。 所以我们无法用字面量表示 -2147483648，但可以写成 -2147483647-1（待我们加上四则运算后）。 2.5 整数运算越界是未定义行为（undefined behavior），即对程序的行为无任何限制。 例如 -(-2147483647-1) 是未定义行为。这一条规则对于后续 step 引入的运算符也都适用。 对于含有未定义行为的 C/C++ 程序，在启用优化选项编译时，编译器可能产生意料之外的结果。 "},"docs/step3/intro.html":{"url":"docs/step3/intro.html","title":"任务概述","keywords":"","body":"实验指导 step3：加减乘除模 step3 我们要增加的是：加 +、减 -、乘 *、整除 /、模 % 以及括号 ( )。 语法上我们继续修改 expression，变成 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1+2*(4/2+1) == 7。 我们这种表达式语法写法可能比较繁琐，但它有几个好处： 和C99 标准草案保持一致 把优先级和结合性信息直接编码入语法里，见优先级和结合性一节。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step3/example.html":{"url":"docs/step3/example.html","title":"通过例子学习","keywords":"","body":"step3 实验指导 本实验指导使用的例子为： 1+3 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 对有兴趣的同学：虽然 -2 和 2-3 里面的 - 意义不同，但 lexer 不知道这点（parser 才知道），所以它们都会用同样的 token kind - 表示。 但有时，可能需要后续阶段告诉 lexer（或 parser）一些信息，最经典的例子是 “typedef-name identifier problem”。 我们的表达式语法规范和 C 标准的基本相同，但略显繁琐。 如果你选择的语法分析工具支持优先级和结合性，并且你希望用这些信息来简化语法分析工具的编写，请参考这里。 语义分析 语义分析无需修改。 中间代码生成 与一元操作类似，针对加法，我们需要设计一条中间代码指令来表示它，给出的参考定义如下： 指令 参数 作用 ADD T0,T1 将两个参数相加 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = 3 _T2 = ADD _T0, _T1 目标代码生成 step3 目标代码生成步骤的关键点与 step2 相同，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。 li t0, 1 li t1, 3 add t2, t0, t1 思考题 我们知道“除数为零的除法是未定义行为”，但是即使除法的右操作数不是 0，仍然可能存在未定义行为。请问这时除法的左操作数和右操作数分别是什么？请将这时除法的左操作数和右操作数填入下面的代码中，分别在你的电脑（请标明你的电脑的架构，比如 x86-64 或 ARM）中和 RISCV-32 的 qemu 模拟器中编译运行下面的代码，并给出运行结果。（编译时请不要开启任何编译优化） #include int main() { int a = 左操作数; int b = 右操作数; printf(\"%d\\n\", a / b); return 0; } 总结 本步骤中其他运算符的实现逻辑和方法与加法类似，可以参考二元加法的实现方法设计实现其他二元运算符。 "},"docs/step3/precedence.html":{"url":"docs/step3/precedence.html","title":"优先级和结合性","keywords":"","body":"优先级和结合性 操作符有优先级和结合性的概念，在之前的编程经历中大家应该已经对这两个概念已经有了直观的理解，这里用例子进一步解释一下： 优先级是两个操作符之间的关系，例如*的优先级比+高，所以表达式1 + 2 * 3应该解析成语法树add (1 mul (2 3))（前序表示），不能解析成mul (add (1 2) 3) 结合性是一个操作符的性质，例如-是左结合的，所以表达式1 - 2 - 3应该解析成sub (sub (1 2) 3)，不能解析成sub (1 sub (2 3)) 我们给出的语法规范已经表示了这样的性质，因此理论上我们不需要再额外定义操作符的优先级和结合性了。你可以自己试试，按照本步给出的语法规则，上面的两个表达式确实只能解析成我们期望的结果。 但是有一个问题：这样的语法规范虽然是正确的，也确实可以直接用来实现语法分析器了，但并不符合直观：我们一开始学习C或者别的编程语言的时候，讲的就是一个二元表达式由两个子表达式和中间的操作符组成，并且操作符有优先级和结合性。也就是这样的： expression : expression ('+'|'-') expression | expression ('*'|'/'|'%') expression | ('-'|'~'|'!') expression | Integer | '(' expression ')' 当然，它是有歧义的，你也可以自己试试，如果只有这些产生式的话，上面的两个表达式都可以解析成正确或者错误的结果。所以如果想基于这个规范来实现语法分析器，就必须告诉语法分析工具这些操作符的优先级和结合性是什么。 之后每一步给出的语法都是没有歧义，本身就能体现优先级和结合性的。如果你确实想借助优先级和结合性来实现，需要两个步骤： 把我们给出的语法规范转化成类似上面这样“更模糊”，有歧义的语法规范。我们相信这个方向的转化应该是容易的。 指定每个操作符的优先级和结合性。可以参考https://en.cppreference.com/w/c/language/operator_precedence，它给出了C语言操作符的优先级和结合性，因为我们的MiniDecaf语言是C语言的一个子集，所以这张表格也足够我们的语言使用了。 "},"docs/step3/manual-parser.html":{"url":"docs/step3/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 struct Node { - Node* expr; + Node* lexpr; + Node* rexpr; } 现在需要储存两个 expression。 parse 过程变化 按照产生式变化对应修改即可，很简单。 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative // ... primary : Integer | '(' expression ')' 加法示例： Node* additive() { Node* node = multiplicative(); while(parse_reserved(\"+\")) { //这里只展示了 `+`, `-`同理 node = new_binary(ND_ADD, node, multiplicative()); } return node; } Node* new_binary(NodeKind kind, Node* lexpr, Node* rexpr); // 类似构造函数，简单赋值 注意左结合性，请思考为何这么写能够保证左结合。如果一种算法是右结合的，应该怎样写呢？ "},"docs/step3/spec.html":{"url":"docs/step3/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step3 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step3 语义规范 3.1 二元操作符 * 的结果是操作数的乘积。 3.2 二元操作符 / 的结果是第一个操作数除以第二个操作数所得的商的整数部分（即所谓“向零取整”），二元操作符 % 的结果是第一个操作数除以第二个操作数所得的余数。在两种操作中，如果第二个操作数为 0，则其行为都是未定义的。当 b 不为 0 时，表达式 (a/b)*b + a%b 应该等于 a。 3.3 二元操作符 + 的结果是操作数的和。 3.4 二元操作符 - 的结果是第一个操作数减去第二个操作数所得的差。 3.5 除非特别声明，子表达式求值顺序是未规定行为（unspecified behavior），即其行为可以是多种合法的可能性之一。也就是说，以任意顺序对子表达式求值都是合法的。 例如：执行 int a=0; (a=1)+(a=a+1); 之后 a 的值是未规定的（待我们加上变量和赋值运算符后，这个问题才会产生真正切实的影响）。 "},"docs/step4/intro.html":{"url":"docs/step4/intro.html","title":"任务概述","keywords":"","body":"实验指导 step4：比较和逻辑表达式 step4 我们要增加的是： 比较大小和相等的二元操作：、、>=, >, ==, != equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive 逻辑与 &&、逻辑或 || expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1=2 是逻辑真（int 为 1）。 但特别注意，C 中逻辑运算符 || 和 && 有短路现象，我们不要求。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step4/example.html":{"url":"docs/step4/example.html","title":"通过例子学习","keywords":"","body":"step4 实验指导 本实验指导使用的例子为： 1 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查无需修改。 注意为新的运算符设置正确的优先级。 语义分析 语义分析无需修改。 中间代码生成 针对小于符号，我们显然需要设计一条中间代码指令来表示它，给出的参考定义如下： 指令 参数 含义 LT T0,T1 给出 T0结果，成立为1，失败为0 需要特别注意的是，在 C 语言中，逻辑运算符 || 和 && 有短路现象，我们的实现中不要求大家考虑它们的短路性质。 因此，测例可以翻译成如下的中间代码： _T0 = 1 _T1 = 2 _T2 = LT _T0, _T1 目标代码生成 step4 目标代码生成步骤的关键点与 step3 相同，针对中间代码指令，选择合适的 RISC-V 指令来完成翻译工作。 li t0, 1 li t1, 2 slt t2, t0, t1 逻辑表达式会麻烦一点，因为 gcc 可能会用跳转来实现&&和||，比较难以理解，所以下面直接给出 land 和 lor 对应的不使用跳转的汇编。 IR 汇编 lor or t1,t1,t2 ; snez t1,t1 land snez t1,t1 ; snez t2,t2 ; and t1,t1,t2 注意 RISC-V 汇编中的 and 和 or 指令都是位运算指令，不是逻辑运算指令。 思考题 在表达式计算时，对于某一步运算，是否一定要先计算出所有的操作数的结果才能进行运算？ 在 MiniDecaf 中，我们对于短路求值未做要求，但在包括 C 语言的大多数流行的语言中，短路求值都是被支持的。为何这一特性广受欢迎？你认为短路求值这一特性会给程序员带来怎样的好处？ 总结 本步骤中其他运算符的实现逻辑和方法与小于符号类似，可以参考小于符号的实现方法设计实现其他逻辑运算符。 "},"docs/step4/spec.html":{"url":"docs/step4/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step4 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step4 语义规范 4.1 关系操作符 （小于）、>（大于）、（小于等于）和>=（大于等于）的结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。 关系操作符可能导致表达式的含义与数学文献中常见的含义不同，例如 0 的含义与 (0 相同，即“如果 0 小于 1，那么判断是否有 1 小于 2，否则判断是否有 0 小于 2”。 4.2 判等操作符 ==（等于）和 !=（不等于）类似于关系操作符，结果取决于两个操作数是否满足它们所指定的关系，当满足时结果为 1，当不满足时结果为 0。但判等操作符的优先级比关系操作符更低。对于任意一对操作数，这两个操作符中有且仅有一个结果为 1。 其优先级的设定会导致其含义在某些时候可能会反直观，例如，0 的运算结果为 1。 4.3 当操作数都非 0 时，逻辑与操作符 && 的结果为 1；否则其结果为 0。 4.4 当操作数有一个非 0 时，逻辑或操作符 || 的结果为 1；否则其结果为 0。 4.5 逻辑操作符 || 和 && 依然遵循语义规范 3.5，即其操作数的求值顺序是未指定行为。 换言之，我们不对逻辑表达式的短路求值做要求，可以将操作数两个以任意顺序计算出，再计算逻辑操作的结果。 "},"docs/step4/stage1.html":{"url":"docs/step4/stage1.html","title":"stage1总结","keywords":"","body":"Stage1 总结 恭喜你！到目前为止，你已经成功实现了一个基于 C-- 语言的计算器，可以完成基本的数学运算和逻辑比较运算了，成就感满满！然而，目前你的计算器还只能支持常量计算，这大大降低了计算器的使用体验，因此，在下一个 Stage，我们将一起实现对变量以及分支语句的支持。无论如何，当前的任务已经完成，好好休息一下吧☕️ "},"docs/step5/intro.html":{"url":"docs/step5/intro.html","title":"任务概述","keywords":"","body":"实验指导 step5：局部变量和赋值 这一步我们终于要增加变量了，包括 变量的声明 变量的使用（读取/赋值） 并且，虽然还只有一个 main 函数，但 main 函数可以包含多条语句和声明了。 为了加入变量，我们需要确定：变量存放在哪里、如何访问。 为此，我们会引入 栈帧 的概念，并介绍它的布局。 语法上，step5 的改动如下： function : type Identifier '(' ')' '{' statement* '}' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression primary : Integer | '(' expression ')' | Identifier 并且我们也要增加语义检查了：变量不能重复声明，不能使用未声明的变量。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step5/example.html":{"url":"docs/step5/example.html","title":"通过例子学习","keywords":"","body":"step5 实验指导 本实验指导使用的例子为： int main() { int x = 2021; return x; } 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 注意，赋值可以被看作是一种表达式，语法规则里要体现这一点。 语义分析 从 step5 开始，我们需要在语义分析阶段对局部变量的规范进行检查。具体来说，我们需要名为符号表的数据结构。符号表的实现已经在框架中给出。因此，你只需要修改语义分析部分的代码，在必要时调用符号表的接口即可。 在符号表构建过程中，我们要按照语句顺序，逐一访问所有变量定义声明。在访问变量声明时，我们需要为该变量赋予一个变量符号，并将它存入符号表中。由于变量不能重复声明，在定义变量符号前需要在符号表中检查是否有同名符号。 类似地，在访问表达式时，如果遇到变量的使用，我们也需要在符号表中检查，避免使用未声明的变量。例如，如果我们将测例修改为： int main() { int x = 2021; return x + y; } 那么在扫描到加法操作的 AST 结点时，会依次检查该操作的两个操作数 x 和 y。这两个操作数均为变量标识符，因此我们需要到符号表中搜索 x 和 y 对应的符号。符号 x 可以在符号表中找到（我们在扫描 int x = 2021; 这条语句后已经为其定义），而 y 无法找到，因此编译器需要在扫描到 y 对应的结点时报错。 符号表总是和作用域相关的。例如，在 C 语言中，我们可以在全局作用域中定义名为 \"a\" 的全局变量，同时在 main 函数中定义名为 \"a\" 的局部变量，这并不产生冲突。不过由于 Step5 还无需支持全局变量和块语句，同学们不用考虑这一点，只考虑 main 函数作用域对应的单张符号表即可。 此外，在本 step 中，我们引入了赋值操作。赋值可以看作一种特殊的二元运算，但需要注意，赋值号左侧必须为一个左值。具体来说，同学们需要检查赋值号左侧只能是变量名标识符。在 step11 中，我们会将左值的范围进一步包括数组元素。 python 框架 frontend/symbol 目录下为符号的实现。其中 symbol.py 为符号类的基类，varsymbol.py 为变量符号。在本 step 中，同学们只需要考虑变量符号即可。 frontend/scope 目录下为符号表的实现。其中 scope.py 为作用域类，在本 step 中由于只有一个局部作用域，因此无需考虑作用域栈。同学们只需要新建一个 Scope 维护 main 函数中所有出现过的变量符号即可。 C++ 框架 src/symb 目录下为符号的实现。symb/symbol.hpp 中，Symbol 类为符号类的基类，Variable 类为变量符号。在本 step 中，同学们只需要考虑变量符号即可。 src/scope 目录下为符号表的实现。scope.hpp 中，Scope 类为作用域基类，其下有 GlobalScope（全局作用域）、FuncScope（函数作用域）、LocalScope（局部作用域）等子类。在本 Step 中由于只有一个局部作用域，因此无需考虑作用域栈。同学们只需要新建一个 Scope 维护 main 函数中所有出现过的变量符号即可。 建立符号表后，需要记录哪个语法树结点对应哪个符号。为此，你可以使用在语法树结点中以 ATTR 宏标记的成员变量，或增加额外的成员变量以供记录。框架中，宏 ATTR 用以区别语法树结点本身的成员变量和中端新纪录的成员变量。这个宏只是给成员变量修改了名字，并无其他语义。例如 VarDecl::name 是语法树结点本身的成员变量，表示变量名；而 VarDecl::ATTR(sym) 则是新增的成员变量，记录此变量对应的符号。 中间代码生成 我们首先来看 step5 测试用例所对应的中间代码： main: _T1 = 2021 _T0 = _T1 return _T0 从中间代码中我们不难看出，step5 我们虽然引入了变量的概念，但是在比较低级的中间代码上，数据的存储和传递仍然是基于虚拟寄存器进行的。由于 MiniDecaf 语言中的基本类型只有 int 型，而 TAC 里的临时变量也是 32 位整数，因此，我们可以把 MiniDecaf 局部变量和 TAC 临时变量对应起来。 在扫描到 int x = 2021; 这条语句时，中间代码先把立即数 2021 加载到临时变量 _T1 中，然后再把 _T1 的值赋给临时变量 _T0 ，此时 _T0 已经成为了变量 x 的“替身”。每次需要用到变量 x 的值时，我们都会去访问 _T0。例如，测例中直接用返回 _T0 代替了返回变量 x 的值。因此，为了在后续使用变量 x 时能快速找到 _T0 这个临时变量，在符号表中存储 x 这个符号时，应当为该符号设置一个成员，存储 x 对应的临时变量。每当在 AST 上扫描到一个变量标识符结点时，我们都直接调用该变量对应的临时变量作为结点的返回值。 python 框架 请注意 frontend/symbol/varsymbol.py 中，变量符号的定义里有该变量对应的 TAC 临时变量成员。 C++ 框架 假设 tr 是一个 TransHelper 类（用于创建 TAC 的辅助类）的对象。对于一个 Variable（变量符号）对象 sym，可通过 sym->attachTemp(tr->getNewTempI4()) 为其分配一个 int 类型的临时变量。分配后，可通过 sym->getTemp 获取此临时变量。 目标代码生成 在 step5 中我们已经引入了变量的概念，然而在中间代码仍然使用虚拟寄存器存储和传递数据，在中间表达中，变量的值也存储在部分虚拟寄存器中。你或许会有疑问，如果我在程序里定义了很多个变量，甚至超过了目标机器实际拥有的物理寄存器，会不会出现寄存器数据覆盖造成的错误呢？答案是肯定的，如果我们仅仅是按照虚拟寄存器定义的顺序分发物理寄存器的。实际的编译器设计中，有一系列算法称为寄存器分配算法。寄存器分配算法负责调度和分配有限的物理寄存器资源，保证所有的临时变量（虚拟寄存器）都有合适的物理寄存器跟它相对应，且在程序执行的任何时刻，不会出现寄存器分配冲突（即两个同时有效且将被用到的临时变量被分配到同一个物理寄存器），寄存器分配冲突会造成程序运行结果的错误。然而，理想寄存器分配问题是 NP 完备的（可归约成 3-SAT 问题），这意味着对于一个含有几百个变量的程序，为了获得理想的寄存器分配方案，编译器需要消耗大量的时间来进行运算。因此，实际的编译器中均只追求获得该问题的近似最优解。我们的实验框架中，使用了一种简单的基于活跃性分析暴力分配算法，下面我们将对这个暴力算法做简单介绍。 暴力寄存器分配算法 我们的暴力寄存器分配算法是基于活跃性分析的，关于活跃性分析，为了避免一次实验包含太多知识，我们将会在 step8 详细介绍活跃性分析的相关理论。你现在只需了解，活跃性分析是为了求解当前临时变量是否还会在后续的程序中被用到。 基于活跃性分析的暴力寄存器分配算法的基本思路为：针对每一条中间代码指令（例如 _T2 = ADD _T1, _T0），对于每条指令的源操作数（本例中 _T1 和 _T0），我们查看是否已经放在寄存器里面，如果不是则分配一个寄存器并从栈帧中把该变量加载进寄存器中；对于每条指令的目标操作数（本例中 _T2），如果它还没有跟某个寄存器关联，则分配一个新的寄存器给它。 当分配寄存器的时候，我们首先查看有没有寄存器是空闲的（即尚未跟某个临时变量关联），有则选择该寄存器作为分配结果。否则看查看有没有寄存器所关联的临时变量在当前已经不是活跃变量了，这说明该寄存器所保存的数据已经不会被用到了，我们可以放心的把这个寄存器交待分配的临时变量而不用担心数据缺失的问题。最糟糕的是，当前所有寄存器所关联的变量都是活跃的，这说明没有空闲寄存器可以被用于分配，我们的做法是把某个寄存器所关联的现在暂时不用的变量“扔”到栈帧（内存的一部分）中，从而腾出这个寄存器。选取受害者寄存器的方法是随机选取，这也是为什么我们的分配算法叫暴力算法。 细心的同学或许已经注意到了，我们在分配寄存器的时候提到了从栈帧中加载数据及将暂时不用的变量存储到栈帧中，那么什么是栈帧呢？ 栈帧 栈帧的概念 汇编语言课上提到过栈帧的概念，简单回想一下：每次调用和执行一个函数，都会在栈上开辟一块新的空间，这片空间就叫做“栈帧”，栈帧中存放了函数执行所需的各种数据，包括需要临时保存的局部变量、在栈上临时申请的存储空间（如数组，我们在 step11 中会讲到）、被调用者负责保存的寄存器等等。栈帧是函数正确调用和执行的保证。 需要注意的是，由于我们目前只支持一个 main 函数，直到 step9 才会有多函数支持。所以现在关于栈帧的讨论，就只针对 main 函数的栈帧，并且集中于临时变量的存储和加载。 下图给出了一个函数的栈帧，我们假设当前函数被某个函数调用。如图所示，当前函数的栈帧由被调用者负责保存的寄存器、保存的临时变量以及局部变量三个部分组成，fp 指向当前栈帧的栈底，sp 指向当前栈帧的栈顶，fp 和 sp 之间的部分就是当前函数的栈帧。当前步骤中，我们需要关注的是临时变量保存区域，正是在这片区域中，保存了寄存器分配中被踢出原来寄存器，但是仍活跃的临时变量。值得一提的是，临时变量保存区域中还保存了基本块出口仍活跃的临时变量，关于基本块的概念，我们将在 step8 提出，这里你只需要知道临时变量保存区域不只有被踢出寄存器的“受害者变量”即可。 栈帧的建立与销毁 栈帧是函数运行所需要的上下文的一部分，在进入函数的时候需要建立自己的栈帧，在退出函数的时候需要销毁自己所建立的栈帧。既然栈帧如此重要，程序在运行的过程中应该怎么建立和销毁呢？实际上，建立栈帧的操作是由编译器生成代码完成的。每个函数最开始、由编译器生成的用于建立栈帧的那段汇编被称为函数的 prologue，prologue 需要做的事情有：分配栈帧空间、保存相应寄存器。相应的，函数末尾、用于销毁栈帧的一段汇编叫函数的 epilogue，epilogue 需要做的事情有设置返回地址、回收栈帧空间以及从当前子过程返回。 听上去创建和销毁栈帧是一个大工程？实际上，确定栈帧，我们只需要维护好两个寄存器就可以了：sp 和 fp，它们分别保存当前栈帧的栈顶地址和栈底地址。当新的函数被调用，我们需要把旧栈帧的栈底地址（fp）保存起来，用旧栈帧的栈顶地址（sp）表示新栈帧的栈底地址（新fp）。不难看出，新老栈帧在栈内存中是连续的空间。此外，每个函数体中需要分配的局部变量以及需要保存的临时变量在编译器都是可知的，因此，栈帧的大小在编译期也是可知的：保存寄存器的空间+临时变量保存空间+局部变量空间。在获得栈帧大小之后，我们通过适当修改栈顶指针（sp）的值，分配恰当的栈帧空间。 实际上，我们在实验框架中已经给出了寄存器分配以及栈帧创建、销毁的代码，下面我们就给出代码所在的位置，感兴趣的同学可以参考代码和注释进行深入学习。 python 框架： 寄存器分配算法主要集中在 backend/reg/bruteregalloc.py 中，主要有以下几个函数： accept：根据每个函数的 CFG 进行寄存器分配，寄存器分配结束后生成相应汇编代码 bind：将一个 Temp 与寄存器绑定 unbind：将一个 Temp 与相应寄存器解绑定 localAlloc：根据数据流对一个 BasicBlock 内的指令进行寄存器分配 allocForLoc：每一条指令进行寄存器分配 allocRegFor：根据数据流决定为当前 Temp 分配哪一个寄存器 C++ 框架： 寄存器分配算法主要集中在 src/asm/riscv_md.cc 中，主要有以下几个函数： getRegForRead：为源操作数对应的临时变量分配寄存器。 getRegForWrite：为目标操作数对应的临时变量分配寄存器。 selectRegToSpill：选择寄存器不足时，溢出到栈内存的寄存器，目前是随机算法。 栈帧建立和销毁分别位于 emitProlog 函数和 emitTrace 函数中。 思考题 描述程序运行过程中函数栈帧的构成，分成哪几个部分？ 有些语言允许在同一个作用域中多次定义同名的变量，例如这是一段合法的 Rust 代码（你不需要精确了解它的含义，大致理解即可）： fn main() { let a = 0; let a = f(a); let a = g(a); } 其中f(a)中的a是上一行的let a = 0;定义的，g(a)中的a是上一行的let a = f(a);。 如果 MiniDecaf 也允许多次定义同名变量，并规定新的定义会覆盖之前的同名定义，请问在你的实现中，需要对定义变量和查找变量的逻辑做怎样的修改？ 总结 Step5 主要涉及的知识为符号表、寄存器分配和栈帧，对于大家来说有一定的跳跃性和挑战性，希望大家能够尽早开始。 "},"docs/step5/manual-parser.html":{"url":"docs/step5/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 推荐你先阅读本节其他部分，了解栈帧和对局部变量的处理方式。 定义变化 struct Node { + Var* var; } // 为了维护变量信息的结构体 + struct Var { + char* name; + int offset; // 在栈中距离 fp 的 offset + Node* init; // 初始化的值 + } parse 变化 语句类别变多了： Node* stmt() { Node* node = NULL; Type* ty; // Return statement if (parse_reserved(\"return\")) { node = new_stmt(ND_RETURN, expr()); assert(parse_reserved(\";\")); return node; } // 局部变量声明 if (type()) { return declaration(); } // 直接由表达式构成的语句，注意 a = 1; 就是此类，有一个表达式的值没有用到 node = expr(); assert(parse_reserved(\";\")); return new_stmt(ND_UNUSED_EXPR, node); } 具体的 declaration()等按照生成式很容易写出来。 declaration : type Identifier ('=' expression)? ';' Node* declaration() { // type() 已经在 stmt() 中完成 char* name; assert(parse_ident(name)); Var* var = new Var(name); // 这里储存已经声明变量的信息，为名称解析做准备 add_local(var); // 如果进行了初始化 if (parse_reserved(\"=\")) { var->init = expr(); } assert(parse_reserved(\";\")); Node* node = new_stmt(ND_DECL); node->var = var; return node; } 在被引用时： Node* primary() { // ... char* name; if (parse_ident(name)) { // find_var 负责寻找同名变量, 在 add_local 维护的数据结构中寻找即可 Var* var = find_var(name); // 引用未声明变量的检查 assert(var); return new_var_node(var); } // ... } [可选]变量信息维护 变量信息的维护可以在 IR 生成中进行，也可以在 parser 的同时进行（本文中就是这样做的），也可以专门作为一个步骤进行。 在处理变量声明时需要维护已声明变量的信息(add_local())，可以使用链表，也可以使用你喜欢的数据结构来维护它。不过要注意 add_local()中应该同时完成 offset 的确定和变量重复定义的检查。在变量被引用时，你需要通过名称找到对应的结构体。 "},"docs/step5/spec.html":{"url":"docs/step5/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step5 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement* '}' type : 'int' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step5 语义规范 5.1 每一条变量声明（定义）指定了对标识符的解释和属性。当变量被定义时，应当有一块存储空间为这个变量所保留。当变量声明之后，若与这个变量的名称相同的标识符作为操作数（operand）出现在一个表达式中时，其就应被指派（designate）为这个变量。 5.2 变量的初始化表达式指定了变量的初始值。 5.3 同一个标识符应只能作为至多一个变量的名字，即是说，不允许声明重名变量。 5.4 对未声明的变量的使用是错误。 5.5 没有被初始化的（局部）变量的值是不确定的。 在初始化表达式中，正在被初始化的变量已被声明，但其值尚未被初始化。 例如，int a = a + 1;，这样一条声明在语义上等价于 int a; a = a + 1; 5.6 局部变量的名字可以为 main。 5.7 赋值运算 = 的左操作数必须是一个可修改的左值（modifiable lvalue）。左值（lvalue）即一个会被指派为某个变量的表达式，如在 int a; a = 1; 中，a 即是一个会被指派为变量的表达式。左值可修改是指被指派的变量不能是一个左值数组。 就 step5 来说，这一点其实几乎已经被语法保证，因为其 = 的左边只能是一个标识符，只需再要求其是一个已经声明过的变量的名字即可。 详见后面 step12 的讨论。 5.8 在赋值运算（=）中，右操作数的值会被存在左操作数所指派的变量中。 5.9 赋值表达式的结果，为赋值运算完成后左操作数所指派的变量的值，但这个结果本身并非左值。 5.10 一个函数中可以有任意多条 return 语句。 5.11 当 main 函数执行至 } 时，应终止执行并返回 0。 "},"docs/step6/intro.html":{"url":"docs/step6/intro.html","title":"任务概述","keywords":"","body":"实验指导 step6： step6 我们要支持 if 语句和条件表达式（又称三元/三目表达式，ternary expression）。 语法上的改动是： if 表达式 statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? 条件表达式 assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional block_item：为了下一阶段做准备 function : type Identifier '(' ')' '{' block_item* '}' block_item : statement | declaration if 语句的语义和 C 以及常识相同，条件表达式优先级只比赋值高。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step6/example.html":{"url":"docs/step6/example.html","title":"通过例子学习","keywords":"","body":"step6 实验指导 本实验指导使用的例子为： int main() { int x = 1; if (x) x = 2; else x = 3; return x; } 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 注意 step6 引入 block_item 后，declaration 不再是语句，所以 if (a) int b; 不是的合法代码。 这和 C 标准是一致的（不过在C++中这样的代码是合法的，也许这更加符合你的常识）。 悬吊 else 问题 这一节引入的 if 语句既可以带 else 子句也可以不带，但这会导致语法二义性：else 到底和哪一个 if 结合？ 例如 if(a) if(b) c=0; else d=0;，到底是 if(a) {if(b) c=0; else d=0;} 还是 if(a) {if(b) c=0;} else d=0;（其中有大括号，step7中会支持，不过意思不难理解）？ 这个问题被称为 悬吊 else（dangling else） 问题。 如果程序员没有加大括号，那么我们需要通过一个规定来解决歧义。 我们人为规定：else 和最近的 if 结合，也就是说上面两种理解中只有前者合法。 为了让 parser 能遵守这个规定，一种方法是设置产生式的优先级，优先选择没有 else 的 if。 按照这个规定，parser 看到 if(a) if(b) c=0; else d=0; 中第一个 if 时，选择没有 else 的 if； 而看到第二个时只能选择有 else 的 if 1，也就使得 else d=0; 被绑定到 if(b) 而不是 if(a) 了。 需要说明的是 bison 默认在 shift-reduce conflict 的时候选择shift，从而对悬挂else进行就近匹配。 语义分析 本步骤中语义分析没有特别需要增加的内容，只需要在扫描到 if 语句和条件表达式时递归地访问其子结点即可。请注意 if 语句不总是有 else 分支，所以在递归到子结点时，请先判断子结点是否存在。 中间代码生成 从本步骤开始，由于 MiniDecaf 程序出现了分支结构，我们需要开始考虑跳转语句了。在 Step1-4 中，TAC 代码中的标签只有标志 main 函数入口这一个功能。而现在，我们需要使用标签来指示跳转指令的目标位置。我们用 _Lk 来表示跳转用标签，以此和函数入口标签区分开来。 为了实现 if 语句，我们需要设计两条中间代码指令，分别表示条件跳转和无条件跳转，给出的参考定义如下： 指令 参数 作用 BEQZ T0, Label 若 T0 的值为0，则跳转到 LABEL 标签处 JMP Label 跳转到 LABEL 标签处 现在让我们来看看示例所对应的 TAC 代码： main: _T1 = 1 _T0 = _T1 BEQ _T0, _L1 _T2 = 2 _T0 = _T2 JMP _L2 _L1: _T3 = 3 _T0 = _T3 _L2: return _T0 在这段 TAC 代码中，x 对应的临时变量为 _T0。如果 x 的值为真（不等于0），那么应当执行 then 分支 x = 2;，否则执行 else 分支 x = 3;。因此，我们设置了两个跳转标签 _L1 和 _L2，分别表示 else 分支开始位置和整个 if 语句的结束位置。如果 x 为假，那么应当跳转到 _L1 处，我们使用一条 BEQ 指令来执行。如果 x 为真，那么按顺序执行 then 分支的代码，并在该分支结束时，用一条 JMP 指令跳转到 if 语句的结束位置，从而跳过 else 分支。在 TAC 生成过程中，每当扫描到 if 语句时，都需要调用 TAC 的底层接口，新建两个跳转标签，并按照这种方式生成中间代码。 当然，如果一条 if 语句没有 else 分支，那么只需要一个跳转标签即可。例如我们将例子中的 if 语句修改为 if (x) x = 2;，则对应的 TAC 代码可简化为： main: _T1 = 1 _T0 = _T1 BEQ _T0, _L1 _T2 = 2 _T0 = _T2 _L1: return _T0 同样地，条件表达式也可以使用类似的方法完成中间代码生成。要注意的是，条件表达式是一种特殊的表达式，因此有返回值。同学们在实现的时候不要忘记为其分配临时变量。 目标代码生成 step6 中目标代码生成主要是指令的选择以及 label 的声明，RISC-V 提供了与中间代码中 BEQ 和 JMP 类似的指令： step6: # RISC-V 汇编标签 beqz t1, step6 # 如果t1为0，跳转到 step6 标签处 j step6 # 无条件跳转到 step6 标签处 思考题 Rust 和 Go 语言中的 if-else 语法与 C 语言中略有不同，它们都要求两个分支必须用大括号包裹起来，而且条件表达式不需要用括号包裹起来： if 条件表达式 { // 在条件为 true 时执行 } else { // 在条件为 false 时执行 } 请问相比 C 的语法，这两种语言的语法有什么优点？ 总结 本节主要就是引入了跳转，后面 step8 循环语句还会使用。 备注 1. 见思考题 ↩ "},"docs/step6/manual-parser.html":{"url":"docs/step6/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 增加两种新节点的同时，需要增加 Node 的内容。 struct NodeKind { + ND_IF, + ND_TERN, // :? 运算 } struct Node { + Node* cond; // 储存条件表达式 + Node* then; // 储存条件判断成功时执行的语句（返回的表达式） + Node* else; // 储存条件判断失败时执行的语句（返回的表达式） } 注意，对于 :?运算符，then 和 else 是两个表达式节点， 对于 if 语句，这两个变量是两个语句节点。 解析变化 按照生成式变化改变即可。if 语句示例如下： Node* stmt() { // ... // IF statement if (parse_reserved(\"if\")) { assert(parse_reserved(\"(\")); node = new_node(ND_IF); node->cond = expr(); assert(parse_reserved(\")\")); node->then = stmt(); if(parse_reserved(\"else\")) node->els = stmt(); return node; } // ... } 以后同质化的内容不再展示。 "},"docs/step6/spec.html":{"url":"docs/step6/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step6 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' block_item* '}' type : 'int' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier 注意：if 的 then 分支和 else 分支需要是一个语句（statement）而非声明（declaration）。 例如 if (1) int a; 不是合法的 MiniDecaf 程序。 step6 语义规范 6.1 条件表达式会先对第一个操作数求值，再根据其值选择计算第二个或第三个操作数。当且仅当第一个操作数的值不等于 0，我们会对第二个操作数求值。当且仅当第一个操作数的值等于 0，我们会对第三个操作数求值。当第一个操作数的值为 0 时，条件表达式的求值结果为第二个操作数所求得的值；当第一个操作数的值非 0 时，条件表达式的求值结果为第三个操作数所求得的值。 不论选择第二个操作数或者是第三个操作数去求值，都必须首先计算完第一个操作数，之后才能开始第二个或第三个操作数的求值计算。 6.2 对于 if 语句而言，当控制条件不等于 0 时，会执行第一个子句；当控制条件等于 0 时，如果有 else 分支，就会执行第二个语句，否则整个 if 语句的执行便已经完成。 6.3 如果出现悬吊 else（dangling else），要求 else 优先和最接近的没有匹配 else 的 if 匹配。 例如 if (0) if (0) ; else ; 等价于 if (0) { if (0) ; else; } 而非 if (0) { if (0) ; } else ;。 "},"docs/step7/intro.html":{"url":"docs/step7/intro.html","title":"任务概述","keywords":"","body":"实验指导 step7：作用域和块语句 step7 我们要增加块语句的支持。 虽然块语句语义不难，就是把多个语句组成一个块，每个块都是一个作用域。 随之而来一个问题是：不同变量可以重名了。 重名的情况包括作用域内部声明覆盖（shadowing）外部声明，以及不相交的作用域之间的重名变量。 因此，变量名不能唯一标识变量了，同一个变量名 a 出现在代码不同地方可能标识完全不同的变量。 我们需要进行 名称解析（name resolution），确定 AST 中出现的每个变量名分别对应那个变量。 语法上改动不大 function : type Identifier '(' ')' compound_statement compound_statement : '{' block_item* '}' statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement 语义检查我们也要修改了，只有在同一个作用域里，变量才不能重复声明。 当然，如果变量在使用前还是必须先被声明。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step7/example.html":{"url":"docs/step7/example.html","title":"通过例子学习","keywords":"","body":"step7 实验指导 本实验指导使用的例子为： int main() { int x = 1; { x = 2; int x = 3; } x = 4; return x; } 词法语法分析 TODO：按照规范要求增加新的语法树结点和语法规则。 语义分析 从 Step7 开始，我们需要考虑作用域和代码块。简而言之，一份代码中可能有多个代码块的嵌套，因此作用域开始出现了层次结构。例如，在示例中，尽管 main 函数里定义了变量 x，但随后我们开启了一个新的代码块。在这个代码块中，赋值语句 x = 2; 中的 x 就是指 main 作用域中定义的 x，而随后通过 int x = 3; 我们定义了另一个变量 x，这个 x 只在内部大括号括起的作用域内生效。 在 Step5 中，我们只维护了 main 的作用域，所有符号都在这个作用域的符号表中维护。现在，为了维护层次嵌套的作用域，我们引入了作用域栈（Scope Stack）这个数据结构。在进行符号表构建的扫描过程中，我们需要动态维护作用域栈，保存当前扫描结点所在的从内到外所有作用域。每次我们开启一个代码块时，要新建一个作用域并压栈；而当退出代码块时，要弹栈关闭此作用域。 让我们看看示例里怎样维护作用域栈。栈底是一个全局作用域，目前它的符号表里只有 main 函数。由于我们目前不需要考虑函数和全局变量，因此可以暂时忽略全局作用域。进入 main 函数时，开启一个局部作用域，在扫描 int x = 1; 时定义变量符号 x，并将之加入栈顶作用域的符号表中。如下所示： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域（栈顶） 变量 x 之后，我们扫描到一个局部代码块，开启一个局部作用域并压栈。在扫描 x = 2; 时，我们需要分析 x 这个变量对应着哪个作用域里的符号。此时的作用域栈是这样的： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域 变量 x 局部作用域（栈顶） 空 我们从栈顶开始，自顶向下依次查找变量 x 直至找到为止。在栈顶作用域中，符号表中没有变量符号 x，于是向下继续查找。在 main 函数对应的作用域中，我们找到了变量符号 x，因此此处的 x 就对应 main 函数作用域里定义的变量 x。 接着，我们扫描到了语句 int x = 3;，定义变量时，我们只需要在栈顶作用域中查找该变量是否存在。若不存在，即可定义。此时的作用域栈是这样的： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域 变量 x 局部作用域（栈顶） 变量 x 请务必注意上表中的两个变量 x 是不同的变量。 接着，我们退出代码块，弹栈，此时的作用域栈变成了： 作用域栈 符号表 全局作用域（栈底） 函数 main（可忽略） 局部作用域（栈顶） 变量 x 最后访问语句 x = 4;，此时我们从作用域栈中找到的变量 x 变为了 main 作用域里的 x。 中间代码生成 本步骤中无须新增新的 TAC 指令。 让我们来看看示例所对应的 TAC 代码： main: _T1 = 1 _T0 = _T1 # int x = 1; _T2 = 2 _T0 = _T2 # x = 2 _T4 = 3 _T3 = _T4 # int x = 3; _T5 = 4 _T0 = _T5 # x = 4; return _T0 显然，两个代码块里的变量 x 是不同的变量，因此它们分别对应着不同的临时变量。其中，_T0 对应着 main 作用域里的 x，而 _T3 则对应着内层代码块定义的变量 x。只要同学们在符号表构建阶段把每个变量和正确作用域的变量符号关联起来，这一步就非常简单了：找到对应变量符号，使用该符号对应的临时变量即可。 目标代码生成 由于不需要新增新的中间代码指令，本步骤中目标代码生成模块没有新的工作，但这是建立在你之前的实现没有错误基础上的。 思考题 请将下述 MiniDecaf 代码中的 ??? 替换为一个 32 位整数，使得程序运行结束后会返回 0。 int main() { int x = ???; if (x) { return x; } else { int x = 2; } return x; } 在实验指导中，我们提到“就 MiniDecaf 而言，名称解析的代码也可以嵌入 IR 生成里”，但不是对于所有语言都可以把名称解析嵌入代码生成。试问被编译的语言有什么特征时，名称解析作为单独的一个阶段在 IR 生成之前执行会更好？ "},"docs/step7/spec.html":{"url":"docs/step7/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step7 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step7 语义规范 7.1 根据其声明的位置，每一个标识符都属于一个作用域。目前我们有两种作用域：文件级和块级。如果是在块中声明，则标识符其声明所属的块的作用域中，例如局部变量；否则标识符在文件级（全局）作用域中，例如全局变量。 7.2 （更新 5.6）如果一个标识符在两个作用域里面，这两个作用域必然是嵌套的，即一个内层作用域完全被另一个外层作用域所覆盖。且在内层作用域中，外层作用域里该标识符所指派（designate）的变量或函数是不可见的。 在初始化表达式中，其正在初始化的变量已被声明，会隐藏（shadow）外层作用域的同名变量，但其值不确定。例如在下面的代码片段中，a + 1 的值是不确定的。 int a = 1; { int a = a + 1; } 7.1 （更新 5.3）对于同一个标识符，在同一个作用域中至多有一个声明。 7.3 （更新 5.4）使用不在当前开作用域中的变量名是不合法的。 "},"docs/step8/intro.html":{"url":"docs/step8/intro.html","title":"任务概述","keywords":"","body":"实验指导 step8：循环语句 step8 我们要增加对循环语句，以及 break/continue 的支持： statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' 循环语句的语义和 C 的也相同，并且我们要检查 break/continue 不能出现在循环外。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step8/example.html":{"url":"docs/step8/example.html","title":"通过例子学习","keywords":"","body":"step8 实验指导 本实验指导使用的例子为： for (int i = 0; i 词法语法分析 TODO：按照规范要求增加新的语法树结点和语法规则。 语义分析 本步骤语义分析阶段的处理方式和 Step6 中的 if 语句相类似，但是请额外注意以下两点： for 循环要自带一个作用域。在示例里，for (int i = 0; i 语句里定义的循环变量处于一个独自的作用域里。这也就是说，我们可以在循环体内部定义同名变量。如果我们把示例修改为：for (int i = 0; i 这也是合法的 MiniDecaf 程序。因此，在符号表构建阶段，扫描到 for 结点时，不要忘记开启一个局部作用域。 break 和 continue 语句必须位于循环体内部才合法。因此，在扫描过程中，需要记录当前结点位于多少重循环内。扫描到 break 和 continue 结点时，若当前不处于任何循环内，则报错。 中间代码生成 本步骤中没有需要新增的 TAC 指令。不过为了实现循环语句，需要仔细地考虑如何将 MiniDecaf 循环语句翻译成 TAC 的分支跳转指令。由于 while 循环、do-while 循环都可以看作 for 循环的特例，我们选择了 for 循环作为示例。 让我们先来看看示例对应的 TAC 代码： _T1 = 0 _T0 = _T1 # int i = 0; _L1: # begin label _T2 = 5 _T3 = LT _T0, _T2 BEQ _T3, _L3 # i 为了实现所有可能的跳转，对每个 for 循环我们都需要定义三个跳转标签：begin, loop 和 break。它们的作用如下： begin 标签是循环体的开始位置。初次进入循环时，从这个标签的位置开始执行，并判断循环条件是否满足，若不满足，则跳转到 break 标签处。 loop 标签是执行 continue 语句时应当跳转到的位置。 break 标签是整个循环结束后的位置。如果循环条件不满足，或者执行了 break 语句，那么应当跳转到此处，执行循环之后的指令。 请注意，示例给出的只是一种参考的循环语句实现方法，同学们也可以选择自己喜欢的实现方法。 由于循环语句可能发生嵌套，因此 TAC 生成过程中需要动态维护 loop 标签和 break 标签才能知道每一条 continue 和 break 语句跳转到何处。因此，在 TAC 生成时，需要使用栈结构维护从内到外所有的 loop 标签和 break 标签。 Python 框架 utils/tac/funcvisitor.py 里的 FuncVisitor 类里实现了维护 TAC 生成时需要的上下文信息的功能。同学们可以在这个类中增加对循环所需的 continue/break 标签的维护。 C++ 框架 同学们可以直接在 translation/translation.hpp 中的 Visitor 中用成员变量维护 continue/break 标签。 目标代码生成 由于不需要新增新的中间代码指令，本步骤中目标代码生成模块没有新的工作，但这是建立在你之前的实现没有错误基础上的。 "},"docs/step8/dataflow.html":{"url":"docs/step8/dataflow.html","title":"数据流分析","keywords":"","body":"数据流分析 大多数编译优化的基础是数据流分析。 基本块（basic block）和控制流图（control-flow graph）是用于进行上述分析的数据结构。 以下讲述数据流分析的内容中，所有的 CondBranch 指令为条件跳转指令，Branch 指令为跳转指令。 基本块 所谓的基本块，是指一段这样的代码序列： 除出口语句外基本块中不含任何的 Branch、Beqz、Bnez 或者 Return 等跳转语句（但可以包含 Call 语句）。 除入口语句外基本块中不含任何的 Label 标记，即不能跳转到基本块中间。 在满足前两条的前提下含有最多的连续语句，即头尾再纳入一条语句的话均会违反上面两条规则。 例如下面的代码中不同的基本块被使用不同的颜色标记出来： 也就是说，基本块内的代码执行过程总是从基本块入口开始，到基本块出口结束的，中间不会跳到别的地方或者从别的地方跳进来。 控制流图 所谓控制流图是这样的一幅有向图：它以基本块作为结点，如果一个基本块执行完以后可能跳转到另一个基本块，则图中含有从第一个基本块指向后一个基本块的有向边。对于以 Jump 语句或者任何非跳转语句结尾的基本块，其后继只有一个结点；对于以 CondBranch 语句结尾的基本块，其后继含有两个结点，分别对应着跳转条件成立和不成立的时候的下一个基本块。不难想像，控制流图是一个有向图，其中的每一个环路都对应着程序中的一个循环结构。由于这幅图体现的是程序控制流的各种可能执行路径，因此这幅图称为控制流图。 对于优化编译器来说，建立控制流图是对代码进行优化的过程中必不可少的一步。已知一个操作序列，如何根据这个操作序列建立对应的控制流图呢？我们通常是划分为两步进行：第一步划分基本块，第二步建立基本块之间的连接关系。 在划分好基本块以后，我们需要从头到尾依次扫描所有的基本块建立控制流图： 如果当前基本块以 Branch 结尾，则我们在当前基本块和目标基本块之间加入一条边； 如果当前基本块以 CondBranch 结尾，则我们在当前基本块和跳转条件成立（不成立）的目标基本块之间加入一条边。（共 2 条边） 如果当前基本块以 Return 结尾，则不用加入新的边。 当所有的基本块都扫描完毕以后控制流图即可建立完毕。建立控制流图是进行控制流分析的基本操作。 活跃变量和活跃变量方程 从编译器中端出来的中间代码中，我们对 TAC 中使用的临时变量的个数并没有做任何限制。但是在实际机器中，物理寄存器的数量是有限的。 因此我们需要想办法把这些无限多的临时变量“塞”到有限个物理寄存器里面：如果两个临时变量不会在同一条指令中被用到，那么我们可以让这两个临时变量使用同一个物理寄存器（把一部分当前指令用不到的临时变量保存到栈上）。 根据这样的原则，大多数的临时变量都可以用有限的几个物理寄存器对应起来，而“塞不下”的那些临时变量，则可以暂时保存到内存里面（因为访问内存的时间比访问寄存器的时间多得多，因此临时变量应尽可能一直存放在物理寄存器中，尽量不要 spill 到栈上）。 由于一个物理寄存器在确定的时刻只能容纳一个临时变量，因此为了把若干个变量塞到同一个物理寄存器里面，我们需要知道各个临时变量分别在哪条指令以后不会再被用到（以便腾出当前临时变量占用的物理寄存器给别的临时变量）。此时我们需要用到活性分析（liveness analysis），或者称为“活跃变量分析”。 一个临时变量在某个执行点是活的（也叫“活跃”、live），是指该临时变量在该执行点处具有的值会在这个执行点以后被用到，换句话说，就是在该执行点到给这个临时变量重新赋值的执行点之间存在着使用到这个临时变量的语句。活性分析是指分析每一个临时变量在程序的每一个执行点处的活跃情况，通常是通过计算出每个执行点处的活跃变量集合来完成。 下面代码中每行语句右边都给出了执行完该语句后的活跃变量集合： TAC 代码 活跃变量集合 _T0 = 4 {_T0} _T1 = 3 {_T0, _T1} _T2 = _T0 * _T1 {_T0} _T3 = _T0 * _T0 {_T0, _T3} _T2 = _T3 * _T3 {_T0, _T2, _T3} _T2 = _T0 * _T2 {_T2, _T3} _T1 = _T2 * _T3 {_T1} return _T1 空集 一般来说，活性分析是通过求解活跃变量方程来完成的。为了介绍活跃变量方程的概念， 我们需要先引入下面四种针对基本块的集合： Def 集合：一个基本块的 Def 集合是在这个基本块内被定值的所有变量。所谓的定值 （definition），可以理解为给变量赋值，例如加法语句给目标变量定值等等（但是 Store 语句不给任何变量定值）。 LiveUse 集合：一个基本块的 LiveUse 集合是在这个基本块中所有在定值前就被引用过的变量，包括了在这个基本块中被引用到但是没有被定值的那些变量。 LiveIn 集合：在进入基本块入口之前必须是活跃的那些变量。 LiveOut 集合：在离开基本块出口的时候是活跃的那些变量。 其中 Def 和 LiveUse 是基本块本身的属性，对每个基本块从后往前遍历基本块内的指令便可以求出。 有了基本块的这四个集合的概念，我们给出控制流图中每个基本块满足的活跃变量方程: 该方程说的是一个基本块的 LiveOut 集合是其所有后继基本块的 LiveIn 集合的并集，而且 LiveIn 集合是 LiveUse 集合的变量加上 LiveOut 集合中去掉 Def 集合以后的部分。 这个方程的直观意义是： 一个基本块的任何一个后继基本块入口处活跃的变量在这个基本块的出口必须也是活跃的。 在一个基本块入口处需要活跃的变量是在该基本块中没有定值就被使用的变量，以及在基本块出口处活跃但是基本块中没有定值过的变量（因为它们的初值必定是在进入基本 块之前就要具有的了）。 根据这个方程，我们可以通过迭代更新的办法求出每个基本块的 LiveIn、LiveOut 集合，以下是求解的伪代码： for i 获得了每个基本块的 LiveIn 和 LiveOut 集合以后，我们需要进一步地计算基本块内每个 TAC 语句的 LiveIn 和 LiveOut 集合。如果我们把基本块内所有 TAC 语句分别看成是一个独立的基本块，则不难想像，前面提到的活跃变量方程仍然有效，不同的是这样的 “控制流图” 有以下三种特点： 每个节点的出度都是 1，也就是说 LiveOut(B) = LiveIn(Succ(B))。 由于每个结点只含有一个语句，因此其 Def 集要么是空集，要么只含有一个元素。 由于每个节点中第一个语句里面所引用到的所有变量在使用的时候都未经定值，因此其 LiveUse 集合就是源操作数中所有的变量。 基于上面三个特点，已经求出基本块的 LiveOut 集合的前提下我们只需要在每个基本块内从后往前遍历基本块内的指令就可以对每条基本块内指令求出 LiveIn、LiveOut。 "},"docs/step8/spec.html":{"url":"docs/step8/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step8 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step8 语义规范 方便起见，我们称 for 循环括号中的三个表达式/声明自左向右依次为 init、ctrl 和 post。 例如 for (i=0; i 中，i=0 是 init，i 是 ctrl，i=i+1 是 post。 8.1 有三种循环语句：for 循环、while 循环和 do 循环。执行一条循环语句，意味着反复执行一条语句（即循环体），直到其控制表达式等于 0。 8.2 while 循环的控制表达式的求值在循环体的每次执行之前。 8.3 do 循环的控制表达式的求值在循环体的每次执行之后。 8.4 对于 for 循环而言：如果 init 是一个声明，其声明发生在控制表达式的第一次求值之前；如果 init 是一个表达式，其求值会在控制表达式的第一次求值之前。ctrl 即是控制表达式，其求值在循环体的每次执行之前。post 的求值在循环体的每次执行之后。 8.5 for 循环的 init、ctrl 和 post 都可以被省略。省略 ctrl 等价于将其替换为一个非零常数，比如 1。 8.6 循环语句有其自己的作用域，且是它所在的作用域的子集。循环体也有其作用域，且是循环语句的作用域的子集。如果 for 循环的 init 是一条声明，则其所声明的变量所属的作用域是整个 for 循环语句的作用域（包含 init、ctrl、post 和循环体）。 例如，for (int i=0;;i=i+1) { int i=1; return i; } 是合法的代码片段。 8.7 continue 语句和 break 语句要么出现在循环体里，要么其就是循环体。 8.8 执行一条 continue 语句，意味着将程序的执行跳转至该条 continue 语句所在的最小的循环语句的循环体的末尾。 例如，for (int i=0;i 等价于 for (int i=0;i。 8.9 执行一条 break 语句，意味着终止该条 break 语句所在的最小的循环语句的执行。 "},"docs/step9/intro.html":{"url":"docs/step9/intro.html","title":"任务概述","keywords":"","body":"实验指导 step9：函数 step9 开始，我们要支持多函数了。 我们需要支持函数的声明和定义： program : function* function : type Identifier '(' parameter_list ')' (compound_statement | ';') parameter_list : (type Identifier (',' type Identifier)*)? 我们还需要支持函数调用： expression_list : (expression (',' expression)*)? unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' 语义检查部分，我们需要检查函数的重复定义、检查调用函数的实参（argment）和形参（parameter）的个数类型一致。 我们不支持 void 返回值，直接忽略 int 返回值即可。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step9/example.html":{"url":"docs/step9/example.html","title":"通过例子学习","keywords":"","body":"step9 实验指导 本实验指导使用的例子为： int func(int x，int y) { return x + y; } int main() { return func(1, 2); } 词法语法分析 TODO：按照规范要求增加新的语法树结点和语法规则。 语义分析 本步骤中我们引入了函数，和局部变量一样，我们也不能调用未定义的函数，或者重复定义同名函数。因此，我们需要在全局作用域的符号表里维护各种函数符号。函数就放在栈底的全局作用域中。构建符号表遍历 AST 过程中，栈底元素一直都在，不会被弹出。 此外，由于函数体内部除了局部变量以外，还有函数参数（argument）。因此，我们在进入一个函数时，需要开启一个位于全局作用域和函数体局部作用域之间的参数作用域（formal scope），并将所有参数加入符号表。 Python 框架 frontend/symbol/funcsymbol.py 里实现了函数符号。 C++ 框架 symb/symbol.hpp 中 Function 类表示函数符号。scope/scope.hpp 中，FuncScope 表示函数作用域。 中间代码生成 为了实现函数，我们需要设计两条中间代码指令，分别表示设置参数和函数，给出的参考定义如下： 指令 参数 含义 PARAM T0 将 T0 设置为下一个参数 CALL LABEL 调用函数 LABEL 假设我们有若干个参数，可以依次使用 PARAM 命令将它们加入参数列表。在调用函数时，这些参数的值会自动依次按顺序装载到临时变量 _T0, _T1 ... 中。比如我们有这样一段 TAC 程序： PARAM A PARAM B PARAM C XX = CALL XXX 那么，在进入 XXX 函数时，相当于执行了： _T0 = A _T1 = B _T2 = C 因此，示例可以对应如下的 TAC 程序： func: return _T1 # 参数 x 和 y 分别对应 _T0, _T1 main: _T0 = 1 PARAM _T0 # 将 _T0 的值作为参数 x _T1 = 2 PARAM _T1 # 将 _T1 的值作为参数 y _T2 = CALL func # 调用函数 return _T2 同学们可以使用这种参考的实现形式，也可以自行思考传参的处理方法。 目标代码生成 Step9 中我们接触到了函数调用这一表达式，函数调用是最复杂的一种表达式结构了。下面我们将详细介绍函数调用的步骤和约定，以及函数调用及返回过程中栈帧的变化。 函数调用 源码里的一个函数调用，实际包含了下面一系列的操作： 准备参数，完成传参。 （汇编）保存 caller-saved 寄存器。 执行汇编中的函数调用指令，开始执行子函数直至其返回。 （汇编）回复 caller-saved 寄存器。 拿到函数调用的返回值，作为函数调用表达式的值。 上述 1-5 有时又被称为调用序列（calling sequence）。然而在调用序列中有一些问题需要明确：如何进行参数传递？如何获取函数返回值？调用者（caller）和被调用者（callee）需要保存哪些寄存器，如何保存？调用者和被调用者通常会对这些问题形成统一的解答约定，并同时遵守这些约定，这些约定称为调用约定（calling convention）。调用约定通常是在汇编层级用到的，汇编语言课上也讲过。 因为汇编语言很底层，没有函数/参数的语言支持，只有标号/地址/寄存器，所以需要规定如何用汇编的语言机制模拟函数调用。 调用约定 我们已经知道，调用约定是 caller 和 callee 之间的约定。因此调用约定并不唯一，只要 caller 和 callee 之间的调用约定相同，那么函数调用就不会出现问题。在我们的实验文档中，我们将给出两种参考的调用约定：一种是 gcc 使用的 32 位 RISC-V 的标准调用约定，一种是简化之后的非标准调用约定。 需要说明的是，我们的测例中没有与 gcc 编译的文件相互调用的情况，因此你实现简化版的调用约定即可。但如果你对自己的编译器要求较高，比如想和用 gcc 编译出来的目标文件一起链接并进行相互的函数调用，那么你就需要实现我们给出的标准调用约定。 RISC-V 的标准调用约定（gcc 使用的、和 MiniDecaf 相关的） caller-saved 和 callee-saved 寄存器 上表给出了 RISC-V 中 32 个整数寄存器的分类。所谓 caller-saved 寄存器（又名易失性寄存器），就是指不需要在各个调用之间保存的寄存器，如果调用者认为自己在子函数调用之后仍然需要用到这些寄存器中的值，便需要自行保存。所谓 callee-saved 寄存器（又名非易失性寄存器），指这些寄存器需要在各个调用之间保存，调用者可以期望在子函数调用结束之后这些寄存器保持原来的值。这要求被调用者，如果使用这些寄存器，需要先进行保存，并在调用返回之前恢复这些寄存器的值。 具体的保存方法并不限制，但一般都使用栈来保存。 函数参数以及返回值的传递 参数（32 位 int）从左到右放在 a0 - a7 寄存器中，如果还有从右往左压栈，第 9 个参数在栈顶。你可以使用 gcc 自己编译一个有很多参数的函数调用进行验证。 返回值（32 位 int）放在 a0 寄存器中。 简化版的非标准调用约定 caller-saved 和 callee-saved 寄存器 callee 只需要保存 fp 和 ra。其中 fp 寄存器中存储调用者栈帧栈底地址，用于在函数调用结束之后恢复调用者的栈帧，ra 寄存器保存函数返回地址。由于我们的实验框架中提供了数据流分析模块，caller 只需保存活跃变量对应的寄存器（数据流分析和活跃变量见 step8）。 函数参数及返回值的传递 不使用寄存器进行传参，所有参数从右往左压栈，第 1 个参数在栈顶。 返回值（32 位 int）放在 a0 寄存器中。 函数调用过程中的栈帧变化（使用非标准调用约定） 为了帮助大家更好的理解，我们使用上述的简化版的非标准调用约定，画出了一段具有代表性的程序，其整个运行过程中栈帧的组成部分以及变化。代表性程序如下： int bar (int x, int y) { return x + y; } int foo () { int a = 1; int b = 2; int c = foo(a, b); // return a+c 的目的是为了讲解保存活跃变量的情况 return a + c; } TODO：待完成 思考题 MiniDecaf 的函数调用时参数求值的顺序是未定义行为。试写出一段 MiniDecaf 代码，使得不同的参数求值顺序会导致不同的返回结果。 "},"docs/step9/calling.html":{"url":"docs/step9/calling.html","title":"函数调用","keywords":"","body":"函数调用 函数调用是最复杂的一种表达式结构了。 源代码里的一个函数调用，其实包含了下面几个步骤 准备参数，完成传参 （汇编）保存 caller-save 寄存器 真正执行 call 指令（汇编上是 jalr 指令） 执行 call 然后是子函数执行的时间, 直到子函数 ret（汇编上是 jr ra）返回 （汇编）恢复 caller-save 寄存器 拿到返回值，作为函数调用这个表达式的值 这几步操作有时又被称为调用序列（calling sequence） 上面几步都需要我们确定 调用约定（calling convention）： （第 1.、5. 步）参数和返回值都如何准备、该放哪儿？ （第 2.、4. 步）哪些寄存器是 caller-save 的？ （在 prologue/epilogue 中）那些寄存器是 callee-save 的？ 调用约定通常是在汇编层级用到的，汇编语言课上也讲过。 因为汇编语言很底层，没有函数/参数的语言支持，只有标号/地址/寄存器，所以需要规定如何用汇编的语言机制模拟函数调用。 我们为了简单，IR 不提供对函数的语言支持，所以我们同样需要有 IR 的调用约定。 需要注意的是，调用约定只是一种约定，它不唯一。 x86 上常见的就有默认的 cdecl（汇编课讲过）、stdcall、fastcall 等好几种。 只要 caller 和 callee 的调用约定相同，那么函数调用就不会出问题。 RISC-V 的调用约定 32 位 RISC-V 的标准（指 gcc 使用的）的调用约定中，和我们相关的是： caller-save 和 callee-save 寄存器在 \"Unprivileged Spec\" 的 109 页。 返回值（32 位 int）放在 a0 寄存器中 参数（32 位 int）从左到右放在 a0、a1……a7 中。如果还有，则从右往左压栈，第 9 个参数在栈顶。 自己使用 gcc 编译一个有很多参数的函数调用即可验证。 为了简便和方便描述，我们下面使用一种非标准的调用约定。 callee 只需要保存 fp 和 ra，caller 无须保存寄存器 callee 把返回值放在 a0 中，caller 看到返回之后把返回值压入运算栈 参数不用寄存器传递，所有参数从右往左压栈，第 1 个参数在栈顶。 这个调用约定的优点是叙述和实现简单，但不标准。 你当然可以选择实现标准的调用约定，这样你的汇编能够和 gcc 的汇编互相调用，但是难度会大一些。 助教的实现用的也不一定是这个调用约定。 采用这个非标准的调用约定，仿照 step5 我们可以画出函数调用过程中栈帧的变化图。 可见现在栈帧包含四块，从顶向下依次是运算栈、实参、局部变量、fp 和 ra（下图 1.）。 其中还有一个问题就是形参的处理，例如上面 3. 到 4. 过程中，bar 要访问 a，那 a 放在哪儿？ 可以直接使用 foo 栈帧上的实参，那么 a 相对 fp 的偏移量为 0，同理 b 偏移量为 4。 因此 step7 中的偏移量计算方法仅限非参数的局部变量，而第 k>=0 个参数相对于 fp 的偏移量是 4*k。 还有一种方法是把参数当成普通局部变量，在 prologue 中复制到栈帧中局部变量的区域。 IR 的调用约定 对于 IR 类似上面简便的约定： 传参从右到左压栈 返回值放在栈顶 另外，IR 也需要保存返回地址，如果它要作为一门独立的语言，需要被执行的话。 但我们暂时没有这个需求，可以不管它。可以假设 call 指令会把返回地址保存到其他地方，并且同时把当前栈帧设为新函数的。 汇编的 call（就是 jalr）会保存返回地址到 ra，然后 prologue 里会保存 ra 到 callee 栈帧中。 "},"docs/step9/spec.html":{"url":"docs/step9/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step9 语法规范 灰色部分表示相对上一节的修改。 program : function* function : type Identifier '(' parameter_list ')' compound_statement type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier 我们暂不要求支持不包含函数体的函数声明。 step9 语义规范 9.1 在函数调用中，实参和形参的参数个数必须相同，同一位置的参数类型也必须相同。 9.2 在准备函数的调用时，所有的实参会被求值，然后赋给相应位置上的形参。 在函数体中，形参的值可能会被改变，但即便实参是一个可修改的左值，被调用函数中形参的改变也不会影响实参的值。 9.3 函数是可以递归调用的。 9.4 （更新 5.10）执行一条 return 语句，意味着终止当前函数的执行，并将控制权交还给调用当前函数的 caller，语句中的表达式的值会返还给 caller 作为函数调用的表达式的值。一个函数可以有任意多条 return 语句。 9.5 函数的形参可以被视为在函数体的开头被定义（被以实参的值初始化）的局部变量。所有形参均为左值，且不能被在函数体中直接重定义（除非是在一个更小的嵌套的块中）。 例如，int f(int x) { int x; } 不合法，但 int f(int x) { { int x; } } 合法。 9.6 如果一个不是 main 的函数执行到了它的 }，且其返回值被 caller 所使用，则这是一个未定义行为。 对于感兴趣的同学：C 语言中规定只有使用了返回值才是未定义行为，而 C++ 中规定不管返回值有没有被使用，都是未定义行为。 我们没有支持 void 类型，但可以忽略返回值达到类似的效果。 “执行到了 }” 意味着执行时没有通过 return 返回，例如 int f(){if(0) return 0;}。 实现的时候，你可以直接让所有函数都默认返回 0，语义规范说 main 之外的函数没有 return 是未定义行为，未定义行为的意思就是你想怎么处理都可以，所以全部默认返回 0 当然也是可以的，而且更清晰简单。 "},"docs/step10/intro.html":{"url":"docs/step10/intro.html","title":"任务概述","keywords":"","body":"实验指导 step10：全局变量 step10 我们要支持的是全局变量，语法改动非常简单： program : (function | declaration)* 全局变量和局部变量不同，它不是分配在栈上，而是放在某个固定地址，写在汇编的 .bss 段或 .data 段里。 访问它也不能通过 fp 加偏移量，而是需要通过它的符号加载它的地址，通过它的地址访问它。 汇编课上应该讲过，实际中（包括 gcc 和 qemu）使用的可执行文件的格式是 ELF（Executable and Linking Format）。 .text 是其中存放代码的段（section），.bss 和 .data 都是其中存放数据的段，前者零初始化后者须指定初始值。 对有兴趣的同学： 全局变量地址不是被狭义上的编译器（compiler）确定的，也不是被汇编器（assembler）确定的，而是被链接器（linker）或加载器（loader）确定的。 简单的说，狭义上的编译器把源代码变成文本汇编，汇编器把文本汇编给编码到二进制代码，然后通过链接器变成可执行文件，运行时由加载器加载到内存中运行。 当然，广义上的编译器就囊括了这所有阶段。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step10/example.html":{"url":"docs/step10/example.html","title":"通过例子学习","keywords":"","body":"step10 实验指导 本实验指导使用的例子为： int x = 2021; int main() { return x; } 词法语法分析 TODO：按照规范要求增加新的语法树结点和语法规则。 语义分析 在引入全局变量后，AST 的根结点的子结点不再只是函数了，还可能包括全局变量定义。全局变量就放在栈底的全局作用域中。构建符号表遍历 AST 过程中，栈底元素一直都在，不会被弹出。 中间代码生成 经过 Step5 的实验学习，我们知道局部变量是存储在寄存器或栈中的，可以直接访问。然而，全局变量存储在特别的内存段中，不能直接访问。我们建议加载一个全局变量的方式为首先加载全局变量符号的地址，然后根据地址来加载数据。因此我们需要定义两个中间代码指令，完成全局变量数值的加载： 指令 参数 含义 LOAD T1, offset 临时变量 T1 中存储地址，加载与该地址相差 offset 个偏移的内存地址中的数据 LOAD_SYMBOL symbol symbol 为字符串，加载 symbol 符号所代表的地址 有了上述两条指令，我们可以将测试用例翻译如下： main: _T0 = LOAD_SYMBOL x _T1 = LOAD _T0, 0 return T1 需要说明的是，你也可以把两条指令合并为一条指令，直接加载全局变量的值，但我们觉得分为两条指令扩展性更好。 请注意，翻译出的 TAC 代码里没有提到全局变量的初始值。同学们可以将变量的初始值存在变量符号里，在后端中通过读取符号表得到初值。当然这里只是一种参考实现，你也可以将全局变量的定义显式地写在 TAC 中，从而使中端与后端完全解耦。 目标代码生成 Step10 中目标代码生成的主要任务有：翻译中间代码，将全局变量放到特定的数据段中。 翻译中间代码 实际上，我们提供的中间代码设计和 RISC-V 汇编的思想是一致的，RISC-V 汇编中有对应 LOAD 和 LOAD_SYMBOL 的指令，我们直接给出翻译结果： main： la t0, x # _T0 = LOAD_SYMBOL x lw t1, 0(t0) # _T1 = LOAD _T0, 0 mv a0, t1 ret 将全局变量放到特定的数据段中 翻译中间代码步骤中（也就是上一点）有很大问题，需要加载的 x 符号究竟在哪，如果生成的汇编程序中通篇不涉及 x 的定义，程序肯定是有问题的。实际上，RISC-V 提供了一系列的汇编指令帮助声明数据段。 因为全局变量的声明都是一样的，所以我们直接给出测试用例的声明，不同的变量声明简要修改名称和初始值即可： .data .globl x x: .word 2021 其中 .data 表示输出到 data 段；.globl x 声明 x 为全局符号；.word 后是一个 4 字节证书，是 x 符号在内存的初始值。 按照约定 data 段中存放已初始化的全局变量，未初始化全局变量放到 bss 段中，如将未初始化的全局变量 x 存放到 bss 段的汇编如下，.space 表示预留一块连续的内存，4 表示大小（字节）。 .bss .globl x x: .space 4 思考题 请给出将全局变量 a 的值读到寄存器 t0 所需的 riscv 指令序列。 "},"docs/step10/spec.html":{"url":"docs/step10/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step10 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step10 语义规范 10.1 对于全局变量的初始化，我们仅对初始化表达式是整数字面量的情况做要求（例如 2123），对初始化表达式是非字面量的情况不做任何要求（例如 a 或 f() 或 2+3）。 C 其实也支持非字面量的编译期常量，例如 int a=1+3;。编译器可以计算出 1+3==4 然后让它等价于 int a=4;。 但为了实现简便，我们就不要求支持这点。 C 不允许 int a=f(); 因为 f() 不是编译器常量； 而 C++ 甚至可以支持 int a=f();，其大致实现为 int a=0; 然后在 main 之前执行的初始化函数中 a=f();。 10.2 我们对全局变量的重复声明不做任何要求或限定；但全局变量不能被重复定义，即不能有同名的被初始化的全局变量。 int a; int a=2; int a; int main(){ return a;} 是合法的 C 代码，不过不是合法的 C++ 代码，也许 C++ 的处理方式更符合你的直觉。 为了简单，我们不要求这点。比如对于形如 int a; int a=2; 或 int a; int a; 的代码片段，你可以以任意方式处理。 10.3 如果一个全局变量没有被初始化，我们认为其拥有一个默认初始值 0。 "},"docs/step11/intro.html":{"url":"docs/step11/intro.html","title":"任务概述","keywords":"","body":"实验指导 step11：数组 step11 支持的是数组和指针算术： 语法上没有太大改动， 数组的声明： declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' 数组和指针的下标操作 postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' 指针算术：语法不变，但允许：指针加/减整数、整数加指针、指针减指针了。 step11 难度不大，但有了数组让我们能够写很多有意思的程序了，step11 之前甚至 MiniDecaf 连快速排序都写不了。 你需要： 改进你的编译器，支持本节引入的新特性，通过相关测试。 完成实验报告（具体要求请看网络学堂的公告）。 "},"docs/step11/example.html":{"url":"docs/step11/example.html","title":"通过例子学习","keywords":"","body":"step11 实验指导 本实验指导使用的例子为： int x[10]; int main() { int y[10]; return 0; } 词法语法分析 TODO：按照规范要求增加新的语法树结点和语法规则。 语义分析 由于 Step11 里引入了数组，现在我们的变量类型不只是 int 型了，还包括 int 型数组。因此，为了保证所有表达式中变量的类型均合法，需要进行类型检查。 在类型系统里我们给出了类型系统的形式化定义，同学们可以参考。 Python 框架 frontend/type/array.py 里实现了数组类型，同学们可以使用它完成实验，也可以自行对其进行修改。 C++ 框架 type/type.hpp 中的 ArrayType 表示数组类型，同学们可以使用它完成实验，也可以自行对其进行修改。 中间代码生成 数组和普通变量类似，可以分为局部数组和全局数组。 全局数组的处理与全局变量类似，由于是升级关卡，我们留给同学自行思考（和全局变量究竟有什么不同，是不是需要的内存空间更大？）。 局部数组我们给出一种参考实现，实际上不只有一种实现方法。参考实现中，我们定义了一条中间代码指令 ALLOC 用于分配内存： 指令 参数 含义 ALLOC size 分配 size 字节的内存，并返回内存首地址 依据参考实现的方法，测试样例可以被翻译为如下的中间代码（忽略全局数组部分）： main: T0 = ALLOC 40 # 一个 int 类型为 4 个字节 T1 = 0 return T1 通过这种方式，我们实际上是把内存分配的锅甩给了目标代码生成，这大大提升了目标代码生成的自由度，属于合理分锅。 我们还需要考虑如何访问数组元素。通过 ALLOC 指令我们得到了数组的首地址，那么任何一个数组元素的地址为在首地址的基础上加上偏移得到。于是读取数组元素可以使用 Step10 中引入的 LOAD 指令实现，我们还需要引入一条类似的 STORE 指令实现写入数组。 那么，如何将数组下标对应到地址偏移？对一维数组，下标和偏移只差一个常数倍（int 型的大小为 4 个字节）的区别。而对于高维数组，我们可以将之看作一个一维大数组。对于一个数组 a[d1][d2]...[dn]，访问 a[i1][i2]...[in] 就等价于访问 a[i1d2d3...dn + i2d3...*dn + ... + in]。在将数组索引翻译成 TAC 时，同学们需要自行将数组下标转换成地址计算指令。这个步骤并不困难，但可能比较繁琐，同学们实现时要注意各种细节。 目标代码生成 同中间代码生成，全局数组自行思考实现。 对于局部数组的内存分配，我们推荐在栈上为局部数组分配所需的空间，实际上，Step5 栈帧中局部变量区域，在我们的实验中就是为局部数组准备的。因此你要做的就是，模仿开辟栈帧的操作，对栈顶指针 sp 进行一定的修改，在栈上开辟出一块连续内存，并将这块内存的首地址返回即可。后续如有对数组中元素的访问，根据首地址进行偏移操作即可。 "},"docs/step11/typesystem.html":{"url":"docs/step11/typesystem.html","title":"类型系统","keywords":"","body":"类型系统 相信大家都了解过编程语言中类型的概念，数据的类型描述了数据的“含义”，描述了编译器和解释器会如何使用这份数据，比如在 C 语言中，下标运算只能应用于数组类型或指针类型。 C 编译器会检查下标运算所应用的表达式的类型，如果它不是数组类型或者指针类型，比如 int a; a[3];，C 编译器就会认为其无法被应用于下标运算，继而报出一个编译错误。 除了数据类型之外，人们同样也会讨论函数类型，但由于 MiniDecaf 几乎不支持任何函数式特性，简单起见，这里我们所讨论的类型仅包含数据类型。 将一种语言中的所有类型及对各种类型的所有使用规则形式化，严格地描述语言中如何为每个表达式指定类型，这就构成了类型系统。 类型系统包含若干条类型规则，每条规则描述了如何为一种表达式指定类型。 一条类型规则形如 p1⋯pme:t \\frac{p_1 \\qquad \\cdots \\qquad p_m}{e : t} ​e:t​​p​1​​⋯p​m​​​​ ，其中 e:te : te:t 指表达式 eee 的类型为 ttt，这条规则的含义（读法）为当横线上方的前提条件 p1⋯pmp_1 \\cdots p_mp​1​​⋯p​m​​ 都被满足时横线下方的结论成立。 注意，一个类型系统要求是一致的，可以简单理解为，没有两条规则的前提条件会被同时满足。 MiniDecaf 的类型系统将会在之后详尽列出。 基于类型系统，我们便可以通过自底向上地遍历 AST 来做类型检查，即对于一个表达式，尝试找到符合子表达式类型及运算的类型规则，通过找到的类型规则来推导出这个表达式的类型；如果没有符合的类型规则，则报出一个类型错误。 通过类型检查，编译器可以很好地减少程序中可能的 bug。 类型检查可以放在编译时（静态）或者运行时（动态）执行，或者在编译时和运行时都执行。 MiniDecaf 的类型系统 MiniDecaf 包含两种类型： int\\mathrm{int}int：一个 32 位整数； [int]n[\\mathrm{int}]^n[int]​n​​：一个 n (n≥1)n~(n \\ge 1)n (n≥1) 维数组，其元素类型为 int\\mathrm{int}int。 MiniDecaf 包含五条类型规则： e:int∙∈UN∙(e):int(T-un) \\frac {e : \\mathrm{int} \\qquad \\bullet \\in UN} {\\bullet (e) : \\mathrm{int}} \\text{(T-un)} ​∙(e):int​​e:int∙∈UN​​(T-un) 第一条规则是对一元运算的结果的指定规则，其中 UNUNUN 是 MiniDecaf 中所有的一元运算集合，∙(e)\\bullet(e)∙(e) 表示将 ∙\\bullet∙ 这个运算应用于 eee 上所得的结果。 直观来讲，即是说当一元运算的操作数是一个 int\\mathrm{int}int 时，该操作的结果也是一个 int\\mathrm{int}int。 e1:inte2:int∙∈BIN∙(e1,e2):int(T-bin) \\frac {e_1 : \\mathrm{int} \\qquad e_2 : \\mathrm{int} \\qquad \\bullet \\in BIN} {\\bullet (e_1, e_2) : \\mathrm{int}} \\text{(T-bin)} ​∙(e​1​​,e​2​​):int​​e​1​​:inte​2​​:int∙∈BIN​​(T-bin) 第二条规则是对二元运算的结果的指定规则，其中 BINBINBIN 是 MiniDecaf 中除了下标运算以外的所有的二元运算集合，∙(e1,e2)\\bullet(e_1, e_2)∙(e​1​​,e​2​​) 表示将 ∙\\bullet∙ 这个运算应用于 e1e_1e​1​​ 和 e2e_2e​2​​ 上所得的结果。 直观来讲，即是说当一个不是下标运算的二元运算的操作数都是一个 int\\mathrm{int}int 时，该操作的结果也是一个 int\\mathrm{int}int。 e1:inte2:inte3:int∙∈TERN∙(e1,e2,e3):int(T-tern) \\frac {e_1 : \\mathrm{int} \\qquad e_2 : \\mathrm{int} \\qquad e_3 : \\mathrm{int} \\qquad \\bullet \\in TERN} {\\bullet(e_1, e_2, e_3) : \\mathrm{int}} \\text{(T-tern)} ​∙(e​1​​,e​2​​,e​3​​):int​​e​1​​:inte​2​​:inte​3​​:int∙∈TERN​​(T-tern) 第三条规则是对三元运算的结果的指定规则，其中 BINBINBIN 是 MiniDecaf 中所有的三元运算集合，∙(e1,e2,e3)\\bullet(e_1, e_2, e_3)∙(e​1​​,e​2​​,e​3​​) 表示将 ∙\\bullet∙ 这个运算应用于 e1e_1e​1​​、e2e_2e​2​​ 和 e3e_3e​3​​ 上所得的结果。 直观来讲，即是说当一个三元运算的操作数都是一个 int\\mathrm{int}int 时，该操作的结果也是一个 int\\mathrm{int}int。 a:[int]ni:intn>1a[i]:[int]n−1(T-hda) \\frac {a : [\\mathrm{int}]^n \\qquad i : \\mathrm{int} \\qquad n > 1} {a[i] : [\\mathrm{int}]^{n-1}} \\text{(T-hda)} ​a[i]:[int]​n−1​​​​a:[int]​n​​i:intn>1​​(T-hda) 第四条规则是对高维数组（维数大于 1）的下标运算的结果的指定规则。 直观来讲，即是说当下标运算被应用于一个高维数组且下标为 int\\mathrm{int}int 时，其运算结果是一个比原数组低一维的数组。 a:[int]1i:inta[i]:int(T-oda) \\frac {a : [\\mathrm{int}]^1 \\qquad i : \\mathrm{int}} {a[i]: \\mathrm{int}} \\text{(T-oda)} ​a[i]:int​​a:[int]​1​​i:int​​(T-oda) 第五条规则是对一维数组的下标运算的结果的指定规则，其运算结果是一个整数。 直观来讲，即是说当下标运算被应用于一个一维数组且下标为 int\\mathrm{int}int 时，其运算结果是一个 int\\mathrm{int}int。 另外，对于仅包含单个变量或者函数调用的表达式 eee，我们有 e:inte : \\mathrm{int}e:int。 "},"docs/step11/spec.html":{"url":"docs/step11/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step11 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step11 语义规范 11.1 一个数组类型描述了一组被连续分配在一段内存空间中的对象，所有对象都具有相同的类型（我们称之为元素类型）。数组类型包含两部分：元素类型，和数组的长度（即元素数量）。数组类型的表达式仅能参与下标运算。 11.2 我们仅要求支持固定长度的数组，即在数组的声明中，其长度是一个正整数字面量。 所以，我们不要求支持变长数组 int a[n]; 或不定长数组 int a[];。 11.3 我们不要求支持数组的初始化。 C 中可以写 int a[2]={1, 2}，但简单起见，我们不做要求。 由于我们不要求数组的初始化，根据 5.5，作为局部变量的数组中的元素初始值未定；根据 10.3，作为全局变量的数组中的元素初始值为 0。 11.4 对于下标运算 a[b]，要求 a 是一个数组类型，b 是一个整数类型，a[b] 是 a 中的第 b 个元素（从 0 开始计数）。 11.5 下标运算越界是未定义行为。 即便是类似 int a[4][5]; a[1][7] 这种，同样也是未定义行为。 step11 类型系统 （更详尽的解释见类型系统一节） MiniDecaf 包含两种类型： int\\mathrm{int}int：一个 32 位整数； [int]n[\\mathrm{int}]^n[int]​n​​：一个 n (n≥1)n~(n \\ge 1)n (n≥1) 维数组，其元素类型为 int\\mathrm{int}int。 MiniDecaf 包含五条类型规则： e:int∙∈UN∙(e):int(T-un) \\frac {e : \\mathrm{int} \\qquad \\bullet \\in UN} {\\bullet (e) : \\mathrm{int}} \\text{(T-un)} ​∙(e):int​​e:int∙∈UN​​(T-un) e1:inte2:int∙∈BIN∙(e1,e2):int(T-bin) \\frac {e_1 : \\mathrm{int} \\qquad e_2 : \\mathrm{int} \\qquad \\bullet \\in BIN} {\\bullet (e_1, e_2) : \\mathrm{int}} \\text{(T-bin)} ​∙(e​1​​,e​2​​):int​​e​1​​:inte​2​​:int∙∈BIN​​(T-bin) e1:inte2:inte3:int∙∈TERN∙(e1,e2,e3):int(T-tern) \\frac {e_1 : \\mathrm{int} \\qquad e_2 : \\mathrm{int} \\qquad e_3 : \\mathrm{int} \\qquad \\bullet \\in TERN} {\\bullet(e_1, e_2, e_3) : \\mathrm{int}} \\text{(T-tern)} ​∙(e​1​​,e​2​​,e​3​​):int​​e​1​​:inte​2​​:inte​3​​:int∙∈TERN​​(T-tern) a:[int]ni:intn>1a[i]:[int]n−1(T-hda) \\frac {a : [\\mathrm{int}]^n \\qquad i : \\mathrm{int} \\qquad n > 1} {a[i] : [\\mathrm{int}]^{n-1}} \\text{(T-hda)} ​a[i]:[int]​n−1​​​​a:[int]​n​​i:intn>1​​(T-hda) a:[int]1i:inta[i]:int(T-oda) \\frac {a : [\\mathrm{int}]^1 \\qquad i : \\mathrm{int}} {a[i]: \\mathrm{int}} \\text{(T-oda)} ​a[i]:int​​a:[int]​1​​i:int​​(T-oda) "},"REFERENCE.html":{"url":"REFERENCE.html","title":"参考资料","keywords":"","body":"参考资料 Writing a C Compiler: by Nora Sandler An Incremental Approach to Compiler Construction : by Abdulaziz Ghuloum Monkey: The programming language that lives in books C17 标准草案 N2176（N2176 是 C17 标准正式发布前的最后一版草案，根据 C17 标准的编者之一 Jens Gustedt 的博文，其与 C17 标准相比只有表述上的差异） RISC-V 手册 RISC-V（非官方）汇编指令用法 "}}
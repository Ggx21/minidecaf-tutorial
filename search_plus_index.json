{"./":{"url":"./","title":"实验简介","keywords":"","body":"MiniDecaf 编译实验 实验概述 MiniDecaf 1 是一个 C 的子集，去掉了如 include/define/多文件/struct 等特性。 这学期的编译实验要求同学通过多次“思考-实现-重新设计”的过程，一步一步实现从简单到复杂的 Minidecaf 语言的完整编译器， 能够把 MiniDecaf 代码编译到 RISC-V 汇编。 从而能够理解并解决编译真实的程序设计语言时遇到的问题，并能与编译的原理进行对照。 下面是 MiniDecaf 的快速排序，和 C 是一样的 int qsort(int *a, int l, int r) { int i = l; int j = r; int p = a[(l+r)/2]; while (i p) j = j - 1; if (i > j) break; int u = a[i]; a[i] = a[j]; a[j] = u; i = i + 1; j = j - 1; } if (i l) qsort(a, l, j); return 0; } 如目录所示，MiniDecaf 实验分为六大阶段，由十二个小步骤组成。 每个步骤，你的任务都是把 MiniDecaf 程序编译到 RISC-V 汇编，并能在QEMU硬件模拟器上运行。 每步做完以后，你都有一个完整能运行的编译器。 随着实验一步一步进行，MiniDecaf 语言会从简单变复杂，每步都会增加部分的语言特性。 实验的关键目标是理解和掌握编译器的设计与实现方法，并能与编译原理课程的知识互补与相互印证。 我们提供一系列的参考实现，包含 Python/Rust/Java/C++ 的。 同学遇到困难可以分析了解参考实现、也可以复用他们的代码。不论同学采用那种方式，都希望能达到实验目标。 编译器边边角角的情况很多，所以你的实现只要通过我们的测例就视为正确。 实验提交 你需要使用 git 对你的实验做版本维护，然后提交到 git.tsinghua.edu.cn。 大家在网络学堂提交帐号名后，助教给每个人会建立一个私有的仓库，作业提交到那个仓库即可。 关于 git 使用，大家也可以在网上查找资料。 每次除了实验代码，你还需要提交 实验报告，其中包括 指导书里面思考题的回答 声明你参考以及复用了谁的代码 晚交扣分规则 是： 晚交 n 天，则扣除 n/15 的分数，扣完为止。例如，晚交三天，那你得分就要折算 80%。 备注 1. 关于名字由来，往年实验叫 Decaf，所以今年就叫 MiniDecaf 了。不过事实上现在的 MiniDecaf 和原来的 Decaf 没有任何关系。 ↩ "},"docs/log.html":{"url":"docs/log.html","title":"更新日志","keywords":"","body":"更新日志 2020.08.29：讨论准备实验帮助文档的改进，开始进行实验帮助文档v0.2 2020.08.26：完成实验帮助文档v0.1，进行文档review 2020.08.19：讨论准备实验帮助文档和分工 2020.08.15：各位助教基于不同的编程语言进一步完善改进基于v2的step1-12 2020.08.05：大致确定实验方案，确定目标语言的语法规范v2，设计基于v2的step1-12 2020.08.01：开始进行基于目标语言的语法规范v1的step，部分助教基于不同编程语言完成基于v1的step1~15的大部分 2020.07.29：大致确定实验方案，不限定实现编译器的编程语言和词法/语法解析方法，确定目标语言的语法规范v1，设计基于v1的step1-15，设定汇编语言 2020.07.20：minidecaf实验准备，方案设计 "},"docs/lab0/env.html":{"url":"docs/lab0/env.html","title":"环境配置","keywords":"","body":"环境配置 必做：RISC-V 的 gcc 和 qemu 我们的编译器只生成 RISC-V 汇编，然后再使用 gcc 把 RISC-V 汇编变成 RISC-V 可执行文件，最后用 qemu 等模拟器来运行 RISC-V 可执行文件。 这里的 gcc 和常说的 gcc 不一样。 常说的 gcc 运行在我们的 x86 机器上、把 C 编译到 x86 可执行文件； 而这里的 gcc 虽然也运行在我们的 x86 机器上，却要编译到 RISC-V 可执行文件。 这种“gcc 跑在 x86 却编译出 RISC-V 代码”的操作被称为交叉编译（cross compilation）。 因此我们不能直接使用有些系统自带的 gcc，这种 gcc 生成的可执行程序只能在你本机（x86）上运行。 我们需要下载安装 riscv64-unknown-elf-gcc，用来生成 RISC-V 可执行程序。 我们提供了预编译的 riscv64-unknown-elf-gcc 和 qemu 模拟器，不过只能在 Linux/Mac 下运行，Windows 的同学可以使用 WSL，或者运行一个虚拟机。 命令行基础操作我们就不赘述了，大家可以自己在网上查找资料。 下面是环境配置指南，请阅读自己的系统的那一小节。 你的编译器 gcc qemu MiniDecaf 源文件 ------------> RISC-V 汇编 -----> 可执行文件 --------> 输出 Windows 用户环境配置指南 下面描述了 WSL 的一种参考方法。 你还可以开一个 Linux 虚拟机，使用 Virtualbox 或 VMWare 等，然后参考下面 Linux 配置。 Win10 设置 参考 https://blog.csdn.net/daybreak222/article/details/87968078 ，设置“开发者模式”以及“启用子系统功能”。 打开Microsoft Store，搜索Ubuntu，选择ubuntu20.04. 更新源： sudo vi /etc/apt/sources.list，并在文件最前面加入 # 默认注释了源码镜像以提高 apt update 速度，如有需要可自行取消注释 deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-updates main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-backports main restricted universe multiverse deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-security main restricted universe multiverse # 预发布软件源，不建议启用 # deb https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse # deb-src https://mirrors.tuna.tsinghua.edu.cn/ubuntu/ focal-proposed main restricted universe multiverse 然后执行命令： $ sudo apt-get update $ sudo apt-get upgrade 安装qemu，执行命令： sudo apt-get install qemu-user 安装riscv64-gcc： 下载已编译的安装包 https://static.dev.sifive.com/dev-tools/riscv64-unknown-elf-gcc-8.3.0-2020.04.0-x86_64-linux-ubuntu14.tar.gz 。把安装包解压，根据解压路径把 riscv64-unknown-elf-gcc-8.3.0-2020.04.0-x86_64-linux-ubuntu14\\bin 加入 PATH 环境变量，配置结束。 Linux 用户环境配置指南 从网络学堂下载 riscv-prebuilt.tar.gz 压缩包并解压（命令是 tar xzf riscv-prebuilt.tar.gz） 安装工具链 cp riscv-prebuilt/* /usr/ -r 在第 2. 步，你可以选择不安装到系统目录下。相应的，你需要设置环境变量： export PATH=$PATH:/path/to/riscv-prebuilt/bin，把 /path/to 替换为你的解压目录。 把上面这条命令加到你的 ~/.bashrc 文件中，这样不用每次打开终端都要重新设置。 每次改完 ~/.bashrc 你都需要重启终端，以便改动生效。 （如果你不用系统自带的 bash 而是用 zsh 之类的 shell，那加到 ~/.zshrc 等 shell 配置文件里） macOS 用户环境配置指南 从这里下载预编译好的 RISC-V 工具链并解压到你喜欢的目录。 由于 macOS 不支持 QEMU 的用户态模式，我们使用 Spike 模拟器和一个简易内核 riscv-pk 提供用户态程序的运行环境。网络学堂上提供了我们预编译的二进制程序包 spike-pk-prebuilt-x86_64-apple-darwin.tar.gz。你也可以使用 Homebrew 安装 Spike：$ brew tap riscv/riscv $ brew install riscv-isa-sim Homebrew 也提供了 riscv-pk，不过那是 64 位的，而我们需要 32 位的，请使用我们预编译的 riscv-pk 或自行编译。 （可选）设置环境变量，方法与 Linux 一样，见上一节。如果不设置每次使用 gcc 和 spike 时都要输入完整路径。不过对于 pk 设置环境变量不管用，要么把它放到系统目录 /usr/local/bin/pk，要么每次都用完整路径。 测试你 GCC 和 Spike 是否成功安装，详见RISC-V 的工具链使用。 必做：测试你是否正确配置好了环境 创建 test.c 文件，其中写入如下内容 #include int main() { printf(\"Hello world!\\n\"); } 编译 test.c 文件，gcc 应该输出一个可执行文件 a.out。但 a.out 是 RISC-V 可执行文件，所以我们的 X86 计算机无法运行。 $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 test.c $ ls a.out a.out $ ./a.out bash: ./a.out: cannot execute binary file: Exec format error 后面RISC-V 的工具链使用总结了 gcc 和 qemu 在编译实验中可能需要的用法。 使用 qemu 执行 a.out$ qemu-riscv32 a.out Hello world! 备注 1. 开头的 $ 表示接下来是一条命令，记得运行的时候去掉 $。例如，让你运行 $ echo x，那你最终敲到终端里的是 echo x（然后回车）。如果开头没有 $，那么这一行是上一条命令的输出（除非我们特别说明，这一行是你要输入的内容）。 ↩ "},"docs/lab0/testing.html":{"url":"docs/lab0/testing.html","title":"运行测试样例","keywords":"","body":"推荐：运行一个参考实现 配好环境以后，我们强烈推荐你选择一个参考实现先测试运行一下（见下一节）。 接下来我们会用到 git。 git 的安装和使用会在今年软件工程课上讲述，同学们也自行查阅相关资料，也可以参考这里 。 每一个参考实现都是一个 git 分支，且都以 commit 的形式提供了每一个 step 的参考实现。 同学们可以通过 git log 查看提交历史，通过 git checkout 查看每一个 step 的参考实现，或者通过 git diff 对比两个 step 之间的差异。 通过 git clone 把测例和某个参考实现克隆到同一个目录下面。 按照参考实现的 README 配置好它的环境。 按照测例的 README 运行测试 测试运行的 输出结果 大致如下。 $ ./check.sh gcc found qemu found parallel found OK testcases/step1/multi_digit.c OK testcases/step1/newlines.c ...... 其他测试点，太长省略 "},"docs/lab0/faq.html":{"url":"docs/lab0/faq.html","title":"常见问题","keywords":"","body":"常见问题 Invalid ELF image for this architecture $ qemu-riscv32 a.out a.out: Invalid ELF image for this architecture 注意编译时 gcc 要用 riscv64-unknown-elf-gcc、并且加上 -march=rv32im -mabi=ilp32。 command not found $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c riscv64-unknown-elf-gcc: command not found 或者运行 qemu-riscv32 时提示上面的错误。 你是否按照环境配置中指南配好环境？ 如果你没有安装到系统目录，是否设置 PATH，并且把 export PATH... 命令放到 ~/.bashrc？ 安装 ANTLR 提示 Permission denied $ wget https://www.antlr.org/download/antlr-4.8-complete.jar --2020-09-13 16:33:34-- https://www.antlr.org/download/antlr-4.8-complete.jar Resolving www.antlr.org (www.antlr.org)... 185.199.111.153, 185.199.109.153, 185.199.108.153, ... Connecting to www.antlr.org (www.antlr.org)|185.199.111.153|:443... connected. HTTP request sent, awaiting response... 200 OK Length: 2089101 (2.0M) [application/java-archive] antlr-4.8-complete.jar: Permission denied Cannot write to ‘antlr-4.8-complete.jar’ (Success). 运行 sudo wget https://www.antlr.org/download/antlr-4.8-complete.jar。 Spike pk 卡死 执行 spike pk 直接卡死，需要按多次 Ctrl-C 后才能退出。 可能是忘加了 --isa=RV32G 选项，在用 64 位的 Spike 跑 32 位 pk。 如果你加了该选项也有这个问题，可能是你安装了 64 位的 pk 然后再用 32 位的 Spike 跑，请使用我们预编译的 32 位 pk。 Spike 运行报错 $ spike --isa=RV32G pk libc++abi.dylib: terminating with uncaught exception of type std::runtime_error: could not open pk (did you misspell it? If VCS, did you forget +permissive/+permissive-off?) Spike 找不到 pk，请输入 pk 的完整路径。 "},"docs/lab0/riscv.html":{"url":"docs/lab0/riscv.html","title":"RISC-V 的工具链使用","keywords":"","body":"RISC-V 相关信息 RISC-V 是一个很像 MIPS 的 RISC 指令集架构，编译实验要求你的编译器把 MiniDecaf 程序编译到 RISC-V 汇编。 指令集文档在这里，我们只需要其中的 \"Unprivileged Spec\"。 另外这里也有（非官方的）指令用法说明。 不过事实上，很多时候看 gcc 输出的汇编比看什么文档都有用。 RISC-V 工具使用 我们提供预先编译好的 RISC-V 工具，在环境配置中已经叙述了安装和使用方法。 下面汇总一下。 注意，我们虽然是用的工具前缀是 riscv64， 但我们加上参数 -march=rv32im -mabi=ilp32 以后就能编译到 32 位汇编 1。 使用时记得加这个参数，否则默认编译到 64 位汇编。 我们假设你已经正确设置好了环境变量，否则运行 riscv64-unknown-elf-gcc 或 qemu-riscv32 或 spike 时请用完整路径。 gcc 编译 input.c 到汇编 input.s，最高优化等级（否则输出的汇编会很冗长） # input.c 的内容 $ cat input.c int main(){return 233;} # 编译到 input.s $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 -O3 -S input.c # gcc 的编译结果 $ cat input.s .file \"input.c\" .option nopic .attribute arch, \"rv32i2p0_m2p0\" .attribute unaligned_access, 0 .attribute stack_align, 16 .text .section .text.startup,\"ax\",@progbits .align 2 .globl main .type main, @function main: li a0,233 ret .size main, .-main .ident \"GCC: (SiFive GCC 8.3.0-2020.04.0) 8.3.0\" gcc 编译 input.s 到可执行文件 a.out # input.s 的内容，就是上面汇编输出的简化版本 $ cat input.s .text .globl main main: li a0,233 ret # 编译到 a.out $ riscv64-unknown-elf-gcc -march=rv32im -mabi=ilp32 input.s # 输出结果，能看到是 32 位的 RISC-V 可执行文件 $ file a.out a.out: ELF 32-bit LSB executable, UCB RISC-V, version 1 (SYSV), statically linked, not stripped 【Linux 用户】qemu 运行 a.out，获取返回码 # 运行 a.out $ qemu-riscv32 a.out # $? 是 qemu 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 【macOS 用户】Spike 模拟器运行 a.out，获取返回码 # 运行 a.out $ spike --isa=RV32G /usr/local/bin/pk a.out # /usr/local/bin/pk 替换为你自己的 pk 路径 bbl loader # $? 是 spike 的返回码，也就是我们 main 所 return 的那个值 $ echo $? 233 1. 这里的 rv32im 表示使用 RV32I 基本指令集，并包含 M 扩展（乘除法）。本实验中我们不需要其他扩展。 ↩ "},"docs/ref/intro.html":{"url":"docs/ref/intro.html","title":"说明","keywords":"","body":"说明 我们提供了一系列完整的 step1~step12 的参考实现，分别使用了不同的编程语言或词法语法分析工具，如下所示： 参考实现仅供参考，不是标准答案！ Python-ANTLR 地址 https://github.com/decaf-lang/minidecaf/tree/md-dzy clone 命令：git clone https://github.com/decaf-lang/minidecaf.git -b md-dzy 演示网址：https://hoblovski.github.io/minidecaf-web/ 请耐心加载，可能要一分钟，加载好以后第一次编译要十秒，之后就快了 因为要动态把 py 翻译成 js 然后执行，三重的缓慢 Rust-lalr1 地址 https://github.com/decaf-lang/minidecaf/tree/mashplant clone 命令：git clone https://github.com/decaf-lang/minidecaf.git -b mashplant 演示网址：https://mashplant.online/minidecaf-frontend/ 除了加载可能因为网络原因稍慢，之后的运行都非常快。原理是Rust编译到WASM在网页中执行，感兴趣的同学可以自行了解 Rust-manual 地址 https://github.com/decaf-lang/minidecaf/tree/md-cy clone 命令：git clone https://github.com/decaf-lang/minidecaf.git -b md-cy TypeScript-ANTLR 地址 https://github.com/equation314/minidecaf clone 命令：git clone https://github.com/equation314/minidecaf.git --recursive 演示网址：https://equation314.github.io/minidecaf Java-ANTLR 地址 https://github.com/decaf-lang/minidecaf/tree/md-xxy clone 命令：git clone https://github.com/decaf-lang/minidecaf.git -b md-xxy C++-ANTLR 地址 https://github.com/decaf-lang/minidecaf/tree/md-zj clone 命令：git clone https://github.com/decaf-lang/minidecaf.git -b md-zj C++-manual 地址 https://github.com/decaf-lang/minidecaf/tree/md-zyr clone 命令：git clone https://github.com/decaf-lang/minidecaf.git -b md-zyr "},"docs/ref/typescript-jyk.html":{"url":"docs/ref/typescript-jyk.html","title":"TypeScript-ANTLR","keywords":"","body":"TypeScript-ANTLR 地址 https://github.com/equation314/minidecaf 演示网址：https://equation314.github.io/minidecaf 概述 本参考实现基于 TypeScript 语言，使用 ANTLR 工具进行语法分析。可以直接转换为 JavaScript，原生支持在浏览器上运行。 本参考实现具有以下特点： 基于 ANTLR 的词法语法分析。使用了 ANTLR 工具进行词法和语法分析，详见 ANTLR 使用。 网页版编译器。通过将 TypeScript 翻译到 JavaScript，可直接在浏览器中运行 MiniDecaf 编译器，生成 RISC-V 汇编。 在浏览器上运行源程序。本参考代码基于对生成的中间表示的模拟执行，实现了一个解释器，能够在网页上直接运行源程序，并得到执行结果（main 函数返回值），无需再用 QEMU 等模拟器运行。 此外，与其他参考代码一样，本参考代码完成每个 step 的过程，都被分成了一个或多个 git commit，你可以使用 git diff 得到相邻两次 commit 的差异，来明确每一步需要完成哪些工作。每一个 step 的最后一个 commit 都被打上了 tag，并都能通过部署在 Github Actions 上的自动测试。 特别注意：实现网页版编译器和解释器不是本实验的必做内容。 TypeScript 是什么？ TypeScript 是 JavaScript 的超集（类似于 C++ 是 C 的超集），顾名思义就是加了类型的 JavaScript。除了类型系统外，还增加了接口、枚举、泛型等众多新特性，比 JavaScript 更加面向对象，更加容易编写，更能发现潜在的错误，更适合开发大型应用。 TypeScript 可以被直接翻译到 JavaScript，因此不仅能使用 Node.js 在命令行里运行，还支持在浏览器里运行。本参考代码就是通过这种方式，先用更加友好的 TypeScript 进行开发，再转成 JavaScript，实现了能在浏览器里运行的编译器。 由于 TypeScript 对 JavaScript 的兼容性，你也可以直接用 JavaScript 语言进行开发。 要不要选择用 TypeScript 写编译器？ 如果你已经会了 TypeScript 语言，或对 Web 开发感兴趣，或想要一个自己亲手制作的炫酷的网页版编译器，强烈建议使用 TypeScript 语言进行实验。如果你只是会 JavaScript，那么上手 TypeScript 是很容易的，当然你也可以直接用 JavaScript 进行开发。如果两者都不熟悉也没关系，作为脚本语言，它们都非常简单易学。 关于 TypeScript 的入门教程与文档，详见： 官方入门教程：https://www.typescriptlang.org/docs/handbook/typescript-tooling-in-5-minutes.html 官方手册：https://www.typescriptlang.org/docs/handbook/intro.html 中文版教程与手册：https://www.tslang.cn/docs/home.html 环境配置 下面给出了此版本参考代码的环境配置、构建与运行、以及测试的方法。 安装 Node.js 去官网下载并安装 Node.js（同时包含了包管理器 npm），建议使用 12 以上的版本。 安装依赖 进入参考代码目录，先运行以下命令一键安装依赖： npm install 运行完后当前目录中会多出一个 node_modules 文件夹，里边包含了开发所需的各种所需的软件包和运行库，例如 TypeScript 编译器 tsc、ANTLR 工具等等。 你无需再像step1：词法语法分析工具那里一样下载 ANTLR 的 JAR 包。 命令行运行 npm run grammar # 生成 ANTLR 语法分析器 npm run build # 将 TypeScript 编译成 JavaScript npm run cli test/test.c -- -s # 使用 node 运行生成的 JS 代码，编译 test/test.c 并生成汇编码 即可看到对测试文件编译后生成的 RISC-V 汇编码。上面第三条命令后面的是编译选项，-s 表示生成汇编码，不加 -s 就会直接运行并输出 main 函数的返回值。运行 npm run cli -- -h 查看更多编译选项。 测试 测试单个文件（即 test/test.c），得到它的运行结果（main 函数返回值）： npm run test # 作为解释器运行 # 或 `npm run test-codegen`，会先生成 RISC-V 汇编码，再在模拟器(QEMU 或 Spike)中运行。 运行我们提供的所有测例： npm run test-all -- -n 12 # 作为解释器运行 # 或 `npm run test-all -- -s -n 12`，会先生成 RISC-V 汇编码，再在模拟器(QEMU 或 Spike)中运行。 这里 -n 表示只运行 step1 到 stepN 的测例。 请确保你在 clone 仓库时加了 --recursive 选项，将测例仓库也一起 clone 了下来。 如果加了 -s 选项，会自动调用 minidecaf-tests/check.sh 运行测试。但该脚本不支持测试解释器，只好写在 test/test_all.sh 中。 【可选】网页版编译器 npm run build-web # 将 TS 编译成 JS，然后将所有 JS 文件打包以便在网页上调用 npm run serve # 启动简易的 HTTP 静态服务器 在浏览器中打开网址 http://127.0.0.1:8080 即可看到，效果与 https://equation314.github.io/minidecaf 一样。在左上角输入 MiniDecaf 源代码，点击“Run”即可编译，左下角会得到运行结果，右上角和右下角分别是生成的中间表示与 RISC-V 汇编码。 实验框架 如果你打算使用 TypeScript/JavaScript 语言完成本实验，实现网页版编译器，我们提供了一个实验框架。该框架已经帮你完成了 TypeScript 项目配置、网页前端开发、自动测试和部署等与实验无关的内容，你只需集中精力完成实验部分，填入你自己的编译器的实现，即可得到一个你自己的网页版编译器。 快速入门 在 clone 整个仓库后，切换到 skeleton 分支，即可开始实验。 git clone https://github.com/equation314/minidecaf.git --recursive git checkout skeleton 实验框架已经进行了基本的项目配置，你可直接运行与上一节“环境配置”中类似的命令： npm install # 安装依赖 npm run build # 将 TS 转 JS npm run cli test/test.c -- -s # 运行 JS 代码，生成汇编 # 测试 npm run test-codegen # 对 test/test.c 生成汇编，并在模拟器中运行 npm run test-all -- -s [-n ] # 运行 step1 到 step 的全部测例 #【可选】构建网站 npm run build-web # 将 TS 编译成 JS 并打包 npm run serve # 启动简易的 HTTP 静态服务器 框架中没有实现 npm run grammar 命令，这与你的语法分析器的实现方式有关。如果你也使用一些工具进行语法分析器的生成，可以在 package.json 中添加类似的命令。例如要安装和使用 TypeScript 版的 ANTLR，详见参考代码或 https://github.com/tunnelvisionlabs/antlr4ts 。 运行完后，只会输出一行 nop。这是因为框架中的编译函数就是这么写的： export function compile(input: string, option: CompilerOption): string { if (option.target === CompilerTarget.Riscv32Asm) { return \"nop\"; } else if (option.target === CompilerTarget.Executed) { return \"0\"; } } 本实验无需实现解释器，你只需要处理 option.target === CompilerTarget.Riscv32Asm 的情况即可。 本函数就是你在实验中需要完成的部分。在每一个 step 中，你都需要让该函数返回正确的 RISC-V 汇编。你可以随意增加文件，不过不建议对除 src/minidecaf.ts 以外的文件做修改。 为了让部署在 git.tsinghua.edu.cn 中的 CI 能自动测试你的代码，请确保对给定源文件生成汇编的命令为以下格式： npm run cli -- -s -o 如果你不使用我们提供的框架，请自行在 package.json 的 scripts 字段中添加 cli 字段，并填好运行你的 JS/TS 编译器的命令。此外你的编译器至少需要支持 -s 和 -o 选项。如果不想自己折腾建议直接使用我们的框架。 【可选】自动测试与部署 如果你使用 Github 进行代码托管，可使用 Github Actions 搭建 CI(continuous integration)，进行自动测试与网站的自动部署。我们已经提供了 workflow 文件，每次 push 任何分支都会使用 test.yml 中的配置，自动构建并跑我们的测试用例；每次 push master 都会创建 GitHub Pages，部署网页版编译器。 test.yml 中也包含了如何在一个干净的系统中配置实验环境的命令，如安装 RISC-V 工具链、安装 QEMU 等，可以作为配置环境时的参考。 与实验总指导的差异 本节列出了本参考实现与实验总指导的几处主要不同，能够帮你更好地理解这份参考代码。参考代码中也提供了详细的注释帮助你理解。你在做实验时应该主要关注实验总指导，无需和这里的实现一样。另外本节内容涉及多个 step 中的细节，建议根据你目前所做的 step 选择性查阅相关内容。 整体架构 参考代码中编译器的整体流程如下： 源代码经过 ANTLR 词法和语法分析器，生成 ANTLR 分析树； 使用 ANTLR visitor 模式对分析树进行名称解析、类型检查等语义检查，并在节点上标记一些属性； 使用 ANTLR visitor 模式对分析树生成中间表示； 将中间表示转换为 RISC-V 汇编，之后用 GCC 生成可执行文件，并在 QEMU/Spike 上运行； 【可选】用解释器模拟中间代码的执行，直接得到结果。 以下是参考代码的目录结构： src/ ├── grammar/ # 语法 │ ├── Lexer.g4 # ANTLR 词法规则 │ └── MiniDecaf.g4 # ANTLR 语法规则 ├── target/ # 编译目标 │ ├── executor.ts # IR 解释执行器 │ └── riscv.ts # IR 到 RISC-V 的代码生成 ├── visitor/ # ANTLR visitors │ ├── irgen.ts # IR 生成器 │ └── semantic.ts # 语义检查 ├── cli.ts # 命令行工具 ├── error.ts # 定义了各类错误 ├── ir.ts # 中间表示 ├── minidecaf.ts # 编译器主入口 ├── scope.ts # 作用域 └── type.ts # 类型系统 语法树（所有 step） 本参考实现没有真正构建出抽象语法树，而是直接使用了 ANTLR 自动生成的分析树。 在第一次遍历分析树时（详见 src/target/semantic.ts），会给分析树增加一些额外的属性，以便之后的分析。使用 JavaScript 的语法可以方便地给任何 object 增加属性，例如： visitType(ctx: MiniDecafParser.TypeContext): Result { if (ctx.Int()) { ctx[\"ty\"] = BaseType.Int; } else { ctx[\"ty\"] = new PointerType(ctx.type().accept(this)[\"ty\"]); } return ctx; } 其中属性 ty 表示节点的类型。其他重要的属性还有： 属性名 含义 ty 类型（表达式） lvalue 是否是左值（表达式） paramCount 参数个数（函数） localVarSize 局部变量所占内存大小（函数） variable 对应的变量（标识符） loop 对应的循环语句（break、continue 语句） 中间表示（所有 step） 为了方便直接在浏览器上执行源程序并得到结果，本参考代码也使用了中间表示，并实现了对中间代码的模拟执行。不过与 step1 中讲的 IR 简明介绍这一节有所不同，这里的 IR 不只是一个简单的栈结构，还包含了两个寄存器。 如果你不打算实现解释器，可不使用中间代码，直接从 AST 生成汇编。 在 IR 简明介绍和之后的 step2、step3 中，我们介绍了如何使用基于栈的 IR 来表示一元和二元运算。例如，要计算表达式 1 + (-2)，IR 如下： PUSH 1 # 把 1 压入栈顶 PUSH 2 # 把 2 压入栈顶 NEG # 从栈顶弹出一个元素，对其取相反数，再压入栈顶 ADD # 从栈顶弹出两个元素，计算它们的和，再压入栈顶 直接转换成 RISC-V 汇编码，将会是： # PUSH 1 addi sp, sp, -4 li t1, 1 sw t1, 0(sp) # PUSH 2 addi sp, sp, -4 li t1, 2 sw t1, 0(sp) # NEG lw t1 0(sp) neg t1, t1 sw t1, 0(sp) # ADD lw t1, 4(sp) lw t2, 0(sp) add t1, t1, t2 addi sp, sp, 4 sw t1, 0(sp) 可以发现，这种 IR 的一个缺点是压栈、弹栈操作太多。最终生成的汇编代码有 16 条指令，其中真正用于计算的指令才 2 条（neg 和 add），而剩下的 14 条都是与计算结果无关的栈操作，运行效率可想而知。 本参考实现中对以上 IR 做了一个简单优化，即引入了两个寄存器 r0 和 r1，上一步的计算结果默认存在 r0 中而不是栈顶。这样尽可能使用寄存器而不是栈来保存中间结果，使得 IR 更加接近于机器代码，执行效率更高。例如，使用该 IR 计算表达式 1 + (-2) 如下： IMM 1, r0 # r0 = 1 PUSH r0 # 把 r0 压入栈顶 IMM 2, r0 # r0 = 2 NEG r0 # r0 = -r0 POP r1 # 从栈顶弹出一个元素，存到 r1 ADD r1, r0 # r0 = r1 + r0 转换成 RISC-V 汇编码如下： # IMM 1, r0 li t0, 1 # PUSH r0 addi sp, sp, -4 sw t0, 0(sp) # IMM 2, r0 li t0, 2 # NEG r0 neg t0, t0 # POP r1 lw t1, 0(sp) addi sp, sp, 4 # ADD r1, r0 addi t0, t1, t0 共 8 条指令，比之前的减少了一半。 此外，本参考实现中的 IR 指令不隐式包含栈操作，只有 PUSH、POP 指令可以进行压栈、弹栈（还有 CALL 指令在函数调用结束后会从栈中弹出参数个数个元素），而不像之前的 IR 中，执行一条二元运算指令也意味着栈中要减少一个元素， 完整 IR 的指令表详见 src/ir.ts。 调用约定（step9） 本参考实现遵循了 step9 中描述的 GCC 的调用约定： caller-save 和 callee-save 寄存器在 \"Unprivileged Spec\" 的 109 页。 返回值（32 位 int）放在 a0 寄存器中。 参数（32 位 int）从左到右放在 a0、a1……a7 中。如果还有，则从右往左压栈，第 9 个参数在栈顶。 具体地，在 commit 6965523 及之前使用的是 step9 中描述的简化版调用约定，在 commit fd5bccc 更改为了 GCC 的调用约定。如果你也想使用 GCC 的调用约定，可以参考 commit fd5bccc 中的实现过程，否则参考 commit 6965523 即可。 实现过程也非常简单粗暴，效率上反而还不如简化版的，只是为了能够调用 GCC 编译的函数。具体做法为：当所有参数从右往左压栈后，从栈中弹出至多 8 个参数，分别存到 a0、a1……a7 中；由于参数寄存器属于临时寄存器，会在嵌套函数调用中被破坏，需要被保存，就在 callee 的 prologue 阶段再将它们保存到 callee 的栈帧上。 参数寄存器和局部变量如何在栈帧中布局不是调用约定的内容，可以自己任意定义，不需要遵循 GCC 的。 为了方便理解，下图给出了本参考实现中的栈帧布局： 【可选】解释器（所有 step） 本小节内容是可选的，如果想实现在浏览器中运行源程序，可阅读本小节以供参考。 本参考代码实现了对中间代码的模拟执行（详见 src/target/executor.ts）。与 IR 的定义一样，解释器实现了对 IR 栈和两个寄存器的模拟。不过为了实现全局变量，还需有另一块内存来放置全局变量。为了方便 step11 实现的取地址操作，参考代码中把这两块内存进行了合并，并使用一个地址 STACK_OFFSET 加以区分，该地址以下是栈空间，该地址以上是全局数据的空间。因此还需要有个 sp 寄存器来表示栈顶地址。 此外，与真实机器以字节为单位的内存不同，模拟的内存就是一个 JavaScript 的数组，其中的元素可以是任意类型，参考代码中使用它来存放数据、地址、函数名等各种东西。而内存地址还是与真实机器的一样 4 个字节对齐，因此在通过地址访问内存数组中的元素时，需要把地址除以 4。 参考代码中的 Ir 类由一堆 IrFunc 和 IrGlobalData 组成，分别表示一个函数与一个全局变量。而一个 IrFunc 又由一堆 IrInstr 组成，即 IR 的指令。在模拟 IR 执行的过程中，有两个全局的数据 currentFunc 和 pc，分别表示当前所在的 IrFunc 和当前所处理的是其中的哪一条 IR 指令。一般情况下，每遇到一条指令，就会让 pc 加 1；如果是跳转指令，就让 pc 设为要跳转的标签的位置；如果是 CALL 指令，就更新 currentFunc 为被调用者，更新 pc 为 0。 对于函数调用，需要模拟出栈帧的结构，因此需要有一个栈帧寄存器 fp，之后对局部变量或参数的引用都是基于 fp 的。和生成目标代码一样，一条 IR 指令可能需要完成多步操作。例如 CALL 指令需要向栈中压入旧的 currentFunc、pc 和 fp，并更新它们；RET 指令需要从栈中恢复它们。对于传参，不需要考虑用寄存器传参，都用栈存放参数即可。 "},"docs/ref/python-dzy.html":{"url":"docs/ref/python-dzy.html","title":"Python-ANTLR","keywords":"","body":"Python-ANTLR 这个文档用来介绍 Python-ANTLR，以及解释它的实现和指导书的不同。 概述 Python-ANTLR 参考实现使用 python 语言（python >= 3.6），使用 ANTLR 工具进行词法语法分析。 网页版使用 brython 动态翻译 python 到 javascript 执行。 如果你要看 Python-ANTLR，至少你要会 python 3，要会写 python 的 class，看得懂 [a+1 for a in l] 等等。 Python-ANTLR 的特点，以及一些注意事项是 用 ANTLR 做语法词法分析，所以词法语法分析很简单。 真·多遍，词法语法分析、名称解析（step7）、类型检查（step11）、IR 生成、汇编生成几个过程都是独立的。 前面的几个 step 是 64 位的，在 commit: 49aecac 中修正， 并且前面 step 也有 bug 到后面才被修正。 因此代码 仅供参考 ，如果你直接切到前面的 commit 是不能通过测试的。 每个 step 都是一个或多个 commit，可以一个一个 commit 来看每个步骤到底改了什么 commit 大致分为几类，根据 commit message 分为： commit message 这个 commit 做了啥 BUGFIX ... / fix ... 修正以前实现的 bug step *. s* .... 完成某 step（后面 s1..s6 是六个大步骤，step 是小步骤） ... refactor ... 代码重构 实验框架 Python-ANTLR 大致思路和实验指导书相同，但有一些小区别。 代码结构 下面是 12 个 step 完全做完以后 minidecaf 中，各个主要文件和目录的作用。 minidecaf ├── __init__.py ├── __main__.py ├── main.py main。顶层逻辑，minidecaf 从这里开始执行 ├── utils.py │ ├── asm 编译器后端：IR 到汇编 │ ├── command.py 汇编中可能出现哪几种元素 │ ├── __init__.py 后端通用框架 │ └── riscv.py RISC-V 对于通用框架的实现 │ ├── frontend 编译器前端：词法语法分析、名称解析、类型检查 │ ├── __init__.py 把 namer/irgen/typer 几个阶段包装一下给 main 用 │ ├── irgen.py IR 生成阶段 │ ├── namer.py 名称解析阶段 │ ├── typer.py 类型检查阶段 │ └── types.py 类型定义和类型规则（给 typer 用的） │ ├── generated ANTLR 生成的代码放在这里面 │ └── __init__.py │ ├── ir IR 的定义 │ ├── __init__.py 定义 IR 的函数/全局变量/程序 │ ├── instr.py 各 IR 指令 │ └── visitor.py 后端实现为一个 IR visitor │ ├── CommonLex.g4 词法定义，就是 ../specs/CommonLex.g4 ├── MiniDecaf.g4 语法定义，就是 ../specs/s6.g4 └── requirements.txt minidecaf 作为 python 包的依赖 IR 的区别 我们的 IR 和指导书一样，但有些名字有些不同 Step 指导书的 IR Python-ANTLR 备注 1 push Const 1 ret Ret 2 neg, not, lnot Unary 3,4 add, sub, mul, div, rem, eq, ne, lt, le, gt, ge, land, lor Binary / 实验指导书中没有 Comment 5 pop Pop 5 load Load 5 store Store 5 frameaddr FrameSlot 设参数是 k，则 frameslot k 最终在 k(fp)，而 frameaddr k 在 -12-4*k(fp) 6 label Label 6 br, beqz, bnez Branch 9 globaladdr GlobalSymbol 9 call Call 并且栈帧也略有不同，fp 的位置有变化。 所以局部变量的位置不是 -12(fp)、-16(fp) 而是 -4(fp)、-8(fp) 以此类推。 step5 不是计算 FRAMESIZE 然后在 prologue 直接 addi sp, sp, -FRAMESIZE，而是每次遇到声明再分配 4 个字节空间，离开声明所在作用域时在释放其空间（待 step7 引入作用域后）。 所以如下代码 int main() { int a=144; { int a=155; } return a; } 会翻译为如下 IR： const 144 # 栈大小加 4、给 a 分配空间；正好 4 就放到 a 的内存里作为初值 const 155 # 给第二个 a 分配空间和设置初值 pop # 离开第二个 a 的作用域，释放第二个 a 所占的空间 frameslot -4 # 这三条都是读取 a 的 load ret pop # 离开第一个 a 的作用域、释放空间（上面有 ret，所以这个 pop 永远不会被执行） step7 名称解析要求我们确定源代码中一个变量名到底是引用哪个变量。 对于每个函数，其名称解析结果放在它的 FuncNameInfo 中，作为一个 dict _v。 变量名用它的 AST 节点表示，例如 ctx.Ident()，其中 ctx 可能是 AtomIdentContext、DeclContext 等。 变量用 Variable 表示，Variable.ident 是变量名，Variable.id 是一个计数器用来区分同名变量。 然后把各个函数的 FuncNameInfo 一起放到 NameInfo 里。 step9 参数处理不使用指导书上说的办法： prologue 里面要把参数从 caller 的栈帧复制到 callee 的栈帧，然后当成普通 decl 处理。 调用约定就是指导书上说的非标准的调用约定（参数从右往左压栈）。 step11 左值分析放到 typer 里面做了，在 class Locator 里面。 它计算左值的地址，然后返回值是一个列表，包含 IR 指令和 AST 结点。 例如 int a[6]; 那么 a[2+3] 的左值地址就是 [ a 的 AST 结点, 2+3 的 AST 结点, const 4, mul, add ]。 类型规则用一个函数表示，参数是操作数类型，函数要加 @TypeRule 修饰。 如果操作数类型满足规则的要求，那么返回结果类型，否则返回一个字符串表示报错消息。 typer 遍历 AST 时记录表达式类型（方法类似Visitor 文档最后一部分），类型保存到 TypeInfo 里。 注意 FuncTypeInfo 只函数本身的参数类型/个数和返回值类型，它和 TypeInfo 的关系与 FuncNameInfo 和 NameInfo 的关系不同。 "},"docs/ref/java-xxy.html":{"url":"docs/ref/java-xxy.html","title":"Java-ANTLR","keywords":"","body":"Java-ANTLR 这个文档用来介绍 Java-ANTLR，以及解释它的实现和指导书的不同。 概述 本参考实现基于 Java （JDK 1.4）语言和 Gradle 项目构建工具，使用 ANTLR 工具进行词法语法分析。 本参考实现具有以下特点： 基于ANTLR的词法语法分析，并且使用 Gradle 的 ANTLR 插件，十分简单易用； 单遍遍历，代码很短。 本框架预计会有 12 个 commit 来展现完成每个 step 的过程，不过助教还在整理代码，目前整理到了 step 1 (updated at 9.15)。 环境配置 可见于这里。 代码结构 下面是最终完整实现的 minidecaf 编译器中的代码结构 src/main ├── antlr/minidecaf/ │ └── MiniDecaf.g4 ANTLR 语法文件 ├── java/minidecaf/ │ ├── Main.java 主体驱动部分 │ ├── MainVisitor.java 主体编译逻辑 │ ├── Type.java 基本类型，包括“无类型”、整型和指针 │ ├── FunType.java 函数类型 │ └── Symbol.java 符号 ├── build.gradle gradle 构建脚本 └── settings.gradle gradle 配置文件 与实验指导的区别 本参考框架在分析树上单遍遍历直接生成汇编代码，所以没有 IR。 TODO: 关于后续步骤的更详细的区别会在之后更新。 "},"docs/lab1/part1.html":{"url":"docs/lab1/part1.html","title":"从零开始的 lexer、parser 以及汇编生成","keywords":"","body":"实验指导 step1：词法分析、语法分析、目标代码生成 第一个步骤中，MiniDecaf 语言的程序就只有 main 函数，其中只有一条语句，是一条 return 语句，并且只返回一个整数（非负常量），如 int main() { return 233; }。 第一个步骤，我们的任务是把这样的程序翻译到汇编代码。 不过，比起完成这个任务，更重要的是你能 知道编译器包含哪些阶段，并且搭建起开发的框架 了解基本概念、包括 词法分析、语法分析、语法树、栈式机模型、中间表示 学会开发中使用的工具和设计模式，包括 ANTLR 工具， lalr1 工具，Visitor 模式 等。 根据你选择的语言和实现方式，需要了解的内容可能是不一样的，不是所有内容都需要了解。 step1 的任务很简单，暴力也能做。 但请一步一步按照指导书说的，搭建你的词法语法分析和汇编生成，否则后面你可能需要推翻重写。 词法分析 读内容 *词法分析* MiniDecaf 源文件 --------> 字节流 ----------> Tokens --> ...... --> RISC-V 汇编 词法分析（lexical analysis） 是我们编译器的第一个阶段，实现词法分析的代码称为 lexer ， 也有人叫 scanner 或者 tokenizer。 它的输入 是源程序的字节流 如 \"\\x69\\x6e\\x74\\x20\\x6d\\x61\\x69\\x6e\\x28\\x29\\x7b\\x72\\x65\\x74\\x75\\x72\\x6e\\x20\\x30\\x3b\\x7d\"。 上面的其实就是 \"int main(){return 0;}\"。 它的输出 是一系列 词（token） 组成的流（token stream）1 上面的输入，经过 lexer 以后输出如 [关键字(int)，空白、标识符(main)，左括号，右括号，左花括号，关键字(return)，空白、整数(0)，分号，右花括号]。 如果没有词法分析，编译器看到源代码中的一个字符 '0'，都不知道它是一个整数的一部分、还是一个标识符的一部分，那就没法继续编译了。 为了让 lexer 完成把字节流变成 token 流的工作，我们需要告诉它 有哪几种 token 如上，我们有：关键字，标识符，整数，空白，分号，左右括号花括号这几种 token token 种类和 token 是不一样的。例如 Integer(0) 和 Integer(222) 不是一个 token，但都是一种 token：整数 token。 有些实现把所有关键字都作为一种 token，把关键字 int 和 return 当成 Keyword(int) 和 Keyword(return)，就像上面 Integer(0) 和 Integer(222)。 但也可以把不同关键字作为不同种类的 token，int 是 Int 类型的 token，而 return 是 Return token。 对于每种 token，它能由哪些字节串构成 例如，“整数 token” 的字节串一定是 “包含一个或多个 '0' 到 '9' 之间的字节的字节串”。 词法分析的正经算法会在理论课里讲解，但我们可以用暴力算法实现一个 lexer。 例如我们实现了一个 minilexer（代码）当中， 用一个包含所有 token 种类的列表告诉 lexer 有哪几种 token（上面第 1. 点）， 对每种 token 用正则表达式描述它能被那些字节串构成（上面第 2. 点）。 minilexer 主要目的只是让大家熟悉词法分析的概念和其中涉及到的问题，不用于指导你的实现，在第二小节会给出实现 lexer 的具体指导。 如果你已经比较熟悉词法分析的概念，只是不知道怎么实现，那它对你不会有太大的帮助（但为了回答思考题还是要看）。 细化到代码，Lexer 的构造函数的参数就包含了所有 token 种类。 例如其中的 TokenKind(\"Integer\", f\"{digitChar}+\", ...) 就定义了 Integer 这种 token， 并且要求每个 Integer token 的字符串要能匹配正则表达式 [0-9]+，和上面第 2. 点一样。 你可尝试运行 minilexer，运行结果如下（我们忽略了空白） $ python3 minilexer.py token kind text ----------- ------------------- Int int Identifier main Lparen ( Rparen ) Lbrace { Return return Integer 123 Semicolon ; Rbrace } 本质上，token 是上下文无关语法的终结符，词法分析就是把一个字节串转换成上下文无关语法的 终结符串 的过程。 不过 token 比单纯的终结符多一个属性，就是它的字符串（如 Identifier(main) 的 main），你可以说 token 是有标注的终结符。 语法分析 词法分析 *语法分析* 字节流 ----------> Tokens ----------> 语法树 --> ...... --> RISC-V 汇编 语法分析（syntax analysis） 是紧接着词法分析的第二个阶段，实现语法分析的代码称为 parser 。 它的输入 是 token 流 就是 lexer 的输出，例子上面有 如果输入没有语法错误，那么 它的输出 是一棵 语法树（syntax tree） 比如上面的程序的语法树类似 编译原理的语法树就类似自动机的 语法分析树，不同的是语法树不必表示出实际语法中的全部细节。 例如上图中，几个表示括号的结点在语法树中是可以省略的。 语法分析在词法分析的基础上，又把程序的语法结构展现出来。 有了语法分析，我们才知道了一个 Integer(0) token 到底是 return 的参数、if 的条件还是参与二元运算。 为了完成语法分析，肯定要描述程序语言的语法，我们使用 上下文无关语法 描述 MiniDecaf。 就这一步来说，MiniDecaf 的语法很简单，产生式大致如下，起始符号是 program。 program : function function : type Identifier Lparen Rparen Lbrace statement Rbrace type : Int statement : Return expression Semicolon expression : Integer 一些记号的区别： 形式语言与自动机课上，我们用大写字母表示非终结符，小写字母表示终结符。 这里正好相反，大写字母开头的是终结符，小写字母开头的是非终结符。 并且我们用 : 而不是 -> 隔开产生式左右两边。 同样的，语法分析的正经算法会在课上讲到。 但我们实现了一个暴力算法 miniparser（代码）。 这个暴力算法不是通用的算法，但它足以解析上述语法。 与 minilexer 类似，miniparser 只用于说明概念和问题，不是实现上的指导。 如果你已经比较熟悉语法分析的概念，只是不知道怎么实现，那它对你不会有太大的帮助（但为了回答思考题还是要看）。 你可尝试运行，运行结果如下（下面输出就是语法树的先序遍历） $ python3 miniparser.py program(function(type(Int(int)), Identifier(main), Lparen((), Rparen()), Lbrace({), statement(Return(return), expression(Integer(123)), Semicolon(;)), Rbrace(}))) 前面提到，语法树可以不像语法分析树那样严格。 如果语法树里面抽象掉了程序的部分语法结构，仅保留后续处理实际关心的部分，那样的语法树可以称为 抽象语法树（AST, abstract syntax tree）；而和语法完全对应的树称为 具体语法树。 当然，AST 和语法树的概念没有清楚的界限，它们也常常混用，不必扣概念字眼。 上面 miniparser 的输出就是一棵具体语法树，而它的抽象语法树可能长成下面这样（取决于设计） $ python3 miniparser-ast.py # 假设有个好心人写了 miniparser-ast.py Prog(funcs=[ Func(name=\"main\", type=(\"int\", []), body=[ ReturnStmt(value=Integer(123)) ]) ]) 语义检查 有时我们会用 语法检查 这个词，因为语法分析能发现输入程序的语法错误。 对应语法检查，还有一个词叫 语义检查。 它检查源程序是否满足 语义规范，是否有 语义错误，例如类型错误、使用未定义变量、重复定义等等。 就 step1 来说，我们的语义规范如下。显然，我们要检查的就只是 Integer 字面量没有越界。 1.1. MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2147483648, 2147483647]，补码表示。 1.2. 编译器应当只接受 [0, 2147483647] 范围内的整数（step2 会添加负数支持）。 如果整数超过此范围，编译器应当报错。 1.3. 因为只有一个函数，故函数名必须是 main。 完整的语义规范应包含如下几点。指导书只会包含关键点，避免叙述太冗长。 什么样的代码是 不合法 的。对于不合法的代码，编译器必须报错而不是生成汇编。为了简单起见，我们不会规定和检查具体的报错信息，只是要求必须不能正常生成汇编。 例如 step1 中，如果程序中 int 字面量超过上面的范围，那编译器就应该报错。 如果函数名不是 main，也应该报错。 合法程序中，每个操作的行为应该是什么样的。 例如 return 执行结果是：对操作数求值并作为返回值，然后终止当前函数执行、返回 caller 或完成程序执行。 对于合法程序，你生成的汇编的运行结果须和 gcc 生成的汇编运行结果一致。 什么样的行为是 未定义 的。如果代码在运行时展现未定义行为，编译器不用报错，但它后果是不确定的。 例如有符号整数溢出、数组越界、除以零都是未定义行为。 测例代码不会有未定义行为，不必费心考虑。 语义检查的实现方式很灵活，可以实现成单独的一个阶段，也可以嵌在其他阶段里面。 第一种方式在后面的实验中有，但就 step1 而言，检查 int 范围的工作直接放进 parser 或 lexer 中就行了。 例如我们就把它放到了下一个阶段：目标代码生成里。 目标代码生成 词法分析 语法分析 *目标代码生成* 字节流 ----------> Tokens ----------> 语法树 ----------------> RISC-V 汇编 生成 AST 以后，我们就能够生成汇编了，所以 目标代码生成（target code emission） 是第三也是最后一个步骤，这里目标代码就指 RISC-V 汇编。 它的输入 是一棵 AST 它的输出 是汇编代码 这一步中，为了生成代码，我们只需要 遍历 AST，找到 return 语句对应的 stmt 结点，然后取得 return 的值, 设为 X 2 语义检查，若 X 不在 [-2147483648, 2147483647] 中则报错；并且检查函数名是否是 main。 打印一个返回 X 的汇编程序 针对第 1. 点，我们使用一个 Visitor 模式来完成 AST 的遍历。 同样，我们有一个 minivisitor（代码）作为这个阶段的例子。 Visitor 模式比简单的递归函数更强大，用它可以让以后的步骤更方便。 Visitor 模式速成请看 这里 另外，如果你用于实现编译器的语言支持抽象数据类型和模式匹配，那么 Visitor 模式可能用处有限，你可跳过相关教程。 在这样的语言中遍历 AST 是一件非常简单的事情，没有必要额外介绍方法。 你不用 Visitor 模式，表达程序逻辑也不会很麻烦，甚至还可能更清晰。 针对第 2. 点，我们用 (RISC-V) gcc 编译一个 int main(){return 233;} 就能知道这个汇编程序什么样。 gcc 的输出可以简化，去掉一些不必要的汇编指令以后，这个汇编程序长成下面这样。 编译方法请看 工具链使用。 汇编代码中，li 加载常数 X 到 a0 寄存器。RISC-V 约定 a0 保存返回值，之后 ret 就完成了 return X 的工作。 .text .globl main main: li a0,X ret 运行 minivisitor，输出就是模板中的 X 被替换为了一个具体整数 $ python3 minivisitor.py .text .globl main main: li a0,123 ret 至此，我们的编译器就完成了，它由三个阶段构成：词法分析、语法分析、目标代码生成。 每个阶段都有自己的任务，并且阶段和阶段之间的接口很明确：字节流、token 流、AST、汇编代码。 任务 在不同输入上，运行 minilexer, miniparser 和 minivisitor。 浏览它们的代码（不用完全看懂） 思考题 以下思考题六选四，在实验报告中回答。 minilexer 是如何使得 int 被分析成一个关键字而非一个标识符的？ 修改 minilexer 的输入（lexer.setInput 的参数），使得 lex 报错，给出一个简短的例子。 miniparser 的算法，只有当语法满足什么条件时才能使用？ 修改 minilexer 的输入，使得 lex 不报错但 parser 报错，给出一个简短的例子。 一种暴力算法是：lex 同上但是不进行 parse，而是在 token 流里面寻找连续的 Return，Integer 和 Semicolon，找到以后取得 Integer 的常量 a，然后类似上面目标代码生成。这个暴力算法有什么问题？ 除了我们的暴力 miniparser，形式语言与自动机课中也描述了一种算法，可以用来计算语法分析树。请问它是什么算法，时间复杂度是多少？ 总结 本节引入了很多概念，请仔细消化 Lexer Token Parser 抽象语法树 语义检查 目标代码生成 Visitor 备注 1. 之所以说“流”而不是“列表”，是因为不一定 lexer 一下就把所有的 token 都拿出来，还可以按照后续阶段的需要按需返回 token。 ↩ 2. 当然，就第一个步骤来说，你直接找到 Integer 节点也可以 ↩ "},"docs/lab1/part2.html":{"url":"docs/lab1/part2.html","title":"词法语法分析工具","keywords":"","body":"实验指导 step1：词法语法分析工具 第一部分中，我们已经自己从零开始暴力实现了一个编译器，但是暴力的 minilexer/miniparser 有几个问题： 运行效率较低，minilexer 比正经 lexer 时间复杂度更高（lexer的耗时可以做到只与输入串长度成正比，而与token种类数无关）； 算法太弱，尤其是 miniparser，处理不了越来越复杂的 MiniDecaf。 接下来我们选择更成熟通用的方法，这里你有两种选择 使用工具辅助完成词法语法分析，而不是完全自己编写：请看下面的【工具概述】； 优点：代码量很少，方便。 缺点：要学工具，不能更深入理解 lexer/parser 底层。 完全自己编写 lexer/parser，请看下面的【手写 lexer 和 parser】。 优点：完整理解 lexer/parser。 缺点：要学算法，代码量更大，而且也不可能理解所有常见的parser算法，只能理解你选择的哪一个。 工具概述 从 minilexer/miniparser 的代码可以看出，lexer 和 parser 包含两部分： 被分析的词法/语法的描述。例如 minilexer 的 TokenKind 列表，以及 miniparser 的 rules 字符串； lexer 和 parser 的驱动代码。例如 lex 和 parse 函数。 使用工具，我们只需要完成第 1. 步，描述被分析的词法或者语法。 然后工具从我们的描述，自动生成 lexer 或者 parser 供你使用，十分方便。 所以这类工具被称为 lexer/parser generator，例子有：C 的 lex/yacc、往届使用的 Java 的 JFlex / Jacc、MashPlant 助教的 re2dfa/lalr1。 对有兴趣的同学：除了这类工具以外，还有一类工具称为 parser combinator，多在函数式语言中使用。 最有名的如 Haskell 的 parsec、scala 的 fastparse，rust 的 nom。课程不涉及其中内容。 下面是助教写的一些工具的速成介绍，你可根据你选择的语言和实现方式，从中选择一个学习使用， 你也可以自己另找其他工具自学使用。 ANTLR ANTLR 支持生成很多语言的代码，它的特点是方便易用人性化，请先仿照官网的 “Quick Start” 安装。 和前面环境配置一样，强烈推荐你把 export CLASSPATH... 和 alias... 那几条命令放进 ~/.bashrc 里。 上面官网截图是 MacOS 的用法，Linux 的用法如下： 上面的 wget 如果有 permission error，请运行 sudo wget ...。curl 也一样。 速成文档在这里。 特别注意：如果输入有错误，ANTLR 的 parser 默认会尝试从错误恢复。 但我们实验要求是：如果输入有错，那编译器应该立马报错退出。 因此我们要设置 ANTLR parser 的错误处理为 BailErrorStrategy，使用速成文档的代码中的方法即可。 lalr1 lalr1是 MashPlant 助教自己编写的 parser generator，它用 Rust 编写，可以生成多种目标语言（目前实现了 Rust, C++, Java）。虽然还不能和那些常用的成熟工具链相比，但也已经在 2019 年的编译原理课程中经受住了考验，可靠性是有一定保证的。 lalr1的使用指导在这里。 手写 lexer 和 parser 手写 lexer: 一种可行的做法是沿用minilexer的做法（虽然它效率低，但是我们对效率也没有要求），依次用所有token种类的正则表达式尝试匹配剩余字符串的开头，选择其中最长的匹配，如果有多个长度相等的匹配，则选择最先出现的。 另一种做法是手动模拟DFA执行的过程，根据当前状态和读入的字符转移到下一个状态。例如在初始状态0看到字符'i'，转移到状态1；接着看到'n'，转移到状态2；接着看到't'，转移到状态3。一部分状态下lexer已经识别出一个token，比如这里的状态3，这时如果看到' '，无法继续转移，那么就成功识别了int这个token。 手写 parser: 参见这里。 任务 二选一 如果你选择使用工具：按照你选择的工具，描述 step1 的 MiniDecaf 词法语法（可参考本章规范），并从 AST 生成汇编。 如果你选择不使用工具：实现你自己的 lexer 和 parser，并生成汇编。 "},"docs/lab1/part3.html":{"url":"docs/lab1/part3.html","title":"使用中间码","keywords":"","body":"实验指导 step1：使用中间码 我们继续改进上一步我们得到的编译器，这次要做的是： 使用中间码让编译器更模块化。 栈机器和中间表示 词法分析 语法分析 IR生成 目标代码生成 字节流 ----------> Tokens ----------> 语法树 --------> *IR* --------------> RISC-V 汇编 中间表示（也称中间代码，intermediate representation / IR）是位于语法树和汇编之间的一种程序表示。 它不像语法树一样保留了那么多源程序的结构，也不至于像汇编一样底层。 我们的实验中，使用简单的栈式机 IR，这里是它的一个详细描述。 容易看出，IR 的好处有如下几点 缩小调试范围，通过把 AST 到汇编的步骤一分为二。 通过观察 IR 是否正确生成就能知道：到底是 IR 生成这一小步有问题，还是 IR 到汇编这一小步有问题。 比起 AST 到汇编当成一整个大步骤，分成两个小步，每步代码更少，更容易调试。 实际中，有了 IR 更容易适配不同指令集（RISC-V, x86, MIPS, ARM...）和源语言（MiniDecaf, Decaf, C, Java...）。 不同源语言的 AST 不同，直接从 AST 生成汇编的话，为了支持 N 个源语言和 M 个目标指令集，需要写 N * M 个目标代码生成模块： 如果有了 IR，只需要写 N 个 IR 生成和 M 个汇编生成，一共 N + M 个模块： 我们使用的 IR 是栈式机 IR，它生成很简单、翻译到汇编也很简单。 一些助教的实现中显式地有 IR，以及对应的 IR 生成和从 IR 到目标代码这两个阶段；而另一些助教的实现则没有，他们是直接从 AST 生成汇编。 你的实现可以选择这两种方法中的任何一个，不一定非要显式地生成 IR。 指导书中的 IR 主要目的是更清晰地说明，栈机器上有哪些操作。 就算你直接从 AST 生成汇编，你生成的汇编也是栈机器上的操作，这些操作也需要被准确描述。 而 IR 就完成描述栈式机操作的任务。 从 AST 到 IR 词法分析 语法分析 *IR生成* 目标代码生成 字节流 ----------> Tokens ----------> 语法树 ---------> IR ---------------> RISC-V 汇编 显然，这一步的 输入 是 AST， 输出 是一个 IR 1 序列。 例如前面的 int main(){return 0;} 例子，输出如 [push 0, ret] 每步我们只介绍这一步必须用到的 IR 指令，而不是一开始就介绍所有指令。 对于 step1，我们只需要两个 IR 指令：push、ret，如下表。 指令 参数 含义 IR 栈大小变化2 push 一个整数常数 把一个常数压入栈中 增加 1 ret 无参数 弹出栈顶元素，将其作为返回值返回当前函数 减少 1 并且我们有如下的假设： 考虑源代码中某个表达式被翻译成了一系列 IR 指令，那么执行这些 IR 指令后，IR 栈大小必须恰好增加 1，栈顶就是表达式的值。 显然，整数常量作为表达式，它被翻译为 push 指令，满足假设。 执行任何语句对应的 IR 指令序列，执行完成后 IR 栈大小不变。 就 step1 而言，return 语句也满足这条假设。 执行任何 n 元操作之前，栈顶的 n 个元素就是操作数。 n 元操作将这 n 个元素弹出，进行操作，再把结果压回栈中。 由此，step1 中 AST 翻译到 IR 就很简单了，只需要按照如下规则访问 AST 中的节点： 遇到 Integer(X)：生成一条 push X。 遇到 Return expr ;：先生成 expr 对应的 IR，然后生成一条 ret。 IR 翻译到汇编 词法分析 语法分析 IR生成 *目标代码生成* 字节流 ----------> Tokens ----------> 语法树 ---------> IR ---------------> RISC-V 汇编 栈机器 IR 翻译到汇编非常简单，如下表，多条汇编指令用分号隔开： IR 汇编 push X addi sp, sp, -4 ; li t1, X ; sw t1, 0(sp) ret lw a0, 0(sp) ; addi sp, sp, 4 ; jr ra 简要解释：li t1 X 表示加载立即数 X 到寄存器 t1；RISC-V 和 x86 一样栈顶比栈底的地址低，所以压栈 4 字节是栈指针 sp 减 4。 （RISC-V 的栈顶指针是 sp，类似 MIPS 的 $sp 和 x86 的 %esp 或 %rsp。） a0 存放返回值，ra 存了调用者地址，jr ra 就是子函数返回。 t1 没有什么特殊的含义，只是用来临时存放数据，你可以换成 t0 / t2 / s1 等。 但不要用 s0，因为它保存了栈帧基地址（同 %ebp 和 $fp），后面要用到。 IR 栈的每个元素都是 32 位整数，所以 push 使得 IR 栈大小加 1 在我们这里就体现为 sp 减 4。 完成后，你对于 int main(){return 0;} 应该生成如下汇编 .text .globl main main: addi sp, sp, -4 li t1, 233 sw t1, 0(sp) lw a0, 0(sp) addi sp, sp, 4 jr ra 任务 （可选，推荐）改进你上一步的代码，先生成 IR，再从 IR 生成汇编。 （和 1. 二选一）改进你上一步的代码，用栈机器的思路直接从 AST 生成汇编。 总结 我们引入 IR 来说明栈机器上能执行那些操作，并用 IR 把目标代码生成阶段一分为二。 备注 1. 实际上 push 和 ret 是 IR 的 指令。我们为了简便，有时直接用 IR 代指 IR 指令。 ↩ 2. 注意区分 IR 栈和汇编中的栈。IR 的栈中包含的元素是整数，IR 栈的大小指栈中有多少个整数。对于 IR 的栈不存在“字节”这一概念。 ↩ "},"docs/lab1/antlr.html":{"url":"docs/lab1/antlr.html","title":"ANTLR 使用","keywords":"","body":"ANTLR 使用——以表达式语法为例 使用 ANTLR 工具，我们只需要写出词法和语法分析的 规范（specification）， 然后它会帮我们生成 lexer 和 parser 乃至 visitor，非常方便。 我们用一个简单的表达式语法 1 来介绍 ANTLR，表达式由一系列整数通过加减乘除以及括号构成，例如 (1+3)*4-3-3。 对于 ANTLR，词法和语法分析的规范都写在 .g4 2 文件中，例如我们的表达式的规范是文法: ExprLex.g4和语法: Expr.g4。 无论是词法规范还是语法规范，它们的规范文件结构是一样的，如下。 规范文件中，// 表示注释，规范是大小写敏感的，字符串常量用单引号括起。 开头声明 规范名，需要和文件名一致： // [ExprLex.g4] 词法规范，用 lexer grammar 标识，行尾有分号。 lexer grammar ExprLex; // [Expr.g4] 语法规范，用 grammar 标识，行尾有分号。 grammar Expr; 然后可能有一些 规范自身的设置，见后面 “语法规范” 然后是 一系列规则，规则类似上下文无关语法的产生式。 每条规则包含左右两边，用冒号隔开， 左边 是一个符号，可以由 右边 规约而来。 符号分为 终结符 和 非终结符 ，终结符用大写字母打头，非终结符用小写字母。 类似产生式，如果多条规则的左边相同，它们可以合并写在一起，它们的右手边用竖线隔开。 // [ExprLex.g4] 词法规则，规则末尾有分号。 Integer: [0-9]+; // [Expr.g4] 语法规则，规则末尾有分号 atom : '(' expr ')' // 一个括号括起来的表达式，它可以规约到 atom | Integer // 整数 token 可以规约到 atom ; 词法规范 词法规范描述了 lexer 应该怎么生成，显然词法规范中规则的左边只能是终结符。 除了上面所说的，词法规范还有一点是：规则的右手边是一个正则表达式。 详细用法在这里，一些常见用法如下： // 1. 为了匹配字符串常量，用单引号把它括起来 Lparen: '('; // 2. [0-9] 匹配 (char)'0' 到 (char)'9' 之间任何一个字符，类似其他 regex 的 \\d 或者 [[:digit:]] // 3. 加号 + 表示它前面的片段可以匹配一次或多次，类似有 * 的零次或多次，? 的零次或一次。 // 它们都是贪婪的，会匹配尽量多的次数。和其他 regex 一样，片段可以用 ( ) 分组。 Integer: [0-9]+; // 4. fragment 表示 WhitespaceChar 本身不是一个符号，它只是一个 regex 的片段，lexer 不会产生它的 token。 // 它和 minilexer 中的 whitespaceChar 是一样的。 // 5. [ \\t\\n\\r] 匹配一个空格 (ascii 码 0x20)，或者一个制表符 (0x9)，或者一个换行符 (0xa) 或者一个回车 (0xd) fragment WhitespaceChar: [ \\t\\n\\r]; // 6. Whitespace 匹配输入中的空白。类似 minilexer，\"-> skip\" 表示忽略此终结符，也就是匹配以后不产生对应的 token。 Whitespace: WhitespaceChar+ -> skip; 语法规范 语法规范描述了 parser 应该怎么生成。除了上面说的，还需注意： parser 依赖于 lexer，所以语法规范中需要 导入词法规范 // 导入词法规范 import ExprLex; 其实 ANTLR 不要求你分开 lexer 和 parser，你可以直接把 import 语句换成 ExprLex 里面的所有规则， 效果是一样的。 但分开 lexer 和 parser 更干净，并且也方便 lexer 复用。 各种语言虽然语法差别很大，词法（空白、整数、标识符、标点符号等）却没太大差别。 parser 规则的右手边除了符号以外，还可以有 字符串常量。 如果它能被规约到词法规范里某个符号，那它就等价于那个符号； 否则 ANTLR 内部会生成一个临时终结符 T__xxx，它的规则的右边是那个字符串常量。 mulOp : '*' | '/' ; // 等价于 mulOp : Mul | Div ; 你可以手动给 规则命名。 在生成的 AST 里，atom 对应的结点会被分为两类：atomParen 和 atomInteger， 它们拥有的字段不同，也对应不同的 visit 函数。 atom : '(' expr ')' # atomParen | Integer # atomInteger ; 规则其实是用 EBNF (extended Barkus-Naur form) 记号书写的，EBNF 也是描述上下文无关语法的一种方式。 相对普通的上下文无关语法记号，EBNF 允许你在规则内部使用 | 描述选择、* 或 ? 或 + 描述重复，(和) 分组 3。 例如下面的用法： add // 1. 使用括号分组，分组内部使用 | 描述选择 // 2. 和 EBNF 无关，但 op 是给这个符号的命名，然后 add 的 AST 结点会有一个 op 字段。 : add op=(Add|Sub) mul | mul ; mul // 3. 使用 * 描述零次或多次的重复。+ 和 ? 类似。 : atom (mul atom)* ; 关于 EBNF，再举一个例子：描述零个或多个用逗号隔开的 expr 列表，下面两种写法是等价的，但 EBNF 记号更简短。 // 传统写法 exprList : # emptyExprList | exprList2 # nonemptyExprList ; exprList2 : expr | expr ',' exprList2 ; // EBNF 写法 exprList : (expr (',' expr)*)? ; 运行 ANTLR 安装 ANTLR，设置 CLASSPATH 环境变量，配置 antlr4 和 grun 的 alias 后，运行以下命令 4： $ antlr4 Expr.g4 -visitor # 会自动拉取 import 的 ExprLex.g4。visitor 见后面一小节。 $ ls ExprLexer.java ExprParser.java # 默认生成 Java 的 lexer 和 parser，其他文件不用管 ExprLexer.java ExprParser.java $ javac *.java $ echo \"(1+3)*4-3-3\" > input # 输入文件内容是 (1+3)*4-3-3 $ grun Expr expr -gui input # 输出如下图 你可以尝试把最后一步的 -gui 换成 -tokens、-tree 看看。 接下来，我们给出示例代码，叙述如何使用生成的 lexer 和 parser。 Main.java 是 Java 的示例代码。做完上面步骤后，运行 Main： $ java Main main.py 是 Python 的示例代码。为了运行它，除了安装 ANTLR 你还需要安装 Python 的 ANTLR API，见这里。运行方法如下 $ antlr4 Expr.g4 -Dlanguage=Python3 $ ls ExprParser.py ExprLexer.py # 生成了 Python 的 lexer 和 parser ExprLexer.py ExprParser.py $ python3 main.py main.cpp 是 C++ 的示例代码。运行方法如下 $ antlr4 Expr.g4 -Dlanguage=Cpp $ ls ExprParser.cpp ExprLexer.cpp # 生成了 C++ 的 lexer 和 parser ExprLexer.cpp ExprParser.cpp $ g++ main.cpp ExprLexer.cpp ExprParser.cpp 你的antlr路径/antlr4-cpp-runtime/dist/libantlr4-runtime.a -I 你的antlr路径/antlr4-cpp-runtime/runtime/src -o main $ ./main 最后请你自行确认，对于不合法的输入（例如 1+2+），运行示例代码会发生什么。 Visitor 的使用 ANTLR 默认生成 listener，它允许你在遍历 AST 过程进入结点和离开结点的时候运行一些代码，但我们不用 listener，我们使用 visitor。 首先用参数 -visitor 告诉 ANTLR 生成 visitor 代码。 $ antlr4 Expr.g4 -visitor $ javac *.java visitor 代码在 ExprVisitor.java 和 ExprBaseVisitor.java 中。 前者定义接口，后者是默认实现：只遍历、不做其他事。 public class ExprBaseVisitor extends AbstractParseTreeVisitor implements ExprVisitor { @Override public T visitExpr(ExprParser.ExprContext ctx) { return visitChildren(ctx); } // ... } 从上可以看出，ANTLR 的 visitor 和我们的基本一致： visit 函数返回值的类型是 T 他所谓 context 就是 AST 的结点，每个 context 也有一个 accept 函数接受 visitor 但他的 visitor 还自带一个方法 visitChildren：遍历所有子结点。返回最后一个子结点的返回值。 ANTLR 生成的 python visitor 也差不多 $ antlr4 Expr.g4 -visitor -Dlanguage=Python3 visitor 在 ExprVisitor.py 里。 # ExprVisitor.py class ExprVisitor(ParseTreeVisitor): def visitExpr(self, ctx:ExprParser.ExprContext): return self.visitChildren(ctx) # ... MainEval.java 和 maineval.py 通过表达式求值展现了 visitor 的用法，如上编译后如下运行即可。 输出的 10 就等于 (1+3)*4-3-3。 $ python3 maineval.py 产生式动作 除 Visitor 之外，你也可以通过产生式动作使用 ANTLR。在这两种方式中选择一种即可。 若要使用产生式动作，你需要在产生式下方添加一对大括号，并在大括号里用你选择的编程语言编写动作。以 ANTLR for C++ 为例，产生式动作可以是： atom : '(' expr ')' # atomParen { std::cout 按下述参数告诉 ANTLR 既不用生成 Visitor 也不用生成 Listener。编译运行后，上述代码会在解析括号时输出\"parenthese\"，在解析整数时输出\"integer\"。 $ antlr4 Expr.g4 -no-listener -no-visitor 当然，仅仅输出常量字符串当然是不够的，我们还可以通过 $符号名.text 获得相关符号对应的字符串，例如： atom : '(' expr ')' # atomParen { std::cout 当一个产生式里有两个相同符号时，可以通过别名指定其中之一，例如： expr : lhs=expr '+' rhs=expr { std::cout 为了生成 AST，我们还可以给符号添加返回值。例如，我们定义类 AddNode 表示 AST 中的加法结点，它是 ExprNode 的子类，并具有一个通过左右子结点构造的构造器。我们给 expr 符号添加一个 ExprNode* 类型的返回值。在产生式中获取子符号的返回值，并以此生成当前符号的返回值，那么动作可以写作： expr [returns ExprNode *node] : lhs=expr '+' rhs=expr { $node = new AddNode($lhs.node, $rhs.node); } ; 为了使用你自己定义的 AddNode 结点，你可能还需要调用一些写在别的文件里面的代码，例如通过 C/C++ 中的 #include。在 ANTLR4 for C++ 中，这是通过在 Parser 的 .g4 文件头部添加 @parser::postinclude { #include \"你自己的头文件\" } 块来实现的，ANTLR4 对其它语言支持中可能有不同的使用方法。 最后，我们可以在主程序中获取根节点的返回值。例如： auto tree = parser.expr(); // 取得一棵以 expr 为根的 AST auto node = tree->node; // 根符号的返回值 常见问题 javac 报错一堆 cannot find symbol 没有设置 CLASSPATH，按官网 Quick Start 重新配置。 特别注意 CLASSPATH 最开始有个 .:，表示当前目录也是 classpath。 grun 报错 Can't load Expr as lexer or parser 你 antlr4 以后没有编译 java 文件 我的输入是 1+2 ((( 它竟然不报错 ANTLR 不强制消耗整个输入，所以 parser 做完 1+2 就停了。 可以把 expr: add; 改成 expr: add EOF; antlr4 报错 error(31): ANTLR cannot generate python3 code as of version 4.8 -Dlanguage=Python3 的 P 要大写 备注 1. step1 的 MiniDecaf 语法太简单，不能体现很多 ANTLR 的特性。 ↩ 2. g 是 grammar，4 是 ANTLR 的版本号 4。 ↩ 3. EBNF 本身又有很多记号，有的使用 { ... } 表示重复。我们描述的是 ANTLR 的 EBNF 记号。 ↩ 4. 命令从 https://www.antlr.org/ 中 Samples 的内容修改而来 ↩ "},"docs/lab1/visitor.html":{"url":"docs/lab1/visitor.html","title":"Visitor 模式","keywords":"","body":"Visitor 模式速成 编译器的构造中会使用到很多设计模式，Visitor 模式就是常见的一种。 基础的设计模式都在 OOP 课程中覆盖，这里重提一下 Visitor 模式，顺带介绍一些参考代码用到的 python 技巧。 我们知道，编译器里有很多的树状结构。 最典型的就是，源程序通过上下文无关文法解析后，得到的语法分析树。 Visitor 模式的目的，就是遍历这些树状结构，本质就是一个 DFS 遍历。 下面通过一个例子说明 Visitor 模式。 表达式语法、语法树定义 我们有一个很简单的表达式文法，终结符包括整数和加减乘除模操作符，起始符号是 expr，大致如下 expr -> int | binary int -> Integer binary -> expr '+' expr | expr '-' expr | expr '*' expr | expr '/' expr | expr '%' expr 这个文法有二义性，同样的字符串可能有多个语法分析树。 不过解析字符串、生成语法分析树不是 Visitor 模式的工作。 Visitor 模式只考虑某个确定的语法分析树。 如下面是 20-13*3 的一棵语法分析树 我们在代码里这样定义这个语法分析树（python>=3.6）： class Node: pass class IntNode(Node): def __init__(self, v:int): # 类型标注是给人看的，python 不检查 self.v = v def __str__(self): return f\"({self.v})\" # f-string 特性 class BinopNode(Node): _legalOps = { *\"+-*/%\" } # 使用 unpacking operator，等价于 set('+', '-', '*', '/', '%') def __init__(self, op:str, lc:Node, rc:Node): assert op in BinopNode._legalOps self.op, self.lc, self.rc = op, lc, rc def __str__(self): return f\"({self.lc} {self.op} {self.rc})\" # 我们通过某种手段，得到了这么一个语法分析树 expr1 = BinopNode('*', BinopNode('-', IntNode(20), IntNode(13)), IntNode(3)) print(expr1) # (((20) - (13)) * (3)) 我们忽略了 Expr，不过显然这无伤大雅。 表达式求值 显然，每个语法分析树都对应一个（加好括号）的表达式，比如上面的树就对应 (20-13)*3。 那么我们考虑一个问题：如何对这个表达式求值？ 当然，我们可以让 python 帮我们做 print(eval(str(expr1), {}, {}))， 不过我们下面会用 Visitor 模式实现表达式求值。 写 Visitor 之前，我们看自己实现表达式求值的最简单的方法，一个递归遍历： def dfs(node:Node): if isinstance(node, IntNode): return node.v if isinstance(node, BinopNode): lhs = dfs(node.lc) rhs = dfs(node.rc) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs print(dfs(expr1)) # 21 dfs 函数接受一个结点，然后对这个结点代表的子树进行求值，返回求值结果。 容易看出，dfs 函数根据被遍历的结点类型不同，执行不同的求值逻辑。 那么我们把这些求值逻辑封装到一个类里面，就得到了一个最简单的 Visitor。 class EvaluationVisitor: def visit(self, node:Node): if isinstance(node, IntNode): return self.visitIntNode(node) if isinstance(node, BinopNode): return self.visitBinopNode(node) def visitIntNode(self, node:IntNode): return node.v def visitBinopNode(self, node:BinopNode): # 不确定子结点的类型，所以只能调用 visit 而非 visitIntNode 或者 visitBinopNode lhs = self.visit(node.lc) rhs = self.visit(node.rc) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs print(EvaluationVisitor().visit(expr1)) # 21 上面就是 Visitor 的核心思想，实际使用中我们一般会有两点改进 不使用 isinstance 来判断结点类型，而是调用结点自身的一个 accept 函数 把几个 visitXXX 函数抽象到一个接口里，各种具体的 Visitor 来实现这个接口 改进后的 Visitor 如下。 class Node: def accept(self, visitor): pass class IntNode(Node): # ... 同上 def accept(self, visitor): return visitor.visitIntNode(self) class BinopNode(Node): # ... 同上 def accept(self, visitor): return visitor.visitBinopNode(self) class Visitor: # 默认行为是遍历一遍，啥也不做，这样比较方便 def visitIntNode(self, node:IntNode): pass def visitBinopNode(self, node:BinopNode): node.lc.accept(self) node.rc.accept(self) class EvaluationVisitor(Visitor): def visitIntNode(self, node:IntNode): # ... 同上 def visitBinopNode(self, node:BinopNode): lhs = node.lc.accept(self) rhs = node.rc.accept(self) # ... 同上 总结 从上面可以看到，Visitor 模式的要素有 被访问的对象。例如上面的 Node。 Visitor 封装的 visitXXX，表示对上述对象实施的操作。例如 EvaluationVisitor。 每种被访问的对象在自己的定义中都有一个 accept 函数，并且在 Visitor 里面也对应一个 visitXXX 函数。 有状态的 Visitor subexpr = BinopNode('-', IntNode(20), IntNode(13)) expr1 = BinopNode('*', subexpr, IntNode(3)) 显然，表达式求值的过程中，所有子表达式也都会被求值。 如上，求值 expr1 的过程中，subexpr 也也会被求值。 我们想把子表达式的值记录下来，以后直接使用，就不需要对子表达式重新求值了。 为了实现这点，还是使用上面的 EvaluationVisitor，但我们用一个字典 Node -> int 记录求值结果，并且把字典作为 Visitor 的状态。 class EvaluationVisitor2(Visitor): def __init__(self): self.value = {} # Node -> int 每次 EvaluationVisitor2.visitXXX(self, node) 返回的时候，我们都记录一下 self.value[node] = value，其中 value 是返回值。 我们用一个函数修饰器来完成记录的动作，如下 class EvaluationVisitor2(Visitor): def __init__(self): self.value = {} # Node -> int def SaveValue(visit): # decorator def decoratedVisit(self, node): value = visit(self, node) self.value[node] = value return value return decoratedVisit @SaveValue def visitIntNode(self, node:IntNode): return node.v @SaveValue def visitBinopNode(self, node:BinopNode): lhs = node.lc.accept(self) rhs = node.rc.accept(self) if node.op == \"+\": return lhs + rhs if node.op == \"-\": return lhs - rhs if node.op == \"*\": return lhs * rhs if node.op == \"/\": return lhs / rhs if node.op == \"%\": return lhs % rhs subexpr = BinopNode('-', IntNode(20), IntNode(13)) expr1 = BinopNode('*', subexpr, IntNode(3)) visitor = EvaluationVisitor2() expr1.accept(visitor) print(visitor.value[subexpr]) # 7 print(visitor.value[expr1]) # 21 "},"docs/lab1/ir.html":{"url":"docs/lab1/ir.html","title":"IR 简明介绍","keywords":"","body":"中间代码 中间代码(也称中间表示，Intermediate Representation, IR)是表示程序结构的一种方式，在后续的实验指导中，我们会先介绍怎么由AST生成IR，再介绍怎么由IR生成汇编代码。尽管直接由AST生成汇编代码在我们的实验中也是完全可行的，我们也不强求你使用IR，但是保留这个中间步骤更加符合真实的编译器的工作流程，也能让你的程序结构更加清晰。 一般真实的编译器都有IR这个中间步骤，这是因为IR一般比AST更加接近汇编，同时仍然保存了一些程序中的高级信息，更加适合进行各种优化。IR有很多种类，包括三地址码(Three Address Code, TAC)，静态单赋值形式(Static Single Assignment Form, SSA)，基于栈的IR，等等。如果你感兴趣的话可以自行查阅了解，这里不做要求。 我们的实验指导选择使用基于栈的IR。这种IR的最大特点是中间代码生成和汇编代码生成(不追求性能的话)非常容易编写，但是一般实际的编译器都不会使用它，因为它并不适合进行优化1，这样其实也就失去了IR存在的根本意义之一了。尽管如此，我们的指导还是选择使用基于栈的IR，主要目的是希望体现IR这个结构在实际的编译器中的地位，尽量让大家体会感受编译器的工作流程，只是限于课程的工作量的限制还是没法和实际的编译器做到真正的一致。 基于栈的IR顾名思义需要维护一个运算栈，它最主要的特点在于它的运算指令，例如加法和减法指令这些，是没有显式的操作数的。例如在编程语言中常常会写a = b + c，这里的b和c就是加法操作的操作数，而基于栈的IR中则不存在这样的结构，相当于只用一个加号来表示加法，不给出这个加法的操作数。这样的的运算指令的语义都是从这个运算栈的顶部弹出操作数，进行运算后再把结果压回栈中。 例子：一加到一百 在之后的每个step中，我们都会介绍(我们推荐的)加入IR的新指令。尽管如此，这里为了给大家留下一些直观的印象，还是先定义一套简单的基于栈的IR，并且用它表示一个简单的例子：计算一加到一百的和。 定义如下指令： PUSH x: 往运算栈中压入常数x LOAD var: 将变量var的值读出，压入栈中 STORE var: 从栈顶弹出一个值，写入变量var LABEL l: 定义一个名为l的标号 BZ l: 从栈顶弹出一个值，如果该值等于0，则跳转到标号l执行，否则继续执行下一条指令 B l: 无条件跳转到标号l执行 CMP_LE/ADD: 两条二元运算指令，从栈上依次弹出两个值，分别作为右操作数和左操作数，执行整数二元运算/+，将结果压入栈中 有几点可能是比较容易引起疑惑的，这里简单解释一下： 很多指令(其实是除了CMP_LE/ADD之外的所有指令)都有额外的参数，看起来不符合上面说的\"运算指令没有显式的操作数\"的特点。可以理解成额外参数和操作数是不一样的，前者是静态确定的，例如LOAD var每次执行，读取的都是同一个变量的值；后者是动态确定的，例如ADD每次执行，弹出的栈上的两个值都可能是不一样的 上面提到了\"变量\"的概念，变量是保存在哪里的呢？假如要把这个IR最终翻译成汇编，运算栈显然会用栈来实现，而局部变量其实也只能保存在栈上，虽然保存在很接近的物理区域，但是它们逻辑上并不是运算栈的一部分，对局部变量的写入不应该影响到运算栈，在运算栈上进行的弹栈/压栈操作也不应该影响到局部变量。 上面提到的var，l这样的名字，实际实现的时候可以选择用整数来表示，而下面的程序中为了清晰起见，还是用人可读的名字来表示。 下面我们用这个IR来表示如下的C程序： int sum = 0; int i = 1; while (i 转化的结果如下(#后的是注释)： PUSH 0 STORE sum # int sum = 0; PUSH 1 STORE i # int i = 0; LABEL loop LOAD i PUSH 100 CMP_LE # 计算i 我们有一个 ir.py（代码）能运行上面程序，结果的确是 1+2+...+100=5050. $ python3 ir.py 5050 标有*和**的两条指令在i = 50时执行前后的状态变化如下： 这里局部变量sum和i的保存位置就和上面描述的差不多，与运算栈保存在接近的物理区域，但是二者互不干扰。 执行ADD前，运算栈上恰好有两个元素，也就是前两条指令依次压入栈中的sum和i的值，当前栈顶的值是i的值50。执行ADD时，将这两个值依次弹出，栈顶的值作为右操作数，栈顶下的一个值作为左操作数，执行加法得到1226，再把1226压回栈中，执行完后运算栈上恰好有一个元素1226。 执行STORE sum时，将栈顶的1226弹出，存入sum所在的位置，执行完后sum的值被更新为1226，运算栈为空。 备注 1. 类似Java Bytecode这样的，虽然也属于基于栈的IR，但是实际的Java虚拟机中都会先把它转化成其它容易优化的形式，所以它的意义仅仅是便于生成和传输，几乎不会用于优化。这也启示我们，尽管我们选择了不容易优化的基于栈的IR，但未来还是有拓展的空间，可以把它转化成其他形式再进行优化。 ↩ "},"docs/lab1/manual-parser.html":{"url":"docs/lab1/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 该文档简单展示使用 c 风格代码手写 parser 的过程。 0. 定义 我们的最终目标是这样一个函数，接受 token list 作为输入，输出一个代表整个程序结构的 AST。 parse(token_list) -> Prog 但是在 lab9 之前我们都只有一个 main 函数，所以这里的 Prog 可以暂时简化为 Function。 首先我们先定义 token 和 AST node enum TokenKind { TK_RESERVED, // 保留字，包含关键字和各种符号 TK_IDENT, // 标识符，如变量名、函数名 TK_NUM, // 数字字面量，如 1, 0 }; struct Token { TokenKind kind; char* str; //对应的字符串 // int raw, col; //如果你想得到报错位置，需要在这里记录行号与列号信息 }; struct Prog { Function* func; } struct Func { list stmts; } enum NodeKind{ ND_RETURN, // return 语句 ND_NUM, // 数值字面量 }; struct Node { NodeKind kind; int val; // 用于储存 ND_NUM 类型节点的数值 Node* expr; // 用来储存 ND_RETURN 类型节点返回的表达式节点 }; statement 和 expression 两类节点有较大的区别，推荐区分为不同的两类 Node，这里未作区分，也不会有什么问题。 推荐使用 unique pointer 和 shared pointer 来构建 AST 树。 1. 访问 Token 在 lex 阶段，我们的到了一个 token list，在 parse 阶段，我们需要访问这个 list 构建 AST ，我们需要一套访问接口来方便操作。 // 获得当前正在处理的 token，处理完毕返回 NULL Token* take_token(); // 进入下一个 token 的处理 void next_token(); 这一步实现简单，甚至不一定要抽象为一个函数，请大家自行实现。 2. 框架 解析的过程是对产生式的还原。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer 最上层函数为解析一个 Prog，目前相当与解析一个函数。 Program* parse() { Program* prog = new Program(); Function *fn = function(); prog->func = fn; return prog; } 　非终结符解析函数 parse()中，function()函数代表解析一个非终结符 function，即：从当前的 token 开始，消耗若干个 token，直到解析完成一个function（一个非终极符）。该函数没有输入，返回一个 AST 结点，过程中消耗了 token。接下来本文中类似函数（名称与产生式中非终结符一致）都是类似的含义。 按照生成式，解析一个 function 需要依次解析 type Identifier ( ） { statement }，如下： Function *function() { parse_reserved(\"int\"); // 应该为 type(), 这里做了简化 char *name; parse_ident(name); Function *fn = new Function(name); parse_reserved(\"(\"); parse_reserved(\")\"); parse_reserved(\"{\"); while (!parse_reserved(\"}\")) { fn->nodes.push_back(stmt()); } return fn; } 其中 parser_xxx()代表解析一个终结符。为直接访问 token 的函数，仅仅处理一个 token，与 token 类别一一对应。正如上方的说明，stmt() 表示，消耗一系列 token，解析出一条语句。 对非终极符的解析函数是由其他的非终结符函数、终结符函数和处理AST节点的语句构成，如果你同时完成了名称解析或者类型检查等，你还需要其他功能语句。 终结符解析函数：parser_xxx() // 解析成功返回 true, 否则为 false bool parse_int_literal(int &val); // 解析一个数字字面量，结果通过 val 返回 bool parse_reserved(const char* str); // 解析一个保留字 str bool parse_ident(char* &ident); // 解析一个标识符，结果通过 ident 返回 这些底层的解析函数会处理当前的 token（通过 take_token()）拿到，如果成功会跳过当前 token（也就是调用 next_token()）。 如 parse_reserved() 会检查当前 token 的类型是否为 TK_RESERVED，如果是，检查其字符串是否与给出的一致,如果是，返回 true。以上任意一步失败，返回 false。 如果你想要自己的编译器在发生错误时停止，可以这样。 Function *function() { assert(parse_reserved(\"int\")); // ... } 当然，也可以输出一些错误信息。如果你想得到报错位置，可以令 parse_xxx()返回 token 位置信息。 stmt() 类似 function()的思路，对语句的解析也可以按照生成式进行，目前仅需要解析 return 一种类型的语句。 Node* stmt() { Node* node = NULL; if (parse_reserved(\"return\")) { node = new Node(ND_RETURN); node->expr = expr(); assert(parse_reserved(\";\")); return node; } return node; } 其中, expr()为解析一个表达式的函数，因为目前的 expr()仅仅需要解析一个数字，可以通过调用 parse_int_lliteral()轻松实现。返回一个类型为 ND_NUM的Node就好了。 总结 第一个 lab 的工作看似很简单，但是我们需要搭建一个比较完整的框架来便于后续工作，其实工作量较大。接下来工作会比较轻松。 "},"docs/lab1/spec.html":{"url":"docs/lab1/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step1 语法规范 我们采用 EBNF (extended Barkus-Naur form) 记号书写语法规范，采用类似 ANTLR 的记号： 小写字母打头的是非终结符（如 program），大写字母打头的是终结符（如 Identifier），可以用字符串字面量表示终结符（如 'int'） 后面会用到：( 和 ) 表示分组，| 表示选择，* 零或多次，+ 一或多次，? 零或一次。 很容易通过增加新的非终结符，去掉这些符号。例如 x+ 就可以被替换成新的非终结符 y，并且 y : x | x y。 EBNF 也有很多写法，另一种是用尖括号表示非终结符 ::= 等。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : Integer step1 语义规范 1.1. MiniDecaf 的 int 类型具体指 32 位有符号整数类型，范围 [-2^31, 2^31-1]，补码表示。 1.2. 编译器应当只接受 [0, 2^31-1] 范围内的整数常量, 不支持负整数常量，如果整数不在此范围内，编译器应当报错。引入负号-后，可以用负号配合正整数常量来间接表示负整数常量。 1.3. 如果输入程序没有 main 函数，编译器应当报错。 "},"docs/lab2/intro.html":{"url":"docs/lab2/intro.html","title":"任务概述","keywords":"","body":"实验指导 step2：一元运算符 step2 中，我们要给整数常量增加一元运算：取负 -、按位取反 ~ 以及逻辑非 !。 语法上，我们需要修改 expression 的定义，从 expression : Integer 变成： expression : unary unary : Integer | ('-'|'!'|'~') unary 三个操作的语义和 C 以及常识相同，例如 ~0 == -1，!!2 == 1。 稍微一提，关于按位取反，我们使用补码存储 int；关于逻辑非，只有 0 表示逻辑假，其他的 int 都是逻辑真。 "},"docs/lab2/guide.html":{"url":"docs/lab2/guide.html","title":"实验指导","keywords":"","body":"step2 实验指导 我们按照上一节划分的编译器阶段，分阶段给出 step2 实验指导。 词法语法分析 如果你使用工具完成词法语法分析，修改你的规范以满足要求，剩下的交给工具即可。 语法规范已经给出，词法规范的变化也很简单，新增三个 token：-、~ 和 !。 你的规范和我们的要求等价、能通过测试即可，不用完全一样。 语义检查无需修改。 如果你是手写分析，参见这里。 IR 生成 显然，我们要引入一类 IR 表示一元操作。 一元操作 IR 的含义是：弹出栈顶，对弹出的值做某个一元操作，再把操作的结果值压入栈顶。 换言之，就是直接对栈顶做某个操作。 指令 参数 含义 IR 栈大小变化 neg 无参数 栈顶取负 不变 not 同上 栈顶按位取反 不变 lnot 同上 栈顶取逻辑非 不变 和 step1 一样，这一节所讲的领悟意思即可。 你不用照着实现。 例如你可以把三条指令变成一条 Unary(op)，其中 op 是 \"-\"、\"~\" 或 \"!\"。 你甚至也不必显式转成 IR。 和 step1 一样，采用 Visitor 模式遍历 AST 来生成 IR。除了 step1 的要求，step2 还要求你遍历 AST 时， 遇到一元表达式的时候，先生成子表达式的 IR，然后再根据操作类型生成一个 neg 或 not 或 lnot 所以，~!--3 会翻译成 push 3 ; neg ; neg ; lnot ; not 五条 IR 指令。 汇编生成 很简单，如下表。 IR 汇编 neg lw t1, 0(sp) ; neg t1, t1 ; sw t1, 0(sp) not …… lnot …… 要知道每个操作生成什么样的汇编，可以参考 gcc 的输出。 例如我们想知道取负的汇编，那我们用 gcc 编译 int foo(int x) { return -x; }， 结果如下（记得加 -O3），我们就知道取负是 neg 目标寄存器, 操作数寄存器。 foo: neg a0,a0 ret 仿照上面，自己确定 not 和 lnot 的汇编。 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 本节内容不多，也很简单。 "},"docs/lab2/manual-parser.html":{"url":"docs/lab2/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 节点定义变化 增加三种表达式节点，分别为：按位取反、取负、逻辑取反 struct NodeKind { + ND_NEG, + ND_NOT, + ND_BITNOT, } 这一变化很简单，以后省略。 parse 过程变化 按照产生式变化对应修改即可，很简单。 expression : unary unary : Integer | ('-'|'!'|'~') unary Node* expr() { return unary(); } Node* unary() { if(parse_reserved(\"-\")) { Node* neg = new Node(ND_NEG); neg->expr = unary(); return neg; } //...　`!``~`同理 return num(); } 注意，unary()的解析是递归的，这与产生式是一致的。 "},"docs/lab2/spec.html":{"url":"docs/lab2/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step2 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : unary unary : Integer | ('-'|'!'|'~') unary step2 语义规范 2.1. MiniDecaf 中，负数字面量不被整体作为一个 token。它被看成是一个取负符号、后面是它的绝对值。 所以我们无法用字面量表示 -2147483648，但可以写成 -2147483647-1（待我们加上四则运算后）。 2.2. 运算越界是未定义行为。例如 -(-2147483647-1) 是未定义行为。这一条规则对于后续step引入的运算符也都适用。 "},"docs/lab3/intro.html":{"url":"docs/lab3/intro.html","title":"任务概述","keywords":"","body":"实验指导 step3：加减乘除模 step3 我们要增加的是：加 +、减 -、乘 *、整除 /、模 % 以及括号 ( )。 语法上我们继续修改 expression，变成 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1+2*(4/2+1) == 7。 我们这种表达式语法写法可能比较繁琐，但它有几个好处： 和C99 标准草案保持一致 把优先级和结合性信息直接编码入语法里，见优先级和结合性一节。 "},"docs/lab3/guide.html":{"url":"docs/lab3/guide.html","title":"实验指导","keywords":"","body":"step3 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 对有兴趣的同学：虽然 -2 和 2-3 里面的 - 意义不同，但 lexer 不知道这点（parser 才知道），所以它们都会用同样的 token kind - 表示。 但有时，可能需要后续阶段告诉 lexer（或 parser）一些信息，最经典的例子是 “typedef-name identifier problem”。 我们的表达式语法规范和 C 标准的基本相同，但略显繁琐。 如果你选择的语法分析工具支持优先级和结合性，并且你希望用这些信息来简化语法分析工具的编写，请参考这里。 语义检查无需修改。 如果你是手写分析，参见这里。 IR 生成 我们同样引入一类 IR 表示二元操作。 执行二元操作的 IR 时，两个操作数需要位于栈顶，然后它们被弹出、进行相应操作，再把结果压入栈顶。 指令 参数 含义 IR 栈大小变化 add 无参数 弹出栈顶两个元素，压入它们的和 减少 1 sub 无参数 弹出栈顶两个元素，压入它们的差，顺序如上 减少 1 mul、div、rem 无参数 ……乘除模 减少 1 其中我们规定二元操作的右操作数在栈顶，左操作数在右操作数下面。 举个例子，(10-3)%5 翻译成 IR 是 [push 10 ; push 3 ; sub ; push 5 ; rem] 五条指令， 执行过程中栈变化如图。 类比 step2，生成 IR 时 Visitor 遍历 AST 遇到二元操作，需要（注意 1. 和 2. 的顺序） 首先生成左操作数的 IR（左操作数入栈，栈顶是左操作数） 然后生成右操作数的 IR（右操作数入栈，栈顶是右操作数) 根据操作不同生成对应的二元 IR 上面的 3 步执行完后，栈大小比执行第 1. 步以前增加 1，栈顶就是二元操作的结果。 这符合我们在 step1 中的假设： 考虑源代码中某个表达式被翻译成了一系列 IR 指令，那么从任何初始状态出发执行这些 IR 指令， 完成后 IR 栈大小增加 1，栈顶就是表达式的值。 汇编生成 仿照 step2 所说，用 gcc 自己确定 sub/mul/div/rem 的汇编。 IR 汇编 add lw t1, 4(sp) ; lw t2, 0(sp) ; add t1, t1, t2 ; addi sp, sp, 4 ; sw t1, 0(sp) sub,mul,div,rem …… 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 本节重点是执行过程中栈的变化，以及上面提到的 step1 的假设，参见上面 IR 生成一节。 "},"docs/lab3/precedence.html":{"url":"docs/lab3/precedence.html","title":"优先级和结合性","keywords":"","body":"优先级和结合性 操作符有优先级和结合性的概念，在之前的编程经历中大家应该已经对这两个概念已经有了直观的理解，这里用例子进一步解释一下： 优先级是两个操作符之间的关系，例如*的优先级比+高，所以表达式1 + 2 * 3应该解析成语法树add (1 mul (2 3))（前序表示），不能解析成mul (add (1 2) 3) 结合性是一个操作符的性质，例如-是左结合的1 - 2 - 3应该解析成sub (1 sub (2 3))，不能解析成sub (sub (1 2) 3) 我们给出的语法规范已经表示了这样的性质，因此理论上我们不需要再额外定义操作符的优先级和结合性了。你可以自己试试，按照本步给出的语法规则，上面的两个表达式确实只能解析成我们期望的结果。 但是有一个问题：这样的语法规范虽然是正确的，也确实可以直接用来实现语法分析器了，但并不符合直观：我们一开始学习C或者别的编程语言的时候，讲的就是一个二元表达式由两个子表达式和中间的操作符组成，并且操作符有优先级和结合性。也就是这样的： expression : expression ('+'|'-') expression | expression ('*'|'/'|'%') expression | ('-'|'~'|'!') expression | Integer | '(' expression ')' 当然，它是有歧义的，你也可以自己试试，如果只有这些产生式的话，上面的两个表达式都可以解析成正确或者错误的结果。所以如果想基于这个规范来实现语法分析器，就必须告诉语法分析工具这些操作符的优先级和结合性是什么。 之后每一步给出的语法都是没有歧义，本身就能体现优先级和结合性的。如果你确实想借助优先级和结合性来实现，需要两个步骤： 把我们给出的语法规范转化成类似上面这样“更模糊”，有歧义的语法规范。我们相信这个方向的转化应该是容易的。 指定每个操作符的优先级和结合性。可以参考https://en.cppreference.com/w/c/language/operator_precedence，它给出了C语言操作符的优先级和结合性，因为我们的MiniDecaf语言是C语言的一个子集，所以这张表格也足够我们的语言使用了。 "},"docs/lab3/manual-parser.html":{"url":"docs/lab3/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 struct Node { - Node* expr; + Node* lexpr; + Node* rexpr; } 现在需要储存两个 expression。 parse 过程变化 按照产生式变化对应修改即可，很简单。 expression : additive additive : multiplicative | additive ('+'|'-') multiplicative // ... primary : Integer | '(' expression ')' 加法示例： Node* additive() { Node* node = multiplicative(); while(parse_reserved(\"+\")) { //这里只展示了 `+`, `-`同理 node = new_binary(ND_ADD, node, multiplicative()); } return node; } Node* new_binary(NodeKind kind, Node* lexpr, Node* rexpr); // 类似构造函数，简单赋值 注意左结合性，请思考为何这么写能够保证左结合。如果一种算法是右结合的，应该怎样写呢？ "},"docs/lab3/spec.html":{"url":"docs/lab3/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step3 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step3 语义规范 3.1. 除以零、模零都是未定义行为。 3.2. 除非特别声明，子表达式求值顺序是不确定的。 例如：执行 int a=0; (a=1)+(a=a+1); 之后 a 的值是不确定的（待我们加上变量和赋值运算符后这个问题才会出现）。 "},"docs/lab4/intro.html":{"url":"docs/lab4/intro.html","title":"任务概述","keywords":"","body":"实验指导 step4：比较和逻辑表达式 step4 我们要增加的是： 比较大小和相等的二元操作：、、>=, >, ==, != equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive 逻辑与 &&、逻辑或 || expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality 新特性的语义、优先级、结合性和 C 以及常识相同，例如 1=2 是逻辑真（int 为 1）。 但特别注意，C 中逻辑运算符 || 和 && 有短路现象，我们不要求。 "},"docs/lab4/guide.html":{"url":"docs/lab4/guide.html","title":"实验指导","keywords":"","body":"step4 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查无需修改。 手写分析根据生成式变化修改即可，变化很小。 IR 生成 沿用 step3 加入的二元操作 IR（以及左右操作数的位置），新的 IR 如下。 指令 参数 含义 IR 栈大小变化 eq 无参数 ==（弹出栈顶两个元素，如果相等压入 1，否则压入 0） 减少 1 ne 无参数 ……!= 减少 1 le 无参数 …… 减少 1 ge 无参数 ……>= 减少 1 lt 无参数 …… 减少 1 gt 无参数 ……> 减少 1 land 无参数 ……&& 减少 1 lor 无参数 弹出栈顶两个元素，将其逻辑或压入栈 减少 1 这样设计的IR中，&&和||都是没有短路性质的。我们的语义规范要求是否实现短路性质都可以。带有短路性质的IR设计参见思考题 3。 汇编生成 对于比较大小和相等的操作，参照 gcc 结果，自行完成汇编生成。 逻辑表达式会麻烦一点，因为 gcc 可能会用跳转来实现&&和||，比较难以理解，所以下面直接给出 land 和 lor 对应的不使用跳转的汇编。 表格中，我们省略了汇编的前缀 lw t1, 4(sp) ; lw t2, 0(sp) 和后缀 addi sp, sp, 4 ; sw t1, 0(sp)。 注意 RISC-V 汇编中的 and 和 or 都是位运算指令，不是逻辑运算指令。 IR 汇编 lor or t1,t1,t2 ; snez t1,t1 land snez t1,t1 ; snez t2,t2 ; and t1,t1,t2 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 step4 和 step3 差别不大。 "},"docs/lab4/spec.html":{"url":"docs/lab4/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step4 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement '}' type : 'int' statement : 'return' expression ';' expression : logical_or logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' step4 语义规范 4.1. 如果 || 和 && 的子表达式有副作用，那么这就是一个未定义行为。 换言之，不对逻辑表达式的短路求值做要求。 4.2. 比较大小是有符号数的比较大小，因此 0xFFFFFFFF == -1 。 "},"docs/lab5/intro.html":{"url":"docs/lab5/intro.html","title":"任务概述","keywords":"","body":"实验指导 step5：局部变量和赋值 这一步我们终于要增加变量了，包括 变量的声明 变量的使用（读取/赋值） 并且，虽然还只有一个 main 函数，但 main 函数可以包含多条语句和声明了。 为了加入变量，我们需要确定：变量存放在哪里、如何访问。 为此，我们会引入 栈帧 的概念，并介绍它的布局。 语法上，step5 的改动如下： function : type Identifier '(' ')' '{' statement* '}' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression primary : Integer | '(' expression ')' | Identifier 并且我们也要增加语义检查了：变量不能重复声明，不能使用未声明的变量。 "},"docs/lab5/guide.html":{"url":"docs/lab5/guide.html","title":"实验指导","keywords":"","body":"step5 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查部分，我们需要检查是否（一）使用了未声明的变量、（二）重复声明变量。 为此，我们在生成 IR 的 Visitor 遍历 AST 时，维护当前已经声明了哪些变量。 遇到变量声明（declaration）和使用（primary 和 assignment）时检查即可。 可以把这个要求和后面提到的符号表结合，放到 IR 生成去做。 如果你是手写分析，参见这里。 IR 生成 为了完成 step5 的 IR 生成，我们需要确定 IR 的栈帧布局，请看 这里。 step1提到，局部变量保存在栈上，这个栈和IR中的运算栈并不是一个概念。 前者指的是汇编中一片可以增长的物理空间（可以称之为物理栈），后者是一个逻辑上的概念。 这二者的关系是，我们之前一直在使用物理栈的空间来实现运算栈。 局部变量存放在物理栈上，运算栈也在物理栈上，它们的内存空间很接近，但是二者是互不干扰的，对运算栈的压栈弹栈操作，不能影响到局部变量的值。 因此我们需要加入访问物理栈内部的 load/store，以及生成栈上地址的 frameaddr 指令。 此外我们还加入一个pop指令，这与上面的讨论没有什么关系，是用于别的用途： 指令 参数 含义 IR 栈大小变化 frameaddr 一个非负整数常数 k 把当前栈帧底下开始第 k 个元素的地址压入栈中 增加 1 load 无参数 将栈顶弹出，作为地址 1 然后加载该地址的元素（int），把加载到的值压入栈中 不变 store 无参数 弹出栈顶作为地址，读取新栈顶作为值，将值写入地址开始的 int 减少 1 pop 无参数 弹出栈顶，忽略得到的值 减少 1 IR 生成还是 Visitor 遍历，并且 遇到读取变量 primary: Identifier 的时候，查符号表确定变量是第几个，然后生成 frameaddr 和 load。 如果查不到同名变量，应当报错：变量未定义 遇到变量赋值的时候，先生成等号右手边的 IR，同上对等号左手边查符号表，生成 frameaddr 和 store。 注意赋值表达式是有值的，执行完它的 IR 后栈顶还保留着赋值表达式的值。这就是为什么 store 只弹栈一次。 遇到表达式语句时，生成完表达式的 IR 以后记得再生成一个 pop，保证栈帧要满足的第 1. 条性质（这里有说） 遇到声明时，除了记录新变量，还要初始化变量。 为了计算 prologue 中分配栈帧的大小，IR 除了一个指令列表，还要包含一个信息：局部变量的个数。 main 有多条语句了，它的 IR 是其中语句的 IR 顺序拼接。 例如 int main(){int a=2; a=a+3; return a;}，显然 a 是第 0 个变量。 那它的 IR 指令序列是（每行对应一条语句）： frameaddr 0 ; push 2 ; store ; pop ; frameaddr 0 ; load ; push 3 ; add ; frameaddr 0 ; store ; pop ; frameaddr 0 ; load ; ret ; 汇编生成 IR 指令到汇编的对应仍然很简单，如下表。 IR 汇编 frameaddr k addi sp, sp, -4 ; addi t1, fp, -12-4*k ; sw t1, 0(sp) load lw t1, 0(sp) ; lw t1, 0(t1) ; sw t1, 0(sp) store lw t1, 4(sp) ; lw t2, 0(sp) ; addi sp, sp, 4 ; sw t1, 0(t2) pop addi sp, sp, 4 但除了把 IR 一条一条替换成汇编，step5 还需要生成 prologue 和 epilogue，并且 ret 也要修改了， 参见栈帧文档。 IR 汇编 ret lw a0, 0(sp) ; addi sp, sp, 4 ; j FUNCNAME_epilogue 另外我们还要求 main 默认返回 0： 5.4. 执行完 main 函数但没有通过 return 结束时，返回值默认为 0。 显然，如果 main 是通过 return 结束的，按照上面的修改一定是跳到 main_epilogue，否则是顺序执行到 main_epilogue 的。 因此我们在 main_epilogue 之前，所有语句之后，加上 push 0 的汇编即可，表示默认返回 0。 备注 1. 我们规定 load 的地址必须对齐到 4 字节，生成 IR 时需要保证。store 也是。 ↩ "},"docs/lab5/stackframe.html":{"url":"docs/lab5/stackframe.html","title":"栈帧","keywords":"","body":"栈帧 所以我们需要确定栈（包括 IR 的栈和汇编的栈）上面到底有那些元素，这些元素在栈上的布局如何。 汇编语言课上提到过 栈帧（stack frame） 的概念，简单回想一下： 每次调用和执行一个函数，都会在栈空间上开辟一片空间，这篇空间就叫“栈帧”。 栈帧里存放了执行这个函数需要的各种数据，包括局部变量、callee-save 寄存器等等。 当然，既然汇编有栈帧, 栈式机 IR 也有栈帧。 我们只有一个函数 main，直到 step9 我们才会有多函数支持。 所以现在关于栈帧的讨论，我们就只考虑一个栈帧。 后面的 step 会深入讨论。 关于栈帧，有两个问题需要说明 栈帧长什么样？即、栈帧上各个元素的布局如何？ 栈帧是如何建立与销毁的？ 第 1. 点，我们规定，程序执行的任何时刻，栈帧分为三块： 栈顶是计算表达式用的运算栈，它可能为空（当前不在计算某表达式的过程中） 然后一片空间存放的是当前可用的所有局部变量 返回地址、老的栈帧基址等信息 下图展现了汇编栈的栈帧结构，以及执行过程中栈中内容的变化。 栈左上方是源代码，右上方是 IR。 粉色背景表示已经执行完的汇编对应的源代码/IR。 假设用户给的输入是 24 12。 从中可以看出，栈帧满足如下性质 每条语句开始执行和执行完成时，汇编栈帧大小都等于 8 + 4 * 局部变量个数 个字节，其中 4 == sizeof(int) 是一个 int 变量占的字节数 （就是 step1 中的假设）任何表达式对应的 IR 序列执行结果一定是：栈帧大小增加 4，栈顶四字节存放了表达式的值。 汇编栈帧底部还保存了 fp 和返回地址，使得函数执行完成后能够返回 caller 继续执行。 把栈帧设计成这样，访问变量就可以直接用 fp 加上偏移量来完成。 例如第 1. 小图中，“读取 a” 就是加载 -12(fp)；第 3. 小图中，“保存到 c” 就是保存到 -20(fp)。 我们只叙述了汇编的栈帧，但 IR 的和汇编的一样（就我们的设计而言），也是三个部分，也要有 old fp 和返回地址。 建立栈帧 进入一个函数后，在开始执行函数体语句的汇编之前，要做的第一件事是：建立栈帧。 每个函数最开始、由编译器生成的用于建立栈帧的那段汇编被称为函数的 prologue。 就 step5 而言，prologue 要做的事情很简单 分配栈帧空间 保存 fp 和返回地址（在寄存器 ra 里） 举个例子，下面是一种可能的 prologue 写法。 其中 FRAMESIZE 是一个编译期已知的常量，等于 8 + 4 * 局部变量个数（这名字不太准确，因为有运算栈，栈帧大小其实不是常量） addi sp, sp, -FRAMESIZE # 分配空间 sw ra, FRAMESIZE-4(sp) # 储存返回地址 sw fp, FRAMESIZE-8(sp) # 储存 fp addi fp, sp, FRAMESIZE # 更新 fp 当然，开始执行函数时需要建立栈帧，结束执行时就需要销毁栈帧。 函数末尾、用于销毁栈帧的一段汇编叫函数的 epilogue，它要做的是： 设置返回值 回收栈帧空间 恢复 fp，跳回返回地址（ret 就是 jr ra） 返回值我们可以直接放在 a0 中，也可以放在栈顶让 epilogue 去加载。 如果是后者，那么上面“栈帧满足如下性质”的 1. 要把 return 作为例外了。 把返回值放在栈顶的话，下面是 epilogue 一种可能的写法。 前缀 FUNCNAME 是当前函数函数名，例如 main，加上前缀以区分不同函数的 epilogue。 FUNCNAME_epilogue: # epilogue 标号，可作为跳转目的地 lw a0, 0(sp) # 从栈顶加载返回值，此时 sp = fp - FRAMESIZE - 4 addi sp, sp, 4 # 弹出栈顶的返回值 lw fp, FRAMESIZE-8(sp) # 恢复 fp lw ra, FRAMESIZE-4(sp) # 恢复 ra addi sp, sp, FRAMESIZE # 回收空间 jr ra # 跳回 caller 就 step5，保存恢复 fp/ra 的确不必要。但是加上会让后面步骤更方便。 需要注意的是，IR 的 ret 指令不能直接 jr ra 了，而是要跳转执行 epilogue，即 j FUNCNAME_epilogue。 变量声明 对于每个变量声明，我们需要 设定变量相对 fp 的偏移量。 在栈帧上预留保存变量空间 第 2. 点已经在 prologue 中完成了，所以重点是第 1. 点。 对每个变量用一个数据结构维护其信息，如：名称、类型（step11）、声明位置、初始值等。 目前阶段，你可以简单的使用一个简单的链表或者数组来保存变量的信息。 这个保存变量符号的表被称为 符号表（symbol table）。 那偏移量可以（一）作为变量数据结构的一个字段、（二）也可以维护一个变量到偏移量的映射、（三）像下面通过某种方法计算得到。 当然，不能用一张符号表覆盖整个程序，程序中不同位置的符号表是不同的。 例如，符号表只会包含被声明的变量的信息，因此在 int a=0; 之后的符号表比之前的多了一个条目表示 a 对应的变量数据结构。 确定变量的偏移量本身倒很容易：从前往后每一个声明的变量偏移依次递减，从 -12(fp) 开始，然后是 -16(fp)、-20(fp) 以此类推。 所以对于每个变量，我们只需在其数据结构中记录：它是从前往后第几个变量。 第 k>=0 个变量的偏移量就是 -12-4*k。 目前我们没有作用域的概念，这样做是没问题的，在第7章引入作用域后，会有一种更加节约空间的做法。 "},"docs/lab5/manual-parser.html":{"url":"docs/lab5/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 推荐你先阅读本节其他部分，了解栈帧和对局部变量的处理方式。 定义变化 struct Node { + Var* var; } // 为了维护变量信息的结构体 + struct Var { + char* name; + int offset; // 在栈中距离 fp 的 offset + Node* init; // 初始化的值 + } parse 变化 语句类别变多了： Node* stmt() { Node* node = NULL; Type* ty; // Return statement if (parse_reserved(\"return\")) { node = new_stmt(ND_RETURN, expr()); assert(parse_reserved(\";\")); return node; } // 局部变量声明 if (type()) { return declaration(); } // 直接由表达式构成的语句，注意 a = 1; 就是此类，有一个表达式的值没有用到 node = expr(); assert(parse_reserved(\";\")); return new_stmt(ND_UNUSED_EXPR, node); } 具体的 declaration()等按照生成式很容易写出来。 declaration : type Identifier ('=' expression)? ';' Node* declaration() { // type() 已经在 stmt() 中完成 char* name; assert(parse_ident(name)); Var* var = new Var(name); // 这里储存已经声明变量的信息，为名称解析做准备 add_local(var); // 如果进行了初始化 if (parse_reserved(\"=\")) { var->init = expr(); } assert(parse_reserved(\";\")); Node* node = new_stmt(ND_DECL); node->var = var; return node; } 在被引用时： Node* primary() { // ... char* name; if (parse_ident(name)) { // find_var 负责寻找同名变量, 在 add_local 维护的数据结构中寻找即可 Var* var = find_var(name); // 引用未声明变量的检查 assert(var); return new_var_node(var); } // ... } [可选]变量信息维护 变量信息的维护可以在 IR 生成中进行，也可以在 parser 的同时进行（本文中就是这样做的），也可以专门作为一个步骤进行。 在处理变量声明时需要维护已声明变量的信息(add_local())，可以使用链表，也可以使用你喜欢的数据结构来维护它。不过要注意 add_local()中应该同时完成 offset 的确定和变量重复定义的检查。在变量被引用时，你需要通过名称找到对应的结构体。 "},"docs/lab5/spec.html":{"url":"docs/lab5/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step5 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' statement* '}' type : 'int' statement : 'return' expression ';' | expression? ';' | declaration declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : logical_or | Identifier '=' expression logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step5 语义规范 5.1. 变量重复声明是错误，使用未声明的变量也是错误。 5.2. 被声明的变量在声明语句完成后，才可以被使用。 int a = a + 1;，这样一条声明完全等价于 int a; a = a + 1;，依据 5.3，这是未定义行为。 另外，step7 引入块语句之后，可能会出现这样的程序片段： int a = 1; { int a = a + 1; } 可能有一种理解是，块语句中 a + 1 中的 a 是外面 int a = 1; 的 a。 但我们和 gcc 以及 C 标准一致，不采用这个理解，而是认为上面的代码包含了未定义行为：int a = a + 1;中使用了未初始化的局部变量。 5.3. （局部）变量初始值不确定，使用不确定的值是未定义行为。 5.4. 执行完 main 函数但没有通过 return 结束时，返回值默认为 0。 5.5. 只有左值能出现在赋值号 = 的左边，合法代码中出现在 = 左边的表达式一定是左值。 表达式被称为左值（lvalue）的必要条件是它能被下面两条规则构造出来： 被声明过的变量是左值； 如果 e 是左值，那么括号括起的 (e) 也是左值。 就 step5 来说，这一点已经被语法保证，无须语义检查。 目前语法上=左边只能是变量名，只要不存在使用未声明的变量的错误，那么必然符合第一种情况。 一个表达式可以满足条件而不是左值，见后面 step11 的讨论。 5.6. 规定赋值表达式的值为，赋值完成后左手边的值。例如 a=(1+3) 的值是 4。 "},"docs/lab6/intro.html":{"url":"docs/lab6/intro.html","title":"任务概述","keywords":"","body":"实验指导 step6： step6 我们要支持 if 语句和条件表达式（又称三元/三目表达式，ternary expression）。 语法上的改动是： if 表达式 statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? 条件表达式 assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional block_item：为了下一阶段做准备 function : type Identifier '(' ')' '{' block_item* '}' block_item : statement | declaration if 语句的语义和 C 以及常识相同，条件表达式优先级只比赋值高。 "},"docs/lab6/guide.html":{"url":"docs/lab6/guide.html","title":"实验指导","keywords":"","body":"step6 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 语义检查无需修改。 如果你是手写分析，参见这里。 注意 step6 引入 block_item 后，declaration 不再是语句，所以 if (a) int b; 不是的合法代码。 这和 C 标准是一致的（不过在C++中这样的代码是合法的，也许这更加符合你的常识）。 悬吊 else 问题 这一节引入的 if 语句既可以带 else 子句也可以不带，但这会导致语法二义性：else 到底和哪一个 if 结合？ 例如 if(a) if(b) c=0; else d=0;，到底是 if(a) {if(b) c=0; else d=0;} 还是 if(a) {if(b) c=0;} else d=0;（其中有大括号，step7中会支持，不过意思不难理解）？ 这个问题被称为 悬吊 else（dangling else） 问题。 如果程序员没有加大括号，那么我们需要通过一个规定来解决歧义。 我们人为规定：else 和最近的 if 结合，也就是说上面两种理解中只有前者合法。 为了让 parser 能遵守这个规定，一种方法是设置产生式的优先级，优先选择没有 else 的 if。 按照这个规定，parser 看到 if(a) if(b) c=0; else d=0; 中第一个 if 时，选择没有 else 的 if； 而看到第二个时只能选择有 else 的 if 1，也就使得 else d=0; 被绑定到 if(b) 而不是 if(a) 了。 IR 生成 显然，我们需要跳转指令以实现 if，同时还需要作为跳转目的地的标号（label）。 我们的跳转指令和汇编中的类似，不限制跳转方向，往前往后都允许。 指令 参数 含义 IR 栈大小变化 label 一个字符串 什么也不做，仅标记一个跳转目的地，用参数字符串标识 不变 beqz 同上 弹出栈顶元素，如果它等于零，那么跳转到参数标识的 label 开始执行 减少 1 bnez 同上 弹出栈顶元素，如果它不等于零，那么跳转到参数标识的 label 开始执行 减少 1 br 同上 无条件跳转到参数标识的 label 开始执行 不变 注意一个程序中的标号，也就是 label 的参数，必须唯一，否则跳转目的地就不唯一了。 简单地维护一个计数器即可，例如 label l1, label l2, label l3 ... Visitor 遍历 AST 遇到一个有 else 的 if 语句，为了生成其 IR，要生成的是 首先是 条件表达式的 IR：计算条件表达式。 beqz ELSE_LABEL：判断条件，若条件不成立则执行 else 子句 跳转没有执行，说明条件成立，所以之后是 then 子句的 IR br END_LABEL：条件成立，执行完 then 以后就结束了 label ELSE_LABEL，然后是 else 子句的 IR label END_LABEL：if 语句结束。 例子：if (a) return 2; else a=2+3; 的 IR 是 frameaddr k ; load，其中 k 是 a 的 frameaddr beqz else_label1，数字后缀是避免标号重复的 push 2 ; ret br end_label1 label else_label1，然后是 push 2 ; push 3 ; add ; frameaddr k ; store ; pop label end_label1 仿照上面，容易写出条件表达式的 IR 应该如何生成，并且同时也能保证满足语义规范 6.4. 和 3.2 不同，条件表达式规定了子表达式的求值顺序。 首先对条件求值。如果条件值为真，然后仅对 ? 和 : 之间的子表达式求值，作为条件表达式的值， 不得对 : 之后的子表达式求值。 如果条件为假，类似地，仅对 : 之后的子表达式求值。 类似，无 else 的 if 语句的 IR 包含 条件表达式的 IR beqz END_LABEL then 子句的 IR label END_LABEL 汇编生成 如下表： IR 汇编 label LABEL_STR LABEL_STR: br LABEL_STR j LABEL_STR2 beqz LABEL_STR lw t1, 0(sp) ; addi sp, sp, 4 ; beqz t1, LABEL_STR bnez LABEL_STR lw t1, 0(sp) ; addi sp, sp, 4 ; bnez t1, LABEL_STR 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 本节主要就是引入了跳转，后面 step8 循环语句还会使用。 备注 1. 见思考题 ↩ 2. 如果 LABEL_STR 在当前函数内，j LABEL_STR 就等于 beqz x0, LABEL_STR ↩ "},"docs/lab6/manual-parser.html":{"url":"docs/lab6/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 增加两种新节点的同时，需要增加 Node 的内容。 struct NodeKind { + ND_IF, + ND_TERN, // :? 运算 } struct Node { + Node* cond; // 储存条件表达式 + Node* then; // 储存条件判断成功时执行的语句（返回的表达式） + Node* else; // 储存条件判断失败时执行的语句（返回的表达式） } 注意，对于 :?运算符，then 和 else 是两个表达式节点， 对于 if 语句，这两个变量是两个语句节点。 解析变化 按照生成式变化改变即可。if 语句示例如下： Node* stmt() { // ... // IF statement if (parse_reserved(\"if\")) { assert(parse_reserved(\"(\")); node = new_node(ND_IF); node->cond = expr(); assert(parse_reserved(\")\")); node->then = stmt(); if(parse_reserved(\"else\")) node->els = stmt(); return node; } // ... } 以后同质化的内容不再展示。 "},"docs/lab6/spec.html":{"url":"docs/lab6/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step6 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' '{' block_item* '}' type : 'int' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step6 语义规范 6.1. int 类型的表达式作为 if 或条件表达式的条件时，非 0（例如 1、-1、1000000007）表示真，0 表示假。 6.2. 如果出现悬吊 else（dangling else），要求 else 优先和最接近的没有匹配else的 if 匹配。 例如 if (0) if (0) ; else ; 等价于 if (0) { if (0) ; else; } 而非 if (0) { if (0) ; } else ;。 6.3. if 的 then 子句和 else 子句不能仅是一个声明。上面的语法规范中已经蕴含了这一点。 例如 if (1) int a; 是不合法的输入 6.4. 和 3.2 不同，条件表达式规定了子表达式的求值顺序。 首先对条件求值。如果条件值为真，然后仅对 ? 和 : 之间的子表达式求值，作为条件表达式的值， 不得对 : 之后的子表达式求值。 如果条件为假，类似仅对 : 之后的子表达式求值。 "},"docs/lab7/intro.html":{"url":"docs/lab7/intro.html","title":"任务概述","keywords":"","body":"实验指导 step7：作用域和块语句 step7 我们要增加块语句的支持。 虽然块语句语义不难，就是把多个语句组成一个块，每个块都是一个作用域。 随之而来一个问题是：不同变量可以重名了。 重名的情况包括作用域内部声明覆盖（shadowing）外部声明，以及不相交的作用域之间的重名变量。 因此，变量名不能唯一标识变量了，同一个变量名 a 出现在代码不同地方可能标识完全不同的变量。 我们需要进行 名称解析（name resolution），确定 AST 中出现的每个变量名分别对应那个变量。 语法上改动不大 function : type Identifier '(' ')' compound_statement compound_statement : '{' block_item* '}' statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement 语义检查我们也要修改了，只有在同一个作用域里，变量才不能重复声明。 当然，如果变量在使用前还是必须先被声明。 "},"docs/lab7/guide.html":{"url":"docs/lab7/guide.html","title":"实验指导","keywords":"","body":"step7 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 至于变量相关的语义检查，因为它们和名称解析密切相关，所以可以放到那里面去，参见后文。 手写分析只需根据产生式变化增量变化即可，如果你将名称解析在语法解析中完成，你可能需要按照本章指导调整你的这部分代码，一点提示。 名称解析 step7 我们需要给自己的编译器新增一个阶段：名称解析，它位于语法分析和 IR 生成之间。 这个词广义上的含义就是：把名称关联到对应的实体。例如网络原理中的 DNS 也是名称解析。 我们所谓 “阶段” 只是逻辑上的。就 MiniDecaf 的实现而言，名称解析也可以放在 IR 生成这一步里，在生成 IR 的同时进行名称解析。 名称解析的阶段任务就是把 AST 中出现的每个变量名关联到对应的变量，它需要遍历 AST，所以实现为 AST 上的一个 Visitor 它的输入 是 parser 给的 AST 它的输出 是上面那棵 AST，但 AST 中所有涉及变量名的结点都增加一个属性，表示此处的变量名到底标识哪个变量 这样的结点有：primary、assignment 和 declaration。 代码中，这样的属性可以实现为指向 变量数据结构 的一个指针。 也可以实现为一个从 AST 结点到变量的映射。 下面是一个例子： 考虑我们有一段代码： { int a=0; a= a+1; if (a) { int a=2; return a; } return a; { int b=12; return a +b; } } 显然其中有三个变量，两个的名字是 a 一个的是 b。不妨把这三个变量记为 a0, a1, b0。 名称解析应当发现这点，并且还要把每个变量名关联到变量，所以它提供的信息类似： { int a=0; // a0 a= // a0 a+1; // a0 if (a) { // a0 int a=2; // a1 return a; // a1 } return a; // a0 { int b=12; // b0 return a // a0 +b; // b0 } } 如果按照定义把这个结果画在语法树上，那么大致如（仅示意，省略了一些不重要的中间结点） 用于储存变量信息的 符号表 的结构也需要改进，以支持作用域。具体的，它需要支持 符号表中，区分不同作用域的变量：支持声明覆盖（shadowing)、检查重复声明 离开某作用域时，要把其中的变量从符号表中删除 为此，我们把符号表改造为一个栈。 (对应上面 1.）栈中每个元素都对应一个开作用域，是一个列表，包含该作用域中至今声明过的所有变量。 程序中不同位置的符号表是不同的；某位置的 开作用域（open scope） 指的是包含该位置的所有作用域。 例如上图中 return a+b; 处，有两个开作用域（声明 a0 和 b0 的），而声明 a1 的作用域不是开作用域。 （对应上面 2.) 每进入一个作用域，就压栈一个空列表；离开作用域就弹栈 在符号表中查找变量名，从栈顶往下查找（所以内层声明才能覆盖外层声明）。 另外， 变量偏移量 和 栈帧大小 的计算方法可以做出修改。例如上面的代码中，我们很清楚a1和b0不可能同时有用，所以它们可以使用同一片物理空间来保存，这样可以节约空间。 如果我们还假设偏移量是 -12-4*frameaddr，那变量的 frameaddr 意义需要变化。 为了保证 step5 中叙述的栈帧性质，变量 frameaddr 的含义要改为是 “在此变量刚声明之前，所有开作用域中的变量总数”。 例如上图中，frameaddr(a1) == frameaddr(b0) == frameaddr(a0)+1。 栈帧大小也 FRAMESIZE 也不能等于 8 + 4 * 局部变量个数 了，它应该是 8 + 4 * 最大的frameaddr。 但是，原来的计算方法也并不是不行，我们完全可以让a1和b0使用不同的物理空间来保存，只是会浪费一些空间而已。 依然可以记录曾经出现过的变量的总数，以此为每个变量分配一个独特的地址，完全不考虑作用域的结构。 最后，名称解析 Visitor 需要 维护符号表，进入块语句（compound_statement）时压栈、离开时弹栈 每次遇到变量名（Identifier）时查找符号表，将其关联到具体的变量，或者报错变量未声明 每次遇到声明（declaration），确定 frameaddr、建立变量并插入符号表，或者报错变量重复声明 IR 生成 无须新增 IR 语句。 块语句的 IR 由其中子语句 IR 顺序拼接而成即可。 汇编生成 无须修改。 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 本节最重要的内容是名称解析。 "},"docs/lab7/manual-parser.html":{"url":"docs/lab7/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 处理块语句时需要记录块若干条语句的信息，可以对 Node 进行这样的修改: struct Node { + std::list body; } "},"docs/lab7/spec.html":{"url":"docs/lab7/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step7 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step7 语义规范 7.1. 不得声明当前作用域已经声明过的同名变量。 7.2. 声明某变量时，只要当前作用域没有同名变量，那么声明即合法。 如果更早的作用于中有同名变量，那么从此声明开始，到此声明所在作用域结束，更早的那个变量声明都被此声明覆盖。 7.3. 使用不在当前开作用域中的变量名是不合法的。 "},"docs/lab8/intro.html":{"url":"docs/lab8/intro.html","title":"任务概述","keywords":"","body":"实验指导 step8：循环语句 step8 我们要增加对循环语句，以及 break/continue 的支持： statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' 循环语句的语义和 C 的也相同，并且我们要检查 break/continue 不能出现在循环外。 "},"docs/lab8/guide.html":{"url":"docs/lab8/guide.html","title":"实验指导","keywords":"","body":"step8 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 值得一提的是，四种循环大同小异，都可以写成 Loop(pre, cond, body, post)，AST 中可以用一个统一的节点表示。 Loop(pre, cond, body, post) AST 结点表示如下的一个循环 { // pre 里面可能有声明，所以需要这个作用域 pre; // 可能是空、也可能是一个 declaration 或者 expression while (cond) { // 可能是空、也可能是一个 expression body; // body 里的 continue 会跳转到这里 post; // 是一个 expression } // break 跳转到这里 } 手写分析只需根据产生式变化增量变化即可。 名称解析 变量名相关的解析不变，但注意按照语义规范 8.2，for 要自带一个作用域，for 的初始化语句中声明的变量相当于在这个作用域中声明的。 因此 for (int i=0; i 是合法的代码， 这是符合C标准的（不过在C++中这样的代码是不合法的，也许这更加符合你的常识）， 它的名称解析如 for (int i=0; // i0 i 另外，我们需要确定：每个 break 和 continue 跳转到的标号是哪个。 实现很容易，类似符号表栈维护 break 标号栈和 continue 标号栈。 遇到 Loop(...) 就（一）创建这个循环的 break 标号和 continue 标号（以及起始标号）； （二）把两个标号压入各自栈里； （三）离开 Loop 的时候弹栈。 和 step6 一样，各个循环的标号需要唯一，简单地后缀一个计数器即可。 每次遇到 break 语句，其跳转目标就是 break 标号栈的栈顶，如果栈为空就报错。continue 语句类似。 IR 生成 无新增 IR。 这一阶段 Visitor 遍历 AST 时，遇到 Loop(pre, cond, body, post)，生成的 IR 如 pre 的 IR label BEGINLOOP_LABEL：开始下一轮迭代 cond 的 IR beqz BREAK_LABEL：条件不满足就终止循环 body 的 IR label CONTINUE_LABEL：continue 跳到这 post 的 IR br BEGINLOOP_LABEL：本轮迭代完成 label BREAK_LABEL：条件不满足，或者 break 语句都会跳到这儿 其中 XXX_LABEL 要和上一步名称解析生成的标号名一样。 遇到 break 语句的 AST 结点时，生成一条 br BREAK_LABEL，其中 BREAK_LABEL 是名称解析确定的标号。 汇编生成 不变。 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 step8 相对容易。 "},"docs/lab8/spec.html":{"url":"docs/lab8/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step8 语法规范 灰色部分表示相对上一节的修改。 program : function function : type Identifier '(' ')' compound_statement type : 'int' compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : primary | ('-'|'~'|'!') unary primary : Integer | '(' expression ')' | Identifier step8 语义规范 为方便，我们称 for 括号中的三个表达式/声明为：init（或 pre）、ctrl、post。 例如 for (i=0; i 中，i=0 是 init，i 是 ctrl，i=i+1 是 post。 8.1. for 循环的控制表达式可以为空，表示循环条件永远为真。 8.2. for 语句自身带一个作用域，给作为 init 的声明用。 如果 for 的循环体是 block 语句块，那么循环体再带一个作用域。 因此 for (int i=0;;i=i+1) { int i=1; return i; } 是合法代码。 8.3. 在循环外使用 break 和 continue 是错误行为。 8.4. break 跳转至最近的循环的结束后第一条语句。 8.5. 如果最近的循环语句是 do 或 while，continue 跳转到执行条件判断； 如果是 for，continue 跳转到执行 post（然后再计算循环条件、结束/继续循环……）。 因此 for (int i=0;i 就等于 for (int i=0;i "},"docs/lab9/intro.html":{"url":"docs/lab9/intro.html","title":"任务概述","keywords":"","body":"实验指导 step9：函数 step9 开始，我们要支持多函数了。 我们需要支持函数的声明和定义： program : function* function : type Identifier '(' parameter_list ')' (compound_statement | ';') parameter_list : (type Identifier (',' type Identifier)*)? 我们还需要支持函数调用： expression_list : (expression (',' expression)*)? unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' 语义检查部分，我们需要检查函数的重复定义、检查调用函数的实参（argment）和形参（parameter）的个数类型一致。 我们不支持 void 返回值，直接忽略 int 返回值即可。 "},"docs/lab9/guide.html":{"url":"docs/lab9/guide.html","title":"实验指导","keywords":"","body":"step9 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 如果你是手写分析，参见这里。 名称解析 类似符号表，我们需要一张表维护函数的信息。 当然，函数不会重名，所以不用解析名称。 这张表主要目的是记录函数本身的信息，方便语义检查。 就 step9 而言，这个信息包括 参数个数（step11 开始还需要记录参数和返回值类型）。对应的语义检查：9.4 是否已经有定义，还是只有声明。对应的语义检查：9.2 IR 生成 step9 之前因为只有一个函数，所以一个 MiniDecaf 程序的 IR 就只是一个指令序列。 现在有了函数了，一个 MiniDecaf 程序的 IR 应当包含一系列 IR 函数，源代码中每个函数都对应一个 IR 函数。 而一个 IR 函数 需要包含 函数自身的信息：函数名、需要 prologue 中分配的“栈帧”大小 3 等； 函数体对应的 IR 指令序列。 对于函数声明和定义，IR 生成的 Visitor 遍历 AST 时， 函数声明结点：没有函数体，无须生成任何 IR 函数定义结点：继续遍历子结点，拿到上面的两种信息，然后创建一个 IR 函数 函数调用是一个比较复杂的操作，见 这里。 为了支持它，我们需要引入 call 指令，并且修改 ret 指令让它不要把栈顶返回值弹出。 指令 参数 含义 IR 栈大小变化 call 一个字符串表示函数名 调用作为参数的函数1，调用完后栈顶是 callee 的返回值 增加 12 ret 无参数 （返回值已经在栈顶了）终止当前函数执行，返回 caller 不变 汇编生成 ret 的汇编不变，call 的如下表。 IR 汇编 call FUNC call FUNC，然后有几个参数就执行几次 pop，然后 addi sp, sp, -4 ; sw a0, 0(sp) 我们已经在 IR 处理了传参，所以汇编生成时不用再考虑传参。 如果你采用非标准的调用约定，prologue 和 epilogue 也不用改，也不用处理 caller-save 寄存器。 否则你可能还需要增加 caller/callee-save 寄存器保存与恢复的代码。 总结 引入了概念 调用约定，并且描述了栈帧的变化。 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 备注 1. call 指令不包含准备参数。 ↩ 2. call 的变化是指，整个 callee 执行完成返回 call 指令后，IR 栈大小相对执行 call 前的大小变化。 ↩ 3. 这个栈帧加了引号，因为它没有包含运算栈 ↩ "},"docs/lab9/calling.html":{"url":"docs/lab9/calling.html","title":"函数调用","keywords":"","body":"函数调用 函数调用是最复杂的一种表达式结构了。 源代码里的一个函数调用，其实包含了下面几个步骤 准备参数，完成传参 （汇编）保存 caller-save 寄存器 真正执行 call 指令（汇编上是 jalr 指令） 执行 call 然后是子函数执行的时间, 直到子函数 ret（汇编上是 jr ra）返回 （汇编）恢复 caller-save 寄存器 拿到返回值，作为函数调用这个表达式的值 这几步操作有时又被称为调用序列（calling sequence） 上面几步都需要我们确定 调用约定（calling convention）： （第 1.、5. 步）参数和返回值都如何准备、该放哪儿？ （第 2.、4. 步）哪些寄存器是 caller-save 的？ （在 prologue/epilogue 中）那些寄存器是 callee-save 的？ 调用约定通常是在汇编层级用到的，汇编语言课上也讲过。 因为汇编语言很底层，没有函数/参数的语言支持，只有标号/地址/寄存器，所以需要规定如何用汇编的语言机制模拟函数调用。 我们为了简单，IR 不提供对函数的语言支持，所以我们同样需要有 IR 的调用约定。 需要注意的是，调用约定只是一种约定，它不唯一。 x86 上常见的就有默认的 cdecl（汇编课讲过）、stdcall、fastcall 等好几种。 只要 caller 和 callee 的调用约定相同，那么函数调用就不会出问题。 RISC-V 的调用约定 32 位 RISC-V 的标准（指 gcc 使用的）的调用约定中，和我们相关的是： caller-save 和 callee-save 寄存器在 \"Unprivileged Spec\" 的 109 页。 返回值（32 位 int）放在 a0 寄存器中 参数（32 位 int）从左到右放在 a0、a1……a7 中。如果还有，则从右往左压栈，第 9 个参数在栈顶。 自己使用 gcc 编译一个有很多参数的函数调用即可验证。 为了简便和方便描述，我们下面使用一种非标准的调用约定。 callee 只需要保存 fp 和 ra，caller 无须保存寄存器 callee 把返回值放在 a0 中，caller 看到返回之后把返回值压入运算栈 参数不用寄存器传递，所有参数从右往左压栈，第 1 个参数在栈顶。 这个调用约定的优点是叙述和实现简单，但不标准。 你当然可以选择实现标准的调用约定，这样你的汇编能够和 gcc 的汇编互相调用，但是难度会大一些。 助教的实现用的也不一定是这个调用约定。 采用这个非标准的调用约定，仿照 step5 我们可以画出函数调用过程中栈帧的变化图。 可见现在栈帧包含四块，从顶向下依次是运算栈、实参、局部变量、fp 和 ra（下图 1.）。 其中还有一个问题就是形参的处理，例如上面 3. 到 4. 过程中，bar 要访问 a，那 a 放在哪儿？ 可以直接使用 foo 栈帧上的实参，那么 a 相对 fp 的偏移量为 0，同理 b 偏移量为 4。 因此 step7 中的偏移量计算方法仅限非参数的局部变量，而第 k>=0 个参数相对于 fp 的偏移量是 4*k。 还有一种方法是把参数当成普通局部变量，在 prologue 中复制到栈帧中局部变量的区域。 IR 的调用约定 对于 IR 类似上面简便的约定： 传参从右到左压栈 返回值放在栈顶 另外，IR 也需要保存返回地址，如果它要作为一门独立的语言，需要被执行的话。 但我们暂时没有这个需求，可以不管它。可以假设 call 指令会把返回地址保存到其他地方，并且同时把当前栈帧设为新函数的。 汇编的 call（就是 jalr）会保存返回地址到 ra，然后 prologue 里会保存 ra 到 callee 栈帧中。 "},"docs/lab9/manual-parser.html":{"url":"docs/lab9/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 程序定义出现变化： struct Program { - Function* func; + std::list funcs; } 程序解析对应发生变化： Program* parse() { Program* prog = new Program(); while(not_end()) { Function *fn = function(); prog->funcs.push_back(fn); } return prog; } 函数解析需要新增对于函数参数的解析，同时函数定义发生变化。 struct Function { + std::list args; } Function *function() { assert(type()); char *name; parse_ident(name); Function *fn = new Function(name); parse_reserved(\"(\"); + fn->args = func_args(); parse_reserved(\")\"); parse_reserved(\"{\"); while (!parse_reserved(\"}\")) { fn->nodes.push_back(stmt()); } return fn; } 对函数调用的节点定义： struct FuncCall { char* name; std::list args; }; struct Node { + FuncCall* func_call; } 对函数调用的解析，同时完成名称解析和参数检查（目前之要求数量相同）。 Node* primary() { // ... char* name; if (parse_ident(name)) { parse_reserved(\"(\") Node *node = new_node(ND_FUNC_CALL); // func_call() 完成对于 args 的解析，循环解析 expr, `,` 即可 assert(node->func_call = func_call(name)); // 不能调用未声明函数 Function* fn; assert(fn = find_func(node->func_call->name)); // 参数必须相同 assert(fn->args.size() == node->func_call->args.size()); return node; } // ... } 这里没有展示如何与局部变量应用做区分，想想该如何做？ "},"docs/lab9/spec.html":{"url":"docs/lab9/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step9 语法规范 灰色部分表示相对上一节的修改。 program : function* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step9 语义规范 9.1. main 默认返回 0，但如果其他函数也没有 return，则它们的返回值未定义。 如果程序尝试使用这个未定义的返回值，那么是一个未定义行为。 如果程序忽略它，那是合法的。 对于感兴趣的同学：C语言中规定只有使用了未定义的返回值才是未定义行为，而C++中规定只要返回值不为void的函数没有return，不管返回值有没有被使用，都是未定义行为。 我们没有支持 void 返回值，但可以忽略返回值达到类似的效果。 “没有 return” 指的是运行时没有通过 return 返回，例如 int f(){if(0)return 0;} 里包含 return 但没有通过 return 返回。 实现的时候，你可以直接让所有函数都默认返回0，语义规范说main之外的函数没有return是未定义行为，未定义行为的意思就是你想怎么处理都可以，所以全部默认返回0当然也是可以的，而且更清晰简单。 9.2. 每个函数只能被定义一次，在定义之前可能有一次前置声明。 多次声明一个函数、以及定义后再声明，均是未定义行为。 多次定义一个函数是错误。 9.3. 函数声明和定义的参数个数、同一位置的参数类型、以及返回值类型必须相同。 现在只有 int 类型，不过以后会有更多类型。 9.4. 调用某函数时，实参和形参的参数个数必须相同，同一位置的参数类型也必须相同。 现在只有 int 类型，不过以后会有更多类型。 9.5. 对于函数定义，参数声明所在作用域就是函数体的块语句对应作用域，参数声明可以看成在函数体开头的声明。 因此函数体块语句中不能重新声明参数，除非又有一层块语句（语义规范 7.2）。 > 就是说，`int f(int x) { int x; }` 不合法，但 `int f(int x) {{ int x; }}` 合法。 "},"docs/lab10/intro.html":{"url":"docs/lab10/intro.html","title":"任务概述","keywords":"","body":"实验指导 step10：全局变量 step10 我们要支持的是全局变量，语法改动非常简单： program : (function | declaration)* 全局变量和局部变量不同，它不是分配在栈上，而是放在某个固定地址，写在汇编的 .bss 段或 .data 段里。 访问它也不能通过 fp 加偏移量，而是需要通过它的符号加载它的地址，通过它的地址访问它。 汇编课上应该讲过，实际中（包括 gcc 和 qemu）使用的可执行文件的格式是 ELF（Executable and Linking Format）。 .text 是其中存放代码的段（section），.bss 和 .data 都是其中存放数据的段，前者零初始化后者须指定初始值。 对有兴趣的同学： 全局变量地址不是被狭义上的编译器（compiler）确定的，也不是被汇编器（assembler）确定的，而是被链接器（linker）或加载器（loader）确定的。 简单的说，狭义上的编译器把源代码变成文本汇编，汇编器把文本汇编给编码到二进制代码，然后通过链接器变成可执行文件，运行时由加载器加载到内存中运行。 当然，广义上的编译器就囊括了这所有阶段。 "},"docs/lab10/guide.html":{"url":"docs/lab10/guide.html","title":"实验指导","keywords":"","body":"step10 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 如果你是手写分析，参见这里。 名称解析 和局部变量一样，全局变量要放进符号表里，名称解析才能解析到它们。 和 step7 一样，符号表是一个栈，其中每个元素对应一个作用域。 全局变量就放在栈底，它们位于全局作用域；名称分析遍历 AST 过程中，栈底元素一直都在，不会被弹出。 全局变量相关的语义检查有： 初始值只能是整数字面量。 有以下几种可行的实现方法： 直接取得初始值对应源代码的字符串，按整数解析（int(text) 或 Integer.parse(text)）即可。 修改语法，全局变量是一个新的 global_declaration : type Identifier ('=' Integer)? ';'。 判断这个expr节点的具体类型，要求它必须是整数常量，并且获取常量值。各种语言中都有相应的机制，只是语法不太一样。 不能重复声明：step7 已经要求同一作用域中不能重复声明变量了。 IR 生成 局部变量需要通过 frameaddr 访问，但全局变量不行，所以我们引入新的 IR 指令用于加载全局变量的地址 指令 参数 含义 IR 栈大小变化 globaladdr 一个字符串，表示符号名 取得符号名对应的全局变量的地址，压入栈中 增加 1 例如 int a=2; int main(){return a;} 中 main 的 IR 是 globaladdr a ; load ; ret。 并且现在，一个 MiniDecaf 程序的 IR 除了一系列 IR 函数，还要包含一系列 IR 全局变量 了，每个需要记录的信息类似： 大小有多少字节 是否有初始值，初始值是多少 汇编生成 汇编可以直接用 la 加载全局变量地址 IR 汇编 globaladdr SYMBOL addi sp, sp, -4 ; la t1, SYMBOL ; sw t1, 0(sp) 每个全局变量还对应一段汇编，不过这段汇编基本就是一个模板替换，我们直接给出结果。 例如 int compiler = 2020; 放到 .data，其汇编如下，compiler 和 2020 可替换成其他变量名和初始值： .data .globl compiler .align 4 .size compiler, 4 compiler: .word 2020 汇编命令（assembler directive）的标准文档在 这里。 不用深入学习汇编命令，它们不是课程内容。 简要解释一下：.data 表示输出到 data 段；.globl a 定义一个全局符号；.word 后是一个四字节整数，是 a 符号所在内存的初始值。 而 int tsinghua; 放到 .bss 的汇编如下，第一个 4 表示大小，第二个 4 表示对齐要求 .comm tsinghua,4,4 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 我们实验中，全局变量相对简单。 但其实全局变量可以展开讲到 linker 和 loader，可惜我们课容量有限不能讨论。 "},"docs/lab10/manual-parser.html":{"url":"docs/lab10/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 Program的构成再次发生变化，需要调整相关定义和解析方式，总体难度较小。这里仅作简单提示。 如何区分全局变量和函数？ 根据产生式，二者关键不同在于名称之后是否带一个　(　。 // 实际上这么写肯定不好 bool is_func() { return type() && parse_ident() && parser_reserved(\"(\"); } "},"docs/lab10/spec.html":{"url":"docs/lab10/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step10 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | Identifier '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!') unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step10 语义规范 10.1. 全局变量的初始值（initializer）必须是整数字面量（例如 2123），不能是非字面量（例如 a 或 f() 或 2+3）。 其实也可以是非字面量的编译期常量，例如 int a=1+3; 编译器可以计算出 1+3==4 然后让它等价于 int a=4;。 但为了实现简便，我们就不要求支持这点。 比如 C 支持全局变量 int a=2+3; 但不允许 int a=f(); 因为 f() 不是常量； 但 C++ 支持 int a=f();，其大致实现为 int a=0; 然后在 main 之前执行的初始化函数中 a=f();。 10.2. 如果没有显式给出初始值，全局变量初始值为 0。 10.3. 不允许重复声明全局变量。 其实 C 是允许全局变量重复声明，只要不重复定义。 int a; int a=2; int a; int main(){return a;} 是合法的 C。不过在C++中这样的代码是不合法的，也许这更加符合你的常识。 为了简单，我们不支持这点。 10.4. 函数定义/声明和全局变量不能重名。 "},"docs/lab11/intro.html":{"url":"docs/lab11/intro.html","title":"任务概述","keywords":"","body":"实验指导 step11：指针 step11 支持的是指针： 增加类型：指针类型 type : 'int' | type '*' 引入左值的概念，修改赋值 assignment : conditional | unary '=' expression 支持取地址操作符 & 和解引用操作符 * unary : postfix | ('-'|'~'|'!'|'&'|'*') unary 支持类型转换 unary : ... | '(' type ')' unary step11 相当复杂，需要我们引入类型系统、左值的概念，并且加入类型检查以及一大堆语义检查。 "},"docs/lab11/guide.html":{"url":"docs/lab11/guide.html","title":"实验指导","keywords":"","body":"step11 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 如果你是手写分析，参见这里。 名称解析 名称解析没有变化。 另外，step11 引入解引用操作符以后，左值的概念更加复杂，因此需要增加 左值分析 1， 排除 1+2=3 或 &(1+2) 这种代码，并且为后续阶段生成左值地址提供信息。 请看左值文档。 左值分析可以放到名称解析中，当然你愿意也可以放到其他阶段或作为一个独立的阶段。 类型检查 step11 开始，要增加一个新阶段：类型检查（type checking）；它在名称解析和 IR 生成之间。 它用于（一）完成和表达式类型相关的一大类语义检查，例如 11.4 和 11.5；（二）计算表达式的类型信息，提供给后续阶段使用。 这一大类的语义检查互相联系很紧密，所以它们被拿出来单独作为一个阶段。 类型检查的阶段文档请看类型检查 当然，指导书上划分的也是逻辑阶段，实现中不必严格遵循。有的助教代码中是 IR 生成和类型检查糅在一起做的。 IR 生成 无须新增 IR 指令。 新语言特性的支持分别需要 对于赋值，和 step5 一样：生成 = 右边的值和左边左值的地址，然后 store。 对于取地址 &，生成其操作数左值的地址作为其值。 解引用 * 的 IR 就是子表达式的 IR 接上一个 load。 类型转换只对类型检查有用，类型转换表达式的 IR 就是被转换的子表达式的 IR。 在实际中，类型转换（cast）可能导致真正的值转换（conversion），例如 (int) 4.5 == 4 就需要生成四舍五入的代码。 汇编生成 无须修改。 任务 首先实现左值分析（无指针的），并通过之前所有测例。 然后搭建类型检查的框架（无指针的），并通过之前所有测例。 最后，加入指针，并且适当修改你的左值分析和类型检查。完整支持本节引入的所有新特性，通过相关测试 实验报告中回答思考题。 总结 本节概念不少，代码也相当多，你需要实现左值分析和类型检查。 备注 1. 这个名字是我们自己取的，但名称解析（name resolution）以及类型检查（type checking）都是约定俗成的专用术语。 ↩ "},"docs/lab11/lvalue.html":{"url":"docs/lab11/lvalue.html","title":"左值","keywords":"","body":"左值 step5 已经提过，赋值表达式中 = 左边必须是左值（lvalue），不能 1+3 = 5， 但当时我们直接在语法上限定了这个条件，没有深入讨论左值。 而 step11 中 & 的操作数也必须是左值，&(2+3) 是没有意义的， 但语法上已经没有这个的保证了 因此 lvalue 的 l 除了 left，又有人说是 location 的意思。 因为比起“能出现在赋值 = 的左边”，左值更本质的特征是，左值是一个 有地址的值（所以才能 &）。 一些例子如： int a; int* p; a = 1; // a 是左值； 1 不是 *&a = 2; // *&a 是左值； 2, &a 不是 p = &a; // p, a 都是左值； &a 不是 *p = 3+a; // *p 是左值； 3, a, 3+a 都不是 由上容易看出： 左值作为操作数时，进行操作需要的是 它的地址； 例如上面 a=1 不需要读取 a 的值，但需要 a 的地址以便把 1 保存到该地址。 非左值（即“右值”，像几个常量和最后一行的 a），操作需要知道的是 它的值； 例如上面 3+a 需要的是 a 的值（对 a 的地址做 load 操作就能加载到 a 的值）。 一个表达式（例如 a）可能有时是左值有时不是，取决于它出现在哪儿。 接着上面第 3. 点说，一个表达式要是左值，需要满足两个条件： 能利用如下规则（语义规范 11.1）构造出来 被声明过的变量是左值； 如果 e 是左值，那么括号括起的 (e) 也是左值。 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值。 如果程序没有类型错误，则 *e 一定是左值，地址是 e 的值。 出现在需要左值的地方（& 操作数、= 左边） 如果需要左值的地方不是左值（例如 1+2=3），那么就要报错。（语义规范 5.5, 11.3） 和上面说的一样，生成代码的过程中，对于左值要生成它们的地址，右值要生成它们的值。 生成左值地址比较容易： 如果左值是变量，其地址就是变量的地址（一个 frameaddr 或者 globaladdr） 如果左值是解引用得到的 *e，其地址就是 e 的值 （语义规范 11.3）所以 &*e 等价于 e，但它不是左值了 括起的左值 (e) 的地址就是 e 的地址 "},"docs/lab11/typeck.html":{"url":"docs/lab11/typeck.html","title":"类型检查","keywords":"","body":"类型检查 正如指导书所说，类型检查目的是 完成和表达式类型相关的一大类语义检查，例如 11.4 和 11.5； 计算表达式的类型信息，提供给后续阶段使用。 说类型检查之前，我们先提一下类型。 类型的概念大家都很熟悉了（非形式化地），无非就是一个值的集合； 然后称表达式 e 的类型是 T 当且仅当 e 的值在 T 的集合里。 就 step11 而言，我们只需要在编译器中定义两种类型： 整数 IntegerType()，表示 32 位有符号 int 指针 PointerType(baseType)，表示指向 baseType 的指针 例如 int** 就是 PointerType(PointerType(IntegerType()))。 文档中为了简洁我们会写成前者，但编译器代码中要写后者。 就 step11 而言实现上不需要这么复杂，甚至你可以就用整数表示类型，例如 0 表示 int，3 表示 int***。 一般不推荐这么做，因为这样对于更复杂的语言特性不是很好拓展，例如struct / 函数指针等等的类型。 但是实际上我们最复杂的类型，也只是在step11的基础上加上数组维度，可以用一个(int, 整数列表)的二元组表示step12中任何表达式的类型，所以这也不失为一种可行的做法。 对有兴趣的同学：这里也有一个概念上的区分，“指针类型（PointerType）” 并不是一个 “类型”。 回顾 step1，我们也说过 Integer 不是一个 Token 而是一个 Token 种类（TokenKind）。 同样的，指针类型是类型的类型，每个 PointerType 的实例对象才真正表示一个具体的指针类型。 有一门专门研究类型的理论叫 type theory，其中类型（type）的类型称为 kind，有兴趣的同学可以参考 Types and Programming Languages、Proofs and Types 等书。 在 step12 的某几条类型规则中，其实就蕴涵了上面的思想。 类型检查阶段是由一系列 类型规则 指导进行的，源代码中操作如果需要类型检查，那它需要先声明自己的类型规则。 对于某个操作，其类型规则包含两个部分： 各个源操作数的类型有什么限制； 如果源操作数的类型满足 1.，那么操作的结果（如果有）是什么类型。 一些类型规则的例子如下 加法 + 只能 int 加 int, 结果还是 int。 如果有了指针算术甚至浮点，加法的类型规则会更加复杂。 if 的条件表达式类型必须是 int，没有操作结果。 变量的类型就是它声明给出的类型。 整数字面量的类型就是整数类型。 解引用操作 *e 要求操作数类型 e 是指针类型 T*，结果类型是 T。 指针能执行的操作很有限，见语义规范 11.5 取地址操作符 &e 对源操作数类型没有要求，结果类型是 PointerType(源操作数类型)。 这里假设已经做过左值检查了，另一种选择是把左值检查和类型检查糅在一起。 另外，虽然操作数类型没有要求，但还是要做类型检查，保证操作数内部没有类型错误。 类型转换（cast）对源操作数类型没有要求，结果类型就是转换的目标类型。 函数调用：见语义规范 9.4，结果类型就是函数的返回类型。 类型检查阶段完成后，为了把类型信息传递给后续阶段，AST 中每个表达式结点都要新增一个属性 type 描述它的类型。 不然后续阶段看到 AST 里面的一个“加”，都不知道是整数加、指针算术（step12）还是浮点加，那 IR/汇编 就没法生成了。 我们还是可以使用一个 AST Visitor 实现类型检查，在其中 对于每个操作结点，先对所有子结点类型检查，完成后子结点的 type 就是源操作数的类型。 然后对照这个操作的类型规则，如果源操作数类型不对那么报错，否则计算该结点的 type。 碰到变量声明（包括形参），遍历声明类型子节点，然后设置其变量数据结构的类型。 如果有初始值，对它执行类型检查，如果它的类型和声明的类型不匹配则报错。 "},"docs/lab11/manual-parser.html":{"url":"docs/lab11/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 新增的两种单目操作和很容易实现，不做赘述。 你需要调整 type()使它能够正确的处理指针类型，一个循环的事，不做赘述。 类型系统 你可以在 parse 阶段一并完成类型检查。 首先，引入类型系统。注意，相关的结构体定义不一定要一样，你可以有自己的定义方式。 enum TypeKind { TY_INT, TY_PTR, }; // 事实上，minidecaf （即便是lab12）不需要这么复杂的类型，你可以仅仅记录指针的重数，请根据自己的理解灵活实现 struct Type { TypeKind kind; // int size; 目前的 minidecaf 中，为一常量 4，lab12 才出现其他长度的类型 // int align; 目前的 minidecaf 中，为一常量 4 Type* base; }; // 注意：Node 的类型的意义是，这个节点所代表的表达式的类型，语句节点没有类型。 struct Node { + Type* ty; // 你可以通过左值计算得到每个节点是不是左值，但真的需要这么复杂吗？ + bool is_lvalue; } // 函数和变量也需要增加类型字段 引入类型比较的函数 bool type_equal(Type*, Type*); 在 parse 的同时计算类型。基础节点（也就是 primary 节点，包含变量、函数调用、数字字面量）返回的类型可以直接确定，其余节点的类型需要根据操作数的类型做计算。比如：如果允许指针加减(这被放在了 lab12 )，那么加法运算的结果可能是整数，也可能是指针，对应节点的类型类似，但是乘法运算一定会返回一个整数。此外还需要在构造节点的同时进行类型检查，具体内容参见这里。 类型计算: Node* factor() { // function call node->ty = fu->ret_ty; // variable node->ty = var->ty; // num node->ty = int_type(); } Node* add() { // 如果允许指针加减，lab11 的加法运算和乘法的类型要求一致，只能计算整数 if(is_integer(node->lexpr) && is_integer(node->rexpr)) { node->ty = int_type(); } } 类型检查： Node* mul() { // 乘法两个操作数必须都是整数 assert(is_integer(node->lexpr) && is_integer(node->rexpr); // 必定产生整数 node->ty = int_type(); } Node* assign() { // 赋值要求双方类型相同 assert(type_equal(node->lexpr, node->rexpr)); // 节点类型就是左操作数或者右操作数的类型 node->ty = node->lexpr->ty; } 类型计算后，你必须保证每一个表达式节点都有正确的类型。类型检查需要在类型出错时报错报错。 此外，对函数的名称解析也需要调整。 左值计算 左值计算可以通过可类型计算相似的方式进行。 强制类型转换 强制类型转换容易与括号表达式（( expr )）相混淆，我们需们需要知道括号后的 token 类型才能作出判断，这里介绍一种作弊的方式：可以不必严格遵循 LL1 的解析方式，我们可以实现一个撤销操作。 void checkout_token(); 功能是与 next_token()相反，这样，我们可以在错误的消耗掉 token 之后回退到之前的状态。 强转可以这样写： Node* cast() { if (parse_reserved(\"(\")) { Type* ty; if(ty = parse_type()) { assert(parse_reserved(\")\")); Node* node = new_cast(unary(), ty); return node; } // 这表明这其实是一个括号表达式，我们应该撤销对于 `(` 的消耗。 // 当然，你也可以在解析 `(` expr `)` 的时候直接跳过对 `(` 的解析。 // 请灵活实现 checkout_token(); } } "},"docs/lab11/spec.html":{"url":"docs/lab11/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step11 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' | type '*' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!'|'&'|'*') unary | '(' type ')' unary postfix : primary | Identifier '(' expression_list ')' primary : Integer | '(' expression ')' | Identifier step11 语义规范 11.1. 构成左值表达式的必要条件除了能通过 5.5 中两条外新增一条： 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值。 因此 int a; *&a=2; 中 *&a 是左值。 11.2. step11 中类型只有 int 和指针类型。禁止隐式类型转换，但允许显式类型转换，只要不违反其他几条规范。 11.3. & 的操作数必须是左值。 所以 &*e 等价于 e，但它不是左值了 11.4. * 的操作数类型必须是指针类型。 11.5. 指针类型的表达式仅能参与如下运算：类型转换、（一元）&、*、（二元）==、!=、=。 指针不得参与乘除模和、一元、比较大小、逻辑运算。step12 会支持算术。 所以 if 和循环语句的条件也不能是指针类型的。 11.6. 空指针是值为 0 的指针。 因为禁止隐式类型转换，所以空指针字面量必须由 0 显示转换而来，例如 (int*) 0。 判断空指针类似：if (p == (int**)0) ; 或 if ((int)p = 0) ;。 11.7. 未对齐的指针是未定义行为。就 MiniDecaf 而言，指针必须对齐到 4 字节边界。 11.8. 如果指针类型和被指向的对象的类型不匹配（例如 step12 的数组/指针越界），对这样的指针解引用就是未定义行为。 这样的指针也包含空指针，所以空指针解引用是未定义行为。 所以 int a; int *p = (int*)a; int x=&*p; 没有包含未定义行为，但 int y=*p; 包含了未定义行为。 这里我们其实和 C 不同，C 中只要指针指向的地方的值的类型和指针的不匹配就是未定义行为，但我们只要不解引用都可以。 "},"docs/lab12/intro.html":{"url":"docs/lab12/intro.html","title":"任务概述","keywords":"","body":"实验指导 step12：数组 step12 支持的是数组和指针算术： 语法上没有太大改动， 数组的声明： declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' 数组和指针的下标操作 postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' 指针算术：语法不变，但允许：指针加/减整数、整数加指针、指针减指针了。 step12 难度不大，但有了数组让我们能够写很多有意思的程序了，step12 之前甚至 MiniDecaf 连快速排序都写不了。 "},"docs/lab12/guide.html":{"url":"docs/lab12/guide.html","title":"实验指导","keywords":"","body":"step12 实验指导 词法语法分析 如果你使用工具完成词法语法分析，修改你的语法规范以满足要求，自行修改词法规范，剩下的交给工具即可。 你可能注意到，虽然数组是一种类型，但我们没有把数组放到 type 中，而是只放在 declaration 里。 这一方面是因为我们并不完全支持 C 的数组（例如我们没有指向数组的指针），另一方面 C 语言本身设计就如此。 对有兴趣的同学：C 的这个设计很麻烦…… 你能区分 int*[] 和 int(*)[] 哪个是指针的数组、哪个是数组的指针吗？ 加上函数指针就更麻烦了，例如声明 int (*(*vtable)[])(void*); 中变量 vtable 的类型是 int (*(*)[])(void*)，含义是 “是一个指针，指向一个数组，数组每个元素是函数指针，函数接受一个 void* 参数，函数返回 int”。 当然，实际中我们一般不会写出这样的代码，更好的方法是用 typedef 包装一下，例如上面的会写成 typedef int (*funcptr_t)(void*) ; typedef funcptr_t vtable_t[] ; vtable_t *vtable。 至于为什么 C 声明被设计成这样，有一个说法是设计者希望声明能够体现变量的用法。例如上面 vtable 的用法是 int v= (*(*vtable)[0])(voidptr_expr)，非常类似其声明。 当然这些都和我们 课程无关 ，我们更不用实现它们。 如果你是手写分析，参见这里。 名称解析 引入数组后，变量的大小不一定是 4 了，例如 int a[5][4] 大小是 80。 因此变量的数据结构还需要增加一个 size 属性，并且变量的 frameaddr 不一定连续了（但每个变量所占的一片内存空间一定连续）。 例如，某种实现中 int main(){ int a[2][2]; int b[2]; int c; } 中， a 的 frameaddr 是 0，b 的是 4，c 的是 6。 另外，我们修改了左值的定义 12.9： 12.9. (更新 11.1）表达式是左值的必要条件是它能被下面几条规则构造出来 被声明过的变量，如果声明类型不是数组，那么它是左值； 如果 e 是左值，那么括号括起的 (e) 也是左值； 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值； 下标运算的结果，如果其类型不是数组类型，那么它是左值。 因为本质上，int a; 的 a 的值被存放在内存中，需要一次访存 load 它的frameaddr 才能取得。 而局部变量 int a[2]; 中的 a 是一个编译期就确定的偏移量常数，它的值就是 fp 加上这个偏移量常数，无须访存。 全局变量 int a[2]; 也是类似的。 另外，数组各维长度必须是正整数，别忘实现对应的语义检查。 类型检查 除了 step11 的 IntegerType 和 PointerType， 我们还需要增加数组类型 ArrayType(baseType, length)。 例如 int *a[10][20] 就是 ArrayType(ArrayType(PointerType(IntegerType()), 20), 10)，特别注意 20 和 10 的位置。 当然，就 MiniDecaf 而言，实现中你可以一口气把所有维长度都存起来，变成 ArrayType(baseType, lengthList)，如上就是 ArrayType(PointerType(IntegerType()), [10, 20]) 如step11中所说，你也可以用不那么通用的方法来表示类型。 因为我们不允许指向数组的指针，所以可以用一个(int, 整数列表)的二元组表示step12中任何表达式的类型。 其中int部分表示数组的元素类型，它只可能是int的若干重指针，比如用 0 表示 int，3 表示 int***。 整数列表部分表示数组维度，如果为空，就是一个普通变量，否则就和上面的lengthList的含义一致。 不管你怎么表示类型，类型检查的规则是不会变的，int *a[10][20]可以表示成ArrayType(ArrayType(PointerType(IntegerType()), 20), 10)或者(1, [10, 20])，但是这只是同一个类型的两种的记录方式而已，不会影响到上层的逻辑。 并且相关类型规则是（语义规范 12.12, 12.13） 对于下标操作 e1[e2]，要求 e1 是指针类型或者数组类型，e2 是整数类型；结果类型是指针/数组的基类型。 注意，这里判断不要写 e1.type == PointerType, 而要写 e1.type instanceof PointerType（或者类似的手段）。 可以写 e2.type == IntegerType() 或者 e2.type instanceof IntegerType。 对于加法操作，除了最基础的 int 加法还要支持指针加法：两个操作数中一个是指针、另一个是 int；结果类型和指针操作数的类型一致。 对于减法操作，除了 int 减法还可能有两种情况 指针减整数：左操作数是指针类型、右操作数是 int；结果类型和第一个操作数的类型相同。（当然，MiniDecaf 禁止 int 减指针） 指针减指针：左右操作数是相同的指针类型，结果类型是 int IR 生成 无须新增 IR 指令。 数组声明 无需 IR 上特别处理，只要注意变量大小不一定是 4 即可。 并且，数组中数据的内存空间是连续的，因此无论数组的原型是几维的，都可以看做是一个一维的大数组。 对于一个数组 int a[d1][d2]⋯[dn]\\mathtt{int}~a[d_1][d_2]\\cdots[d_n]int a[d​1​​][d​2​​]⋯[d​n​​]，可看做是 int a′[d1d2⋯dn]\\mathtt{int}~a'[d_1d_2\\cdots d_n]int a​′​​[d​1​​d​2​​⋯d​n​​]。访问 a[i1][i2]⋯[in]a[i_1][i_2]\\cdots[i_n]a[i​1​​][i​2​​]⋯[i​n​​]，就是访问 a′[i1d2d3⋯dn+i2d3d4⋯dn+⋯+in]a'[i_1d_2d_3\\cdots d_n + i_2d_3d_4\\cdots d_n + \\cdots + i_n]a​′​​[i​1​​d​2​​d​3​​⋯d​n​​+i​2​​d​3​​d​4​​⋯d​n​​+⋯+i​n​​]。 例如，对于数组 int a[3][4][5]，有： a[i] 的地址是 a + (i * 4 * 5) * sizeof(int)； a[i][j] 的地址是 a + [(i * 4 * 5) + (j * 5)] * sizeof(int)； a[i][j][k] 的地址是 a + [(i * 4 * 5) + (j * 5) + k] * sizeof(int)。 下标操作 e1[e2] 需要分数组和指针来说，并且需要类型检查阶段所计算出的表达式类型信息。 如果 e1 是数组： 显然，e1[e2] 的地址是 e1 起始地址加上 e2 的值乘以 S，其中 S 为 e1 基类型的大小。 我们约定，任何数组类型类型表达式的 IR 执行后，栈顶正好多出一个元素，其为该数组的起始地址。 因此，为了生成 e1[e2] 的 IR，先生成 e1 的 IR，再生成 e2 的 IR，再生成三条指令：push S ; mul ; add； 这一步生成的是 e1[e2] 的地址，如果 e1[e2] 不是左值也不是数组，还需要一个 load。 例如 int a[10][20];，设 a 的 frameaddr 为 20，则 a 的 IR 如 frameaddr 20。 而 a[2+3] 的 IR 如下（其中 80 == 20 * sizeof(int)） frameaddr 20 push 2 ; push 3 ; add push 80 mul add 而 a[2+3][17] 作为非左值的 IR 如（如果是左值，去掉最后 load 即可） ...（和上面一样） push 17 push 4 mul add load 如果 e1 是指针： 类似上面，e1[e2] 的地址是 e1 的值加上 e2 的值乘以 S，其中 S 为 e1 的基类型的大小。 因此，为了生成 e1[e2] 的 IR，先生成 e1 的 IR（这里 e1 不是左值），然后生成 e2 的 IR，然后还是 push S ; mul ; add ; load。 不过 e1[e2] 可能作为左值，如果作为左值，那么生成地址的 IR 和上面一样，但去掉最后的 load。 指针算术 也分两类 指针加整数：e1 + e2，其中 e1 是指针、e2 是整数。 注意指针加整数的值是：指针的值，加上整数乘以 S，其中 S 为指针基类型的大小 1。 IR 生成类似上面，请自行设计。 例如 int *p;，设 p 的 frameaddr 是 20，那么 p+61 的 IR 如下（注意其中 push 4 ; mul） frameaddr 20 ; load ; push 61 ; push 4 ; mul ; add。 整数加指针、指针减整数类似。 指针减指针：同上，指针数值相减后，要除以基类型的大小。 因此 int *p 那么 (p+10) - (&p[3]) 等于 7。 汇编生成 无需特别修改。 任务 改进你的编译器，支持本节引入的新特性，通过相关测试。 实验报告中回答思考题。 总结 本节内容本身难度不大，但细节很多（尤其注意指针加整数时，整数要乘一个数），也有相当代码量。 备注 1. MiniDecaf 中指针基类型只能是 int、int*、int**……，所以这里 S 只可能等于 4。 ↩ "},"docs/lab12/manual-parser.html":{"url":"docs/lab12/manual-parser.html","title":"手写简单 parser","keywords":"","body":"手写 parser 简单实例 定义变化 引入了新类型数组，你可以这样定义类型。注意，你可以有自己的定义方式，这种定义稍显复杂。 enum TypeKind { TY_INT, TY_PTR, TY_ARR, }; struct Type { TypeKind kind; // 数组大小可变，其余类型皆为 4 // 数组 size = elem_size * arr_len int size; // 数组元素的类型，可能是另一个数组 Type* base; // 数组长度 int arr_len; // 数组元素大小， elem_size = base->size，可省略 int elem_size; // 数组维度 int arr_dim; }; struct Node { // 用于记录数组被引用时的 index + std::list arr_index; } 声明解析 注意对于类型的解析要分成两部分。 Node* declaration() { Type* ty = type(); char* name; assert(ty && parse_ident(name)); // 这里完成对 index 后缀的解析，最终确定类型 // suffix 消耗若干个 `[` num `]` ty = suffix(ty); // ... return node; } 引用解析 对于 index 后缀的解析比较简单，注意： minidecaf 允许数组和指针两种类型的变量进行 index 运算，但是意义完全不同。 仔细计算最终生成节点的类型。 "},"docs/lab12/spec.html":{"url":"docs/lab12/spec.html","title":"规范","keywords":"","body":"规范 每个步骤结尾的 规范 一节都会对这个步骤中的新特性给出规范，方便大家查阅。 step12 语法规范 灰色部分表示相对上一节的修改。 program : (function | declaration)* function : type Identifier '(' parameter_list ')' (compound_statement | ';') type : 'int' | type '*' parameter_list : (type Identifier (',' type Identifier)*)? compound_statement : '{' block_item* '}' block_item : statement | declaration statement : 'return' expression ';' | expression? ';' | 'if' '(' expression ')' statement ('else' statement)? | compound_statement | 'for' '(' expression? ';' expression? ';' expression? ')' statement | 'for' '(' declaration expression? ';' expression? ')' statement | 'while' '(' expression ')' statement | 'do' statement 'while' '(' expression ')' ';' | 'break' ';' | 'continue' ';' declaration : type Identifier ('[' Integer ']')* ('=' expression)? ';' expression_list : (expression (',' expression)*)? expression : assignment assignment : conditional | unary '=' expression conditional : logical_or | logical_or '?' expression ':' conditional logical_or : logical_and | logical_or '||' logical_and logical_and : equality | logical_and '&&' equality equality : relational | equality ('=='|'!=') relational relational : additive | relational ('|'>'|'|'>=') additive additive : multiplicative | additive ('+'|'-') multiplicative multiplicative : unary | multiplicative ('*'|'/'|'%') unary unary : postfix | ('-'|'~'|'!'|'&'|'*') unary | '(' type ')' unary postfix : primary | Identifier '(' expression_list ')' | postfix '[' expression ']' primary : Integer | '(' expression ')' | Identifier step12 语义规范 12.1. 支持多维数组，但每一维长度只能是正整数常数，不能是零或负数。 所以也没有变长数组 int a[n]; 也没有不定长数组 int a[];。 12.2. 对数组取地址是错误，也不会有指向数组的指针。 这是为了简化实验，否则需要引入 C 中一堆繁复的记号，像 int *a[10] 和 int (*a)[10]，对于实验意义不大。 12.3. 数组声明不能有初始值。局部变量数组初始值未定，全局变量初始值为零。 C 中可以写 int a[2]={1, 2} 但 MiniDecaf 不行。 12.4. 数组首地址对齐要求同元素的对齐要求（4 字节）。 数组的各个元素在内存中是连续的，并且多维的情况下排在前面的维度优先。 例如 int a[3][4][5] 占用了 60 个 int（240 字节）的连续内存，和 int b[60] 一样。 a[1][2][3] 的偏移量是 (1*20+2*5+3) * 4 字节，和 b[33] 一样。 12.5. 下标运算优先级高于一元运算符。 因此 -a[0] 即 -(a[0])。 12.6. 下标运算 a[b] 的操作数类型必须是：a 为指针或数组，b 为 int。 12.7. 下标运算越界后，再取下标运算表达式的值是未定义行为。 类似 11.8，int *a[2]; return a[2]; 包含了未定义行为，return a[-1]; 也包含了，但 return &a[2] - &a[-1] 没有。 12.8. 可以将数组的前几维单独提出，类型还是数组类型，可转换以后赋给一个指针。 例如 int a[2][2][2]，那么 int *p = (int*) a[0]; int *q = (int*) a[1][1]; 是合法的。 但 int x=a[1] 和 int *r=a[0][0][0] 是不合法的。 12.9. (更新 11.1）表达式是左值的必要条件是它能被下面几条规则构造出来 被声明过的变量，如果声明类型不是数组，那么它是左值； 如果 e 是左值，那么括号括起的 (e) 也是左值； 如果 e 是类型为 T* 的表达式，那么 *e 是类型为 T 的左值； 下标运算的结果，如果其类型不是数组类型，那么它是左值。 例如 int a[2][2]，那么 a 和 a[1] 不是左值，但 a[1][1] 是左值。 a[1][1]=2 和 &a[1][1] 都是合法操作，但 &a 和 &a[1] 都不是。 注意，为简便，我们约定 MiniDecaf 的数组变量不是左值，这点和 C 不同。 C 中你可以对数组左值取地址 int a[5]; int (*b)[5]=&a;，b 和 &a[0] 两者类型不同，但地址值相同。 参见 12.2，MiniDecaf 不支持数组的指针，所以上面 &a 是不支持的。 12.10. 数组类型的表达式仅能参与如下运算：类型转换、下标。 和指针不同，数组类型的表达式不能参与赋值。我们（C 也是）不支持 int a[5]; a={1,2,3,4,5}; 这种代码。 12.11. 函数形参不能被声明为数组，传参只能传指针。 C 允许 int foo(int a[]); 和 int bar(int b[5]); 但我们不允许。 12.12. （更新 11.5）指针可参加加减运算，允许 int 加指针和指针加 int，以及指针减 int（不允许 int 减指针）。 运算结果的类型和指针操作数的类型相同。 实际运算时，int 操作数需要乘上指针基类型的大小。 例如 int **p（考虑到 sizeof(int*) == 4），那么 p-2 等价于 p+-2，其汇编类似 addi result, p, -8。 12.13. （更新 11.5）允许两个指针相减，但两个指针类型必须相同。 a 和 b 是同类型的指针，那么 a-b 的结果 c 是一个 int，且满足 a == b+c。 12.14. 空指针参与任何指针算术都是未定义行为。 12.15. （同 11.8）指针运算越界，然后解引用的话，是未定义行为。 "},"REFERENCE.html":{"url":"REFERENCE.html","title":"参考资料","keywords":"","body":"参考资料 Writing a C Compiler: by Nora Sandler An Incremental Approach to Compiler Construction : by Abdulaziz Ghuloum C99 标准草案（和正式标准差不多，用于课程足矣。正式标准需要找 ISO 购买） RISC-V 手册 RISC-V（非官方）汇编指令用法 "}}